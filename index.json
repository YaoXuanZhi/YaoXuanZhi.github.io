[{"categories":["工具"],"content":"从识字以来，已经遭遇了不少烂尾或太监的网络小说，每次遇到，都有很强的动力去想将它续写或者改变它虎头蛇尾的后半段，但是本人的写作水平一般，短篇都未曾驾驭过，更不用说那种动辄几百万字的网络小说，一直没去做，当然也是没那个闲工夫啦。幸运的是，现在在OpenAI等科技巨头的带动下，涌现了很多AI工具，其中就包括一些AI写作应用，ChatGpt4 和通义千问等问答语言模型。这些工具为写作提供了强大的辅助支持。在下面，我将整理下AI_Writer 的开源 AI 写作工具的试用体验 AI-Writer仓库地址\rhttps://github.com/BlinkDL/AI-Writer\r环境部署基于anaconda3的集成环境 # 创建独立的python3运行环境 conda create -n ai_writer python=3.8 conda activate ai_writer # 安装相关依赖包 pip install torch==1.9.1 pip install numpy pip install onnxruntime 克隆仓库 git clone https://github.com/BlinkDL/AI-Writer ","date":"2022-01-05","objectID":"/posts/ai_writer/:0:0","tags":["自动写作","AI-Writer"],"title":"AI写作尝鲜","uri":"/posts/ai_writer/"},{"categories":["工具"],"content":"\r模型部署 ","date":"2022-01-05","objectID":"/posts/ai_writer/:0:1","tags":["自动写作","AI-Writer"],"title":"AI写作尝鲜","uri":"/posts/ai_writer/"},{"categories":["工具"],"content":"\r运行Demo修改run.py的默认配置，官方默认为gpu运行模式，其运行环境配置复杂，尝鲜还是采用cpu模式更简便 cd AI-Writer python run.py ","date":"2022-01-05","objectID":"/posts/ai_writer/:0:2","tags":["自动写作","AI-Writer"],"title":"AI写作尝鲜","uri":"/posts/ai_writer/"},{"categories":["工具"],"content":"\r参考资料 开源：小说 AI 网文写作（支持N卡A卡I卡和CPU）有玄幻和言情模型 炼丹分享：AI 写网文小说的 GPT 模型（100M参数量），以及一种新采样方法 ","date":"2022-01-05","objectID":"/posts/ai_writer/:0:3","tags":["自动写作","AI-Writer"],"title":"AI写作尝鲜","uri":"/posts/ai_writer/"},{"categories":["代码库"],"content":"这是一个简单且易用的条件组分词器，提供了c#、c++、python等多种语言的实现和示例，如果你的项目里需要支持多层条件或组合条件之类的机制，那么它将非常适合你 简易的条件组分词器\rhttps://github.com/YaoXuanZhi/condition_group\r为了说明这个小玩具怎么用，这里以一个游戏项目为例 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:0:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["代码库"],"content":"\r前言在游戏项目的Gameplay开发中，条件配置是很大一项配置内容，而且经常变更，一个通用且可维护性强的条件支持机制就显得尤为重要了，这里提供了一种程序只需要为每类条件做机制支持，最终条件配置交由策划童鞋自行组合的配置方式，而且能够很好兼容excel、csv等配置 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:1:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["代码库"],"content":"\r需求分析策划童鞋设计一个功能开启需求，并且罗列了一些例子，如下所示： 系统功能名 开启条件 武器系统 玩家等级达到5级 坐骑系统 玩家等级达到15级 天赋系统 武器系统升到10级【且】开启了坐骑系统 聊天系统 玩家等级达到30级【且】充值过 公会系统 玩家等级达到100级【或】累计登录30天 上述这些条件又应该是怎么配置到配置表上呢，比如在excel表上怎么配置这些条件呢 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:2:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["代码库"],"content":"\r配置表设计将罗列的开启条件进行整理，如下所示： 配置格式设计如下：Type-Param1-Param2-Param3 Type(条件类型) Desc(描述) Template(模板) Example(示例) is_system_open 系统A是否开启 is_system_open-system_id 武器系统是否开启:is_system_open-weapon_sys system_level 系统A达到B等级 system_level-system_id-need_level 武器系统是否达到10级: system_level-weapon_sys-10 player_level 玩家达到A等级 player_level-need_level 玩家是否达到10级：player_level-10 acc_charge_total 累计充值总额达到A acc_charge_total-need_total 是否累计充值总额已达1000元：acc_charge_total-1000 acc_login_days 累计登录天数达到A acc_login_days-need_days 是否累计登录了30天：acc_login_days-30 各个具体条件已经拆分好了，那么怎么表述它的【且】和【或】关系呢，在此，引入了另外两个特殊符号，如下所示： 符号 作用 \u0026\u0026 完成条件A和条件B的且运算 || 完成条件A和条件B的或运算 那么再来到复杂的条件示例上，它们将会简化成如下配置： 描述：玩家等级达到30级【且】充值过 ==\u003e 配置项：player_level-30 \u0026\u0026 acc_charge_total-1 描述：玩家等级达到100级【或】累计登录30天 ==\u003e 配置项：player_level-100 || acc_login_days-30 最终的配置表格式如下： 系统功能名 注释 开启条件 武器系统 玩家等级达到5级 player_level-5 坐骑系统 玩家等级达到15级 player_level-15 天赋系统 武器系统升到10级【且】开启了坐骑系统 system_level-weapon_sys-10 \u0026\u0026 is_system_open-mount_sys 聊天系统 玩家等级达到30级【且】充值过 player_level-30 \u0026\u0026 acc_charge_total-1 公会系统 玩家等级达到100级【或】累计登录30天 player_level-100 || acc_login_days-30 上述条件配置项已经很像我们编程语言里的条件表达式了，比如C++里面的if statement，与之相比我们还差了一个小括号()的功能和逻辑运算符:非的支持，不过非一般用不上，可以酌情考虑要不要搞，有了小括号()的支持后，我们可以表达更加复杂的条件了，诸如： 描述：(武器系统升至50级 【且】锻造系统升至30级) 或 玩家充值达到10000元 配置项：(system_level-weapon_sys-50 \u0026\u0026 system_level-mount_sys-30) || acc_charge_total-10000 给这类复杂条件起个名字，叫做条件组，因为每个小括号包裹住的条件可以当作一个条件分层组，如果完全没有小括号的话，可以看作它有个隐藏的小括号，同策划童鞋沟通好，达成共识 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:2:1","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["代码库"],"content":"\r程序设计上面已经将相关复杂条件描述的条件配置都设计好了，相关测试用例也收集了一些，那么接下来就是提供功能支持来解析条件配置，并且封装好判断接口，再将各个条件类型的支持给加上 程序实现步骤拆解： 实现一个Tokenizer：解析这个配置项文本，依据其设计好的分割规则，拆分成一个Token数组，然后提取里面的条件块和逻辑运算符和层级关系，举个简单例子：将 system_level-weapon_sys-50 \u0026\u0026 system_level-mount_sys-30 解析成一个数组：system_level-weapon_sys-50、\u0026\u0026、system_level-mount_sys-30 将ConditionToken进行解析并返回结果：将上述例子里的 system_level-weapon_sys-50、system_level-mount_sys-30 进一步解析，并且调用各个系统的数据判断该条件的结果，将结果结合\u0026\u0026逻辑运算符得出结果，可以简化成 result1 \u0026\u0026 result2 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:3:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["代码库"],"content":"\r功能实现根据游戏项目采用的编程语言，参考condition_group_tokenizer 项目本身就是一个简单且易用的条件组分词器，提供了多种语言的实现，包含了c#、c++、python等语言的支持，参考该项目的Demo示例，重载ProxyCondition()方法，在其内部直接一步到位进行步骤2即可 这里贴了Python版的测试用例，其它语言依葫芦画瓢就行 # coding=utf-8 from condition_group_tokenizer import ConditionGroupTokenizer import unittest class PlayerFakeDataComponent: ''' 伪造玩家数据 ''' def __init__(self) -\u003e None: self.buildFakeDatas() def buildFakeDatas(self): ''' 测试用例可以重载该函数 ''' # 已开启的系统数据 self.systemDatas = { \"weapon_sys\" : {\"level\":39}, \"mount_sys\" : {\"level\":31}, } # 累计登录天数 self.accLoginDays = 3 # 累计充值金额 self.accChargeTotal = 3 # 玩家等级 self.level = 3 class PlayerConditionComponent(ConditionGroupTokenizer): \"\"\" 玩家条件组件 \"\"\" def __init__(self, playerDataComponent:PlayerFakeDataComponent) -\u003e None: super().__init__() self.playerDataComponent = playerDataComponent def proxyCondition(self, source:str, isPromt:bool) -\u003e bool: elements = source.split(\"-\") atomType = elements[0] params = elements[1:] result = self.checkConditionAtom(atomType, params) if isPromt: print(f\"判断：{atomType}:{params} 结果为：{result}\") return result def checkConditionAtom(self, atomType, params) -\u003e bool: \"\"\" 根据条件类型来逐个判断 \"\"\" if atomType == \"is_system_open\": systemId = params[0] return systemId in self.playerDataComponent.systemDatas elif atomType == \"system_level\": systemId = params[0] needSystemLevel = int(params[1]) if systemId in self.playerDataComponent.systemDatas: systemInfo = self.playerDataComponent.systemDatas[systemId] return systemInfo[\"level\"] \u003e= needSystemLevel return False elif atomType == \"player_level\": needPlayerLevel = int(params[0]) return self.playerDataComponent.level \u003e= needPlayerLevel elif atomType == \"acc_charge_total\": needAccTotal = int(params[0]) return self.playerDataComponent.accChargeTotal \u003e= needAccTotal elif atomType == \"acc_login_days\": needAccDays = int(params[0]) return self.playerDataComponent.accLoginDays \u003e= needAccDays else: assert False, f\"条件类型：{atomType} 还没支持，请完善相关条件判断逻辑\" return False class TestCondtionGroupComponent(unittest.TestCase): def __init__(self, methodName: str = \"且运算逻辑\") -\u003e None: super().__init__(methodName) def test_and_operator_success(self): ''' 测试用例-\u0026\u0026运算符:成功 ''' class TestDataComponent(PlayerFakeDataComponent): def buildFakeDatas(self): # 已开启的系统数据 self.systemDatas = { \"weapon_sys\" : {\"level\":50}, \"mount_sys\" : {\"level\":60}, } # 累计登录天数 self.accLoginDays = 3 # 累计充值金额 self.accChargeTotal = 3 # 玩家等级 self.level = 3 source = \"system_level-weapon_sys-50 \u0026\u0026 system_level-mount_sys-30\" dataComponent = TestDataComponent() conditionComponent = PlayerConditionComponent(dataComponent) result = conditionComponent.directCheck(source, False) self.assertTrue(result, f\"判断：{source} 结果为：{result}\") def test_and_operator_fail(self): ''' 测试用例-\u0026\u0026运算符:失败 ''' class TestDataComponent(PlayerFakeDataComponent): def buildFakeDatas(self): ''' 伪造玩家数据 ''' # 已开启的系统数据 self.systemDatas = { \"weapon_sys\" : {\"level\":50}, \"mount_sys\" : {\"level\":29}, } # 累计登录天数 self.accLoginDays = 3 # 累计充值金额 self.accChargeTotal = 3 # 玩家等级 self.level = 3 source = \"system_level-weapon_sys-50 \u0026\u0026 system_level-mount_sys-30\" dataComponent = TestDataComponent() conditionComponent = PlayerConditionComponent(dataComponent) result = conditionComponent.directCheck(source, False) self.assertFalse(result, f\"判断：{source} 结果为：{result}\") def test_or_operator_success(self): ''' 测试用例-\u0026\u0026运算符:成功 ''' class TestDataComponent(PlayerFakeDataComponent): def buildFakeDatas(self): ''' 伪造玩家数据 ''' # 已开启的系统数据 self.systemDatas = { \"weapon_sys\" : {\"level\":50}, \"mount_sys\" : {\"level\":29}, } # 累计登录天数 self.accLoginDays = 12 # 累计充值金额 self.accChargeTotal = 3 # 玩家等级 self.level = 3 source = \"is_system_open-pet_system || (acc_charge_total-100 || acc_login_days-10) || player_level-5\" dataComponent = TestDataComponent() conditionComponent = PlayerConditionComponent(dataComponent) result = conditionComponent.directCheck(source, False) self.assertTrue(result, f\"判断：{source} 结果为：{result}\") def test_or_operator_fail(self): ''' 测试用例-\u0026\u0026运算符:成功 ''' class TestDataComponent(PlayerFakeDataC","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:3:1","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["代码库"],"content":"\r结尾在游戏项目里，我们仅需实现一次通用条件组件模块，然后在奖励发放、任务触发\u0026完成、成就事件达成等业务模块上，都调用这个通用组件来判断条件是否满足 当然，真正要集成到项目里，还需要考虑到非法输入等情况，配置检查之类的事情，这块没法偷懒 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:4:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["代码库"],"content":"\r参考资料 游戏内条件集合(与或非组合)的判定处理 C#版 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:4:1","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["小工具"],"content":"由于新工作的服务器开发环境相对麻烦，遂编写了一个集成脚本来简化了服务器环境部署和运行流程 ","date":"2021-06-12","objectID":"/posts/improve_msys2/:0:0","tags":["msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["小工具"],"content":"\r前言新项目的服务器工程其实是skynet for windows，基于msys2+gcc来进行编译并运行，因此，日常开发工作中，需要经常打开msys2终端来输入各种shell指令，这并不方便 另外，本人更加偏好有个集成好的bat脚本，在上面输入【1】【2】【3】等数字之后，就能执行相应的【构建】【启动】【测试】等命令，最终调用msys2上的类linux环境来执行透传过来的命令，而且这种脚本也可以同配套环境打包给策划、测试童鞋，让他们快捷自建服务器完成功能验收和测试 ","date":"2021-06-12","objectID":"/posts/improve_msys2/:1:0","tags":["msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["小工具"],"content":"\r为msys2的追加镜像源基于 《MSYS2 镜像使用帮助》提供的实现思路，最初使用Python来快速实现了一个脚本 append_extra_mirror_source.py\r# !/user/bin/env python # -*- coding:utf-8 -*- import os, glob, codecs, re, argparse def add_mirror_url(mirror_url): mirror_paths = glob.glob(\"mirrorlist*\") re_pattern = r'(Server = )(https.*.org)(.*)' for path in mirror_paths: with codecs.open(path, mode=\"r\", encoding=\"utf-8\", errors='ignore') as f: config = f.read() f.close() search_re = re.search(re_pattern, config, re.M|re.I) exist_same_re = re.search(mirror_url, config, re.M|re.I) if not exist_same_re and search_re: mirror_url_item = search_re.group() temp = re.compile(re_pattern) mirror_url_item = temp.sub(r'\\1%(mirror_url)s\\3' % {'mirror_url': mirror_url}, mirror_url_item) new_config = '%(mirror_url)s\\n%(source)s' % {'mirror_url': mirror_url_item, 'source': config} outfile = codecs.open(path, 'w', 'utf-8') outfile.write(new_config) outfile.close() if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument(\"-url\", \"--mirror_url\", help=\"输入其他镜像源\", default=\"https://mirrors.cloud.tencent.com/msys2\") parser.add_argument(\"-msys2\", \"--msys2_dir\", help=\"msys2安装目录\", default=\"C:/msys64\") args = parser.parse_args() pacman_mirror_dir = \"%s/etc/pacman.d\" % (args.msys2_dir) os.chdir(pacman_mirror_dir) add_mirror_url(args.mirror_url) 但考虑到后续会推广给不会撸码的童鞋使用这个集成脚本，而这些童鞋大部分都是首次安装msys2的，因此，基于Python实现的脚本显然是不行的，又重新实现了一个bash脚本 由于bash脚本本身对文件、字符串等操作的支持极其有限，在此使用了msys2内置的sed、cp、cat、grep等工具来实现 在编写这个bash脚本的时候，遇到了一些知识盲区，特意记录下来： ✔ grep正则查找 ✔ sed正则替换需要对双引号、小括号等特殊字符进行前置转义 ✔ 在shell函数内修改传参变量的内容 ✔ 在文件首行插入新内容 append_extra_mirror_source.sh\r#!/bin/bash # sed 需要对斜杆和括号等字符进行转义后才能正常正则替换 replace_escape_string(){ eval $2=\\\"$(eval echo \"\\${$1}\" | sed \"s/\\//\\\\\\\\\\//g; s/(/\\\\\\\\(/g; s/)/\\\\\\\\)/g\")\\\" } # 在文件头上加入其它镜像源 push_front_mirror_url(){ _source_config_file=$1 _backup_config_file=$(dirname $1)/bak_$(basename $1) _old_mirror_pattern=$2 _new_mirror_host=$3 # 备份原本的镜像源配置 if [ ! -f ${_backup_config_file} ]; then cp $_source_config_file ${_backup_config_file} fi # 找到镜像源配置模板 mirror_temp_url=$(grep -r -P \"$_old_mirror_pattern\" ${_backup_config_file}) replace_escape_string _old_mirror_pattern _old_mirror_pattern replace_escape_string _new_mirror_host _new_mirror_host # 根据模板镜像源修改成新的镜像源 new_mirror_url=$(echo $mirror_temp_url | sed \"s/$_old_mirror_pattern/\\\\1$_new_mirror_host\\\\3/g\") # 在文件头上插入新的镜像源链接 (echo $new_mirror_url \u0026\u0026 cat ${_backup_config_file}) \u003e $_source_config_file } main(){ # 腾讯云镜像源 # new_mirror_host=\"https://mirrors.cloud.tencent.com/msys2\" # 清华镜像源 new_mirror_host=\"https://mirrors.tuna.tsinghua.edu.cn/msys2\" old_mirror_pattern=\"(Server.*)(http.*repo.msys2.org)(.*)\" if [ ${#} == 1 ]; then new_mirror_host=$1 fi # 遍历pacman的镜像源配置 for file in /etc/pacman.d/mirror*; do push_front_mirror_url $file $old_mirror_pattern $new_mirror_host done } main $1 ","date":"2021-06-12","objectID":"/posts/improve_msys2/:2:0","tags":["msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["小工具"],"content":"\r拓展msys2","date":"2021-06-12","objectID":"/posts/improve_msys2/:3:0","tags":["msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["小工具"],"content":"\r让msys2支持在dos上直接执行shell指令在着手实现过程中，以下这些点是挺有意思的： ✔ 在dos中调用msys2来直接执行shell指令 详情看msys2_shell.cmd里面的!SHELL_ARGS!参数，其实它实现了：一个外部参数若果并不是msys2_shell.cmd的内置参数的话，其将会原样传递到终端上，结合bash -c cmd即可实现外部调用 ✔ 如何指定msys2的启动目录 详情看msys2_shell.cmd的参数列表：-where dir ✔ 在msys2里，将父bash的alias传递给子bash，并且执行其它指令 bash --noprofile --rcfile \u003c(alias) ","date":"2021-06-12","objectID":"/posts/improve_msys2/:3:1","tags":["msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["小工具"],"content":"\r将msys2添加到右键菜单上 ✔ 在目录下或者文件夹上执行该菜单命令时，启动msys2并定位到该目录下 ✔ 在某个文件上执行该菜单命令时，启动msys2，定位到该文件所在目录，并用Vim打开该文件 msys2_vim_installer.bat\r@echo off ::判断是否已经获取了管理员身份 Md \"%WinDir%\\System32\\test_permissions\" 2\u003eNUL||(Echo 请使用右键管理员身份运行\u0026\u0026Pause \u003eNUL\u0026\u0026Exit) Rd \"%WinDir%\\System32\\test_permissions\" 2\u003eNUL SetLocal EnableDelayedExpansion call %~dp0create_depends_env.bat ::设置右键菜单项的名称 set desc=\"Msys2-Vim\" ::设置搭建编译环境的BAT set runbat=\"run_msys2_vim.bat\" ::设置子路径名称 set subname=\"msys2_vim\" ::去掉双引号，主要是为了兼容包含了空格的文件名或路径 call :removequotes runbat call :removequotes subname ::添加注册表信息 reg add \"HKEY_CLASSES_ROOT\\Directory\\background\\shell\\%subname%\" /v \"\" /t REG_SZ /d %desc% reg add \"HKEY_CLASSES_ROOT\\Directory\\background\\shell\\%subname%\\command\" /v \"\" /t REG_EXPAND_SZ /d \"\\\"%~dp0%runbat%\\\" \\\"%%V\\\" reg add \"HKEY_CURRENT_USER\\Software\\Classes\\*\\shell\\%subname%\" /v \"\" /t REG_SZ /d %desc% reg add \"HKEY_CURRENT_USER\\Software\\Classes\\*\\shell\\%subname%\\command\" /v \"\" /t REG_EXPAND_SZ /d \"\\\"%~dp0%runbat%\\\" \\\"%%V\\\" reg add \"HKEY_CLASSES_ROOT\\Directory\\shell\\%subname%\" /v \"\" /t REG_SZ /d %desc% reg add \"HKEY_CLASSES_ROOT\\Directory\\shell\\%subname%\\command\" /v \"\" /t REG_EXPAND_SZ /d \"\\\"%~dp0%runbat%\\\" \\\"%%V\\\" :removequotes FOR /F \"delims=\" %%A IN ('echo %%%1%%') DO set %1=%%~A GOTO :eof run_msys2_vim.bat\r@echo off call %~dp0config.bat set ROOT=%1 call :removequotes ROOT pushd \"%ROOT%\" 2\u003enul \u0026\u0026 (call :folder \"%ROOT%\" \u0026 popd) || call :file \"%ROOT%\" GOTO :eof :file call :filename ROOT file_name call :dirname ROOT dir_name set command_args=%msys2_type% -where \"%dir_name%\" call %msys2_shell_bat% %command_args% -outside_exec \"vim '%file_name%'\" GOTO :eof :folder set command_args=%msys2_type% -where \"%ROOT%\" call %msys2_shell_bat% %command_args% GOTO :eof :removequotes FOR /F \"delims=\" %%A IN ('echo %%%1%%') DO set %1=%%~A GOTO :eof :dirname FOR /F \"delims=\" %%A IN ('echo %%%1%%') DO set %2=%%~dpA GOTO :eof :filename FOR /F \"delims=\" %%A IN ('echo %%%1%%') DO set %2=%%~nxA GOTO :eof 提供一个脚本来关联msys2和当前脚本的关系 create_depends_env.bat\r@echo off REM 创建目录关联 echo 将msys2目录粘贴到这里 set /p msys2_dir= call :removequotes msys2_dir @REM 自动生成config.bat set config_path=\"%~dp0config.bat\" if not exist %config_path% ( echo @echo off\u003e\u003e %config_path% echo set msys2_install_dir=\"%msys2_dir%\"\u003e\u003e %config_path% echo set msys2_shell_bat=\"%msys2_dir%\\msys2_shell.cmd\"\u003e\u003e %config_path% echo set msys2_type=-mingw64\u003e\u003e %config_path% echo set pause_cmd=read -p 'Please press any key after'\u003e\u003e %config_path% ) GOTO :eof :removequotes FOR /F \"delims=\" %%A IN ('echo %%%1%%') DO set %1=%%~A GOTO :eof GOTO :eof 最终成品：msys2_vim ","date":"2021-06-12","objectID":"/posts/improve_msys2/:3:2","tags":["msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["小工具"],"content":"\r参考资料 MSYS2 镜像使用帮助 forward aliases to child process invoking-msys-bash-from-windows-cmd executing-msys-from-cmd-exe-with-arguments how-do-i-integrate-msys2-shell-into-visual-studio-code-on-window ","date":"2021-06-12","objectID":"/posts/improve_msys2/:4:0","tags":["msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["工具"],"content":" 本人在收集一些文章正文的时候，中途被一些采用图文混合形式加密保护的网页卡着了，这篇文章记录下了我针对该类事情的处理方式 ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:0","tags":["图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["工具"],"content":"\r前言由于自己的某些学习需求，不想一直联网浏览某些网页内容，因此想将这些站点的某些内容缓存到本地。另外，该网站为了防止内容被爬虫抓取或被盗稿，因此在页面渲染时对内容进行了一些加密处理：将纯文本内容拆分成图文混合形式渲染，格式如下所示： \u003cp\u003e生活就像海洋，只有意\u003cimg src=\"/image/data/3452027561.png\" /\u003e坚强的人，才 \u003cimg src=\"/image/data/0001716716.png\" /\u003e\u003cimg src=\"/image/data/4356266290.png\" /\u003e达彼岸。 ——马克思 \u003c/p\u003e 分析了一下这个html源码，摸索出了它的加密规律：每个页面的字符图片都是随机的，也就是说，无法写一套[图片名 =\u003e 字符]的模板来批量替换，需要频繁对字符图片来进行OCR识别 但目前的免费OCR服务，都有体验次数限制，毕竟识别精度一般较高，而且维护这套识别服务也是挺费钱的。而按照本人的估计，假设要全部缓存这个站点的内容，采用在线OCR服务来识别这些字符图片肯定要凉，当天免费次数铁定不够；那么，相对靠谱的方案就是自建OCR服务或者搞个Native OCR工具来做OCR识别了，这些方案没有商用服务的体验限制 ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:1","tags":["图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["工具"],"content":"\rOCR开源技术调研思路确定了，但是面临了一个新问题，本人并没有OCR相关的开发经验，只能采用开源OCR项目来达成自己的目的，在网上检索一轮之后，找到了这些方案： pandaocr 在线ocr服务的聚合工具，实际上还是有体验次数限制 chineseocr-lite 识别准度可靠，需要自行编译，windows下部署环境相对复杂，费时间，服务方式调用 tesseract 这个开源方案虽然是最有历史的，部署简单，但是官方提供的模型数据给出的识别效果最差，耗时最多，要想获得较高的识别精度，需要自己花费非常多精力去调教，或者尝试其它训练模型，是故不推荐 paddleocr 它是百度开源ocr项目，基于paddle深度学习框架实现的，部署难度一般，国内资料非常丰富，并且整个项目非常庞大，使用官方提供的模型数据即可有较高识别精度，但是耗时一般，对于复杂的文字排版的识别结果可用。如果有识别各种广告营销图的OCR需求，那么它将是目前较好的开源方案 cnocr 它是起源于爱因互动 Ein+ 内部的项目需求，后续开源出来，其部署简单，使用官方提供的模型数据即可有较高识别精度，并且耗时最少，对于复杂的文字排版的识别结果准度一般。如果只是单纯的文字图片识别，比如微信聊天截图啥的，那么它的识别准度和识别速度都是较好的，但是不建议使用它来识别广告营销图 本人在Windows系统下分别跑通了tesseract、cnocr、paddleocr这些开源项目，以下是本次技术调研的总结： OCR方案 部署难度 文字图片识别精度 复杂文字排版识别精度 识别速度 tesseract 简单 较差 不可用 慢 cnocr 简单 准确 勉强能用 快 paddleocr 复杂 准确 可用 一般 经过调研对比，最终采取cnocr作为字符图片的ocr方案 其实在windows下，Tim的Ctrl+Alt+O快捷键呼出来的[相框识别文字]的识别精度更高 ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:2","tags":["图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["工具"],"content":"\r设计识别流程在调研过程中，发现每次ocr识别耗时是秒级的，并且字符图片的识别准度不如合并后的图片识别准度，为了提升最终的ocr识别准度以及减少耗时，需要先合并多个字符图片，再进行ocr识别，流程图如下所示： ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:3","tags":["图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["工具"],"content":"\r开发思路确定具体的OCR方案后，梳理此工具的实现思路，大致步骤如下： 使用wget来爬取这个网站的资源 wget -c -r -np -k -p -nc \"http://www.xxx.com/xxx/\" \u003eWindows下，建议使用msys2来执行 识别该站点里的字符图片文件夹，将ocr识别结果按照[字符图片=\u003e字符]的映射关系导出为json文件 读取json文件里面的字符图片映射数据，将html里面的字符图片标签替换成正常的字符 继续执行正常的网络爬虫 ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:4","tags":["图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["工具"],"content":"\r成品 功能特性 添加帮助文档 支持合成单行文字图片 支持合成多行文字图片 支持可选调试信息输出 支持可选保存合并后的图片 支持cnocr识别，并将映射结果导出到json 支持外部OCR结果校正 直接替换html里的字符图片标签 增加Windows右键菜单集成支持 附件：char_images_ocr_tool.zip ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:5","tags":["图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["工具"],"content":"\r参考资料 字符图片合并 初探cnocr ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:6","tags":["图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["开源技术"],"content":"\r仓库地址 cnocr ","date":"2021-04-08","objectID":"/posts/cnocr/:0:0","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r在线安装 virtualenv/anaconda3 win32OpenSSL conda create -n cnocr python=3.7 conda activate cnocr pip install cnocr pip install cnstd 注意，执行pip install cnstd之后，shapely的在线安装是有问题的，需要下载离线的shapely_xxx.whl文件(如Shapely-1.7.1-cp37-cp37m-win_amd64.whl)进行离线安装，如下所示： pip uninstall Shapely pip install your_path/Shapely-1.7.1-cp37-cp37m-win_amd64.whl ","date":"2021-04-08","objectID":"/posts/cnocr/:0:1","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r源码安装 cd cnstd/ pip install -r requestment.txt python setup.py build python setup.py install ","date":"2021-04-08","objectID":"/posts/cnocr/:0:2","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r离线包部署如果不想折腾这个cnocr的环境配置，这里提供了一个本人整合的离线工具包，只需要在一个不包含中文或空格的路径上解压，直接以管理员身份执行ocr_deploy.bat即可 下载链接：cnocr离线工具包-cnocr_toolkit.zip，提取码：y80u 该离线包仅仅支持x64bit Windows系统 ","date":"2021-04-08","objectID":"/posts/cnocr/:0:3","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r代码片段\r纯文本识别 # 识别纯文字图片 def ocr_single_png_from_cache(image): nd_array = np.asarray(image.convert('RGB')) res = cn_ocr.ocr(nd_array) res = [''.join(line_p) for line_p in res] temp_res = '\\n'.join(res) return temp_res # 识别纯文字图片 def ocr_single_png_from_cache_bak(image): img_bytes = BytesIO() image.save(img_bytes, format='PNG') nd_array = mx.image.imdecode(img_bytes.getvalue()) res = cn_ocr.ocr(nd_array) res = [''.join(line_p) for line_p in res] temp_res = '\\n'.join(res) return temp_res 外部调用cnocr # 读取shell命令输出结果 def popen_wrapper(cmd_line): p = subprocess.Popen(cmd_line, shell=True, stdout=subprocess.PIPE) lines = p.stdout.readlines()[1:] temp_str = \"\" for str in lines: utf8_str = str.decode(\"utf8\") temp_str = temp_str + utf8_str return temp_str # 尝试进行OCR识别 def try_ocr_image(image_path): cmd_line = \"xxx/try_ocr_image.bat %s\" % (image_path) ocr_str = popen_wrapper(cmd_line).strip() return ocr_str 剪贴板OCR # -*- coding: utf-8 -*- import win32.win32clipboard as win32clipboard from PIL import Image, ImageDraw, ImageGrab import os # 读取PIL image进行OCR识别 def ocr_image_from_pil(image): from cnocr import CnOcr import numpy as np cn_ocr = CnOcr() nd_array = np.asarray(image.convert('RGB')) res_lines = cn_ocr.ocr(nd_array) res = [''.join(line_p) for line_p in res_lines] temp_res = '\\n'.join(res) return temp_res # 读取剪贴板上的图像数据进行OCR识别 def try_ocr_clipboard(): ocr_result = \"\" im = ImageGrab.grabclipboard() if not im == None: return ocr_image_from_pil(im) return ocr_result def set_text_to_clipboard(text): text_bytes = bytes(text, encoding=\"utf8\") win32clipboard.OpenClipboard() win32clipboard.SetClipboardText(text) win32clipboard.CloseClipboard() def ocr_clipboard(): ocr_result = try_ocr_clipboard() if (len(ocr_result) \u003e 0): set_text_to_clipboard(ocr_result) print(\"剪贴板OCR结果：\\n%s\" % (ocr_result)) os.system(\"pause\") ocr_clipboard() 剪贴板OCR工具-ocr_clipboard.zip 注意，Tim上有一个屏幕OCR功能，只需要Ctrl+Alt+O即可唤出，识别准度更高 训练新字体\r生成新字体的训练集先通过以下脚本来快速生成字体的训练集 pre_train_for_font.py\r# !/user/bin/env python # -*- coding:utf-8 -*- import os import argparse from PIL import Image,ImageFont,ImageDraw # 根据文本生成图片 def save_chars_image(text, image_path, font, is_debug = False): chars_x, chars_y = 0, 0 chars_w, chars_h = font.getsize(text) if is_debug == True: chars_w = chars_w + 2 chars_h = chars_h + 2 im = Image.new(\"RGB\", (chars_w, chars_h), (255, 255, 255)) dr = ImageDraw.Draw(im) # 绘制文字边框 if is_debug == True: coords = [(chars_x+1, chars_y+1), (chars_x+1, chars_y+chars_h-1), (chars_x+chars_w-1, chars_y+chars_h-1), (chars_x+chars_w-1,chars_y+1)] dr.polygon(coords, outline=(255, 0, 10)) # 居中绘制文字 dr.text((chars_x, chars_y), text, font=font, fill=(0,0,0), align='center') im.save(image_path) def indexing(standards, new_chars, text): res = [] for i in range(len(text)): try: res.append(standards.index(text[i])+1) except: new_chars.append(text[i]) res.append(len(standards)+len(new_chars)+1) return res def clear_invalid_chars(char_array): for i in range(len(char_array)): char_array[i] = char_array[i].strip('\\n') def main(): parser = argparse.ArgumentParser(description='生成用于CnOcr训练的数据集') parser.add_argument(\"-root\", \"--root_dir\", default=\"data\", type=str, help=\"预训练配置目录\", ) parser.add_argument(\"-examples\", \"--examples_dir\", default=\"examples\", type=str, help=\"图片样本所在目录\", ) parser.add_argument(\"-font\", \"--font_path\", default=\"fonts/卷卷桃心中文字体.ttf\", type=str, help=\"待训练的字体路径\", ) parser.add_argument(\"-font_size\", \"--font_size\", default=20, type=int, help=\"待训练的字体大小\", ) parser.add_argument(\"-label\", \"--label_path\", default=\"label_cn.txt\", type=str, help=\"文本原料\", ) parser.add_argument(\"-train\", \"--train_name\", default=\"train.txt\", type=str, help=\"训练样本名\", ) parser.add_argument(\"-test\", \"--test_name\", default=\"test.txt\", help=\"测试样本名\", ) parser.add_argument(\"-is_test\", \"--is_test\", action=\"store_true\", help=\"是否生成测试图片\", ) parser.add_argument(\"-test_text\", \"--test_text\", default=\"\", help=\"测试文本\", ) args = parser.parse_args() root_dir = args.root_dir images_dir = args.examples_dir label_path = args.label_path train","date":"2021-04-08","objectID":"/posts/cnocr/:0:4","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r学习计划 ✔ 跑通cnocr的识别流程 ✔ 制作成离线部署包，方便在其它电脑上快速部署 ✔ 用来制作一些自用小工具，比如剪贴板上的图片OCR识别等 ✔ 跑通它的训练流程，持续改善识别精度 ✔ 提供新字体的预训练脚本 ✔ 提供适合在windows下使用的脚本-Makefile.bat ✔ 尝试改进它的文本方向纠正效果 现在它的文本校正方向很容易出现180度倒转的情况，看有没有啥办法处理下，已经找到问题了，OpenCv4.5的bug，通过pip install opencv-python==4.4.0.46降版本就行了，不过竖版文本的识别官方是暂不支持的，这个要另外项办法了 ","date":"2021-04-08","objectID":"/posts/cnocr/:0:5","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r后记在Python3.8下部署时候遇到问题，因此推荐使用Python3.7及其以下版本，详情看官方教程 个人比对了一下各个ocr项目，cnocr对纯文本图片的识别的准确度非常高，并且速度较快，但限于文本方向必须正确，一旦出现文本垂直或水平翻转，精度会严重下降；另外它对于那些广告图的识别效果也较差，不过无论如何，肯定甩tesseract不止一条街 如果你的需求大多集中在广告图等非纯文本图片上，那么建议使用paddleocr或chinesecor-lite，不过这些ocr项目的部署也相对复杂多了 ps:mxnet库有个Warning一直很烦人，但是其不影响使用，直接在site-packages\\mxnet\\symbol\\symbol.py里注释掉line 925的warning输出 离线工具包制作python3环境(从anaconda3中提取而得) + 系统环境变量关联脚本 + 官方模型 ","date":"2021-04-08","objectID":"/posts/cnocr/:0:6","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r参考资料 更轻量的中文OCR—— cnocr-V1.2.2 ：最小模型只有 4.7M OCRSpace 支持超长图片的OCR识别 ","date":"2021-04-08","objectID":"/posts/cnocr/:0:7","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["工具"],"content":"在ocr识别当中，单字识别效果一般不够准确，另外，对于一个ocr功能而言，最耗时的莫过于每次执行ocr识别了，假设现今有几百张字符图片，为了快速生成{图片名：字符}的映射关系，需要耗时更少的方案 这个时候图片合并就需要安排上了，将几百次的字符图片识别转换为识别若干次单行或多行文字图片，减少ocr识别次数，就能有效减少耗时了，另外，经过合并后的文字图片在保留合理的字符间隔后，其识别准度也会有所提升，可谓一箭双雕 ","date":"2021-04-07","objectID":"/posts/char_image_merge/:0:0","tags":["图片合并","ocr识别"],"title":"字符图片合并","uri":"/posts/char_image_merge/"},{"categories":["工具"],"content":"\r合并成单行文字图片实现思路上还是比较简单的，大致拆分成以下步骤： 设定单行文字图片里的文字数量 遍历文件夹下的字符图片，存储即将进行图片合并的图片路径列表 计算每个字符图片的尺寸大小 根据单行文字数量和尺寸大小来计算出最终合并后的图片尺寸，并在内存里创建一张该尺寸的纯色背景图 注意，如果字符图片的尺寸过小，为了让各个字符之间有足够的间隔，最好增加一个参数来拓展字符图片的边界 计算每张字符图片的混合贴图的位置信息，将各个字符图片平铺到这个背景图片上 保存图片到磁盘上 # 合并成单行文字图片 def combine_image_with_lite(paths, merge_times, is_debug = False): count = len(paths) src_image = Image.open(paths[0]) image_width, image_height = src_image.size x = image_width + extra_bound_as_single_line y = image_height + extra_bound_as_single_line # 计算合并之后的大小 full_x = x * count full_y = y full_size = (full_x, full_y) full_image = Image.new('RGBA', full_size, (255,255,255)) full_image.format = \"PNG\" # print(\"full rect : {%d,%d,%d,%d}\" % (0, 0, full_x, full_y)) # 将图片块平铺到这个大图片上 start_x = 0 start_y = 0 end_x = x end_y = y index = 1 draw = ImageDraw.Draw(full_image) for path in paths: if is_debug == True: # 绘制每个填充区域的边界 print(\"{%d,%d,%d,%d}\" % (start_x, start_y, end_x, end_y)) draw.rectangle((start_x+1, start_y+1, end_x-1, end_y-1), outline = get_random_color()) # 居中绘制填充的图片索引 index_str = \"%d\"%(index) font_size_x, font_size_y = draw.textsize(index_str) draw.text((start_x + (x-font_size_x)/2, start_y + (y-font_size_y)/2), index_str, fill='black') else: # 由于字符图片边界过小，如果直接平铺的话，就会显得太挤，OCR识别效果很差 # 为此拓展字符图片的填充区域，并将图片在此中间叠加上去 src_image = Image.open(path) start_x0 = start_x + (x-image_width)//2 start_y0 = start_y + (y-image_height)//2 end_x0 = start_x0 + image_width end_y0 = start_y0 + image_height full_image.paste(src_image, (start_x0, start_y0, end_x0, end_y0), src_image) index = index + 1 if end_x \u003e= full_x: # 从左往右填充，遇到边界之后切换到下一行 start_x = 0 end_x = start_x + x start_y = start_y + y end_y = start_y + y else: # 继续从左往右平铺 start_x = start_x + x end_x = end_x + x current_dir = os.getcwd() output_path = '%s/../single_line_%d.png' % (current_dir, merge_times) full_image.save(output_path) ","date":"2021-04-07","objectID":"/posts/char_image_merge/:0:1","tags":["图片合并","ocr识别"],"title":"字符图片合并","uri":"/posts/char_image_merge/"},{"categories":["工具"],"content":"\r合并成多行文字图片实现思路上同上述差不多，但是需要注意计算好图片的行列数，尽可能减少空白区域，步骤如下： 遍历文件夹下的所有字符图片得到待合并的图片路径列表 计算每个字符图片的尺寸大小 根据合并的图片数量，开根号后计算行列数 根据行列数来计算出最终合并后的图片尺寸，并在内存里创建一张该尺寸的纯色背景图 注意，如果字符图片的尺寸过小，为了让各个字符之间有足够的间隔，最好增加一个参数来拓展字符图片的边界 计算每张字符图片的混合贴图的位置信息，将各个字符图片平铺到这个背景图片上，如果当前行已经平铺满了，就切换到下一行继续平铺 平铺顺序：从左到右 从上到下 保存图片到磁盘上 # 合并成多行文字图片 def combine_image_with_multi(paths, merge_times, is_debug = False): count = len(paths) src_image = Image.open(paths[0]) image_width, image_height = src_image.size x = image_width + extra_bound_as_multi_line y = image_height + extra_bound_as_multi_line # 根据待合并的图片总数来计算平铺的行列数 sqrt2 = math.sqrt(count) row_num = round(sqrt2) column_num = row_num if sqrt2 \u003e column_num: column_num = column_num + 1 print(\"总数：%d 开根号：%f 行：%d 列：%d\" % (count, sqrt2, row_num, column_num)) # 计算合并之后的图片尺寸 full_x = x * column_num full_y = y * row_num full_size = (full_x, full_y) full_image = Image.new('RGBA', full_size, (255,255,255)) print(\"full rect : {%d,%d,%d,%d}\" % (0, 0, full_x, full_y)) # 将图片块平铺到这个大图片上 start_x = 0 start_y = 0 end_x = x end_y = y index = 1 draw = ImageDraw.Draw(full_image) for path in paths: if is_debug == True: # 绘制每个填充区域的边界 print(\"{%d,%d,%d,%d}\" % (start_x, start_y, end_x, end_y)) draw.rectangle((start_x+1, start_y+1, end_x-1, end_y-1), outline = get_random_color()) # 居中绘制填充的图片索引 index_str = \"%d\"%(index) font_size_x, font_size_y = draw.textsize(index_str) draw.text((start_x + (x-font_size_x)/2, start_y + (y-font_size_y)/2), index_str, fill='black') else: src_image = Image.open(path) start_x0 = start_x + (x-image_width)//2 start_y0 = start_y + (y-image_height)//2 end_x0 = start_x0 + image_width end_y0 = start_y0 + image_height full_image.paste(src_image, (start_x0, start_y0, end_x0, end_y0), src_image) index = index + 1 if end_x \u003e= full_x: # 从左往右填充，遇到边界之后切换到下一行 start_x = 0 end_x = start_x + x start_y = start_y + y end_y = start_y + y else: # 继续从左往右平铺 start_x = start_x + x end_x = end_x + x current_dir = os.getcwd() output_path = '%s/../multi_line_%d.png' % (current_dir, merge_times) full_image.save(output_path) 附件：char_image_merge_tool.zip ","date":"2021-04-07","objectID":"/posts/char_image_merge/:0:2","tags":["图片合并","ocr识别"],"title":"字符图片合并","uri":"/posts/char_image_merge/"},{"categories":["插件开发"],"content":"\r前言之前在《谈一种页面加密技术》里谈到了自己捣弄了一个页面加密方案，并且也开发了一个cli工具用来对html或tag进行打包加密，由于本人的文章都是采用hexo来发布的，因此就需要将这个打包工具整合成hexo plugin了 ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:1","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["插件开发"],"content":"\r使用方式本人希望借助这款插件，只需要让那些想要加密的md的文件头上添加password: your_pwd，即可在执行hexo g的时候，自动对生成的html的文章正文进行加密 ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:2","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["插件开发"],"content":"\r开发笔记由于互联网上关于Hexo插件的开发笔记早已汗牛充栋，在此就不再赘述了，以下是本人在开发该插件时所检索到的有效资料： 了解hexo的插件工作机制 插件|Hexo 找出处理文章正文的插件接口或示例 在 hexo-blog-encrypt 里找到了关键接口 新建一个插件项目 《hexo教程之为hexo编写一个插件》 整合加密打包功能到这个插件项目上 已上传到 hexo-encrypted-package-html 仓库上了 将这款插件发布到npmjs.com上 《如何发布自己的NPM包（模块）？》 将这款插件发布到hexo插件市场上 插件|Hexo ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:3","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["插件开发"],"content":"\r插件调试目前没有找到vscode直接断点调试hexo插件的方式以及相关的文章教程，这里采用的是根据hexo.log()或console.log()的日志输出来跟踪问题的 ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:4","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["插件开发"],"content":"\r注意事项由于GithubPage是部署在墙外的，部分国内的cdn国外无法正常访问，所以需将bootstrap.min.css的国内url要改成国外url ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:5","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["插件开发"],"content":"\r后记其实hexo 插件市场上也有好几款文章正文加密插件，其中一款也做得更加完善，具体看这里：hexo-blog-encrypt，本人开发的此款加密插件可当作另一种实现思路 这些同类插件是在本人实现一遍页面加密技术之后才发现的，为了不让自己的折腾变成瞎折腾，因此硬着头皮在搞多一款同类插件出来了\u003e\u003c ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:6","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["插件开发"],"content":"\r参考资料 插件|Hexo hexo-blog-encrypt 《hexo教程之为hexo编写一个插件》 《如何发布自己的NPM包（模块）？》 《谈一种页面加密技术》 ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:7","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["小工具"],"content":"\r前言这段时间边练车边整理工作笔记，然后突然发现，有一些内容不适合直接公开分享，但是也希望发布出去，被那些想看的亲朋好友可以正常浏览，因此有了html的加密访问需求，另外，考虑到这些加密分享的内容并不适合被搜索引擎检索到它的正文，所以正文内容也是有加密需求的。于是就在网上检索有没有相关的技术实现的文章。然后找到了这些技术博客或在线工具： HTML的简单页面加密代码 基本流程上是没啥问题，但是这个示例里面，密码完整验证的方式已经被明文存储在页面上了，纵使密码存放在其它地方，采用Ajax方式获取之后再对比也毫无意义，开发者很容易在浏览器上通过F12修改这个密码验证逻辑从而正常浏览到，并且，由于这里面的内容也是明文存放着的，也会被搜索引擎检索到 HTML网页加密解密 无法正常体验，并且访问体验也不是我想要的 总而言之，虽然找到了各种貌似可用的实现，但是都没有get到我的需求痛点，决定自己开搞一个 ","date":"2021-03-15","objectID":"/posts/a_way_of_html_encryption/:0:1","tags":["html","hexo","encrypted"],"title":"谈一种页面加密技术","uri":"/posts/a_way_of_html_encryption/"},{"categories":["小工具"],"content":"\r基本思路实际上，本人对访问的加密强度没啥追求，只需要以下特性即可： 正文不能被搜索引擎爬虫到 需要输入密码访问 针对这两个需求点，采用以下两种加密方式混合使用即可达到： base64 (一种可逆加密方式，将明文或字节流转换成base64字符串，在此解决首次xor加密生成的字节流存储在页面的问题) xor (一种可逆加密方式，提供密钥验证支持，在正确的密钥下，进行两次该加密即可获得原文) 页面加密打包思路读取需要加密的html文件的特定标签内容，将其进行base64+xor加密之后，塞到一个可以进行密码验证访问的模板标签上，删掉这个已加密的正文标签后，将模板标签再重新拼接成新的html。具体流程流程看代码啦，也是比较直观的 页面验证访问思路游客打开这个加密后的html之后，已加密的标签上会显示一个密码验证的界面，如果密码输入错误，浏览器会弹框提醒，如果输入密码正确，则解密后的正文标签outHtml会直接替换掉这个密码验证标签的outHtml，此时浏览器会自动将正文内容加载出来 密码验证思路核心思路是提供一个 **前缀字符串(prefix_str)**来作为判断依据，最终整个流程如下所示： 加密打包：base64(xor(prefix_str+content)) 解密验证：xor(unbase64(encode_str))，再从中匹配前缀字符串是否刚好为 prefix_str，如果是，则密码正确，反之，提醒用户重新输入 加密/解密思路从html上提取到需要加密的正文tag之后，其加密、解密的流程设计如下所示： html encrytion html decrytion +--------------+ +--------------+ | | | | |input html tag| |input html tag| | | | | +--------------+ +--------------+ | | | | | | +-------v--------+ +---------v---------+ | | | | | xor encryption | | base64 encryption | | | | | +----------------+ +-------------------+ | | | | | | +--------v----------+ +-------v--------+ | | | | | base64 encryption | | xor encryption | | | | | +-------------------+ +----------------+ | | | | | | +------v--------+ +------v--------+ | | | | |output html tag| |output html tag| | | | | +---------------+ +---------------+ 技术选型此工具基于nodejs技术栈实现，经过对比，选择了下面这几个第三方库： js-base64 utf8支持良好的base64库 cheerio 能够解析修改html的html库，多用于爬虫项目 yargs 能轻松配置命令，解析多个参数，并设置快捷方式等，还能自动生成帮助菜单的命令行辅助库 代码实现 base64+xor加密解密库 html加密打包工具 后续迭代由于目前本人的博客都是采用hexo发布的，因此需要将这个加密逻辑整合成hexo插件，期间找到了一款同类型的插件hexo-blog-encrypt，这款hexo插件基本满足我最开始的要求了，但由于它是在我完成了base64+xor加密解密库和html加密打包工具后，打算整合到hexo的时候才找到的，本着不断学习的态度，借鉴这个插件的思路，自己也重写了一个 OMG，感兴趣的可前往hexo-encrypted-package-html ","date":"2021-03-15","objectID":"/posts/a_way_of_html_encryption/:0:2","tags":["html","hexo","encrypted"],"title":"谈一种页面加密技术","uri":"/posts/a_way_of_html_encryption/"},{"categories":["工具"],"content":"\r前言目前在项目里做导表工具改版，由于这个导表工具采用php实现的，希望在ide上可以断点调试php，需要安装xdebug 在idea里的php settings上有其安装指导，如下图所示： 经过网上检索可知，安装php-xdebug的步骤如下： 查询phpinfo 拿phpinfo去xdebug wizard查询其匹配的xdebug版本及其下载链接 然后下载dll并在php.ini里修改xdebug的配置项 但由于本人有多台办公设备，并且其php版本都不太一样，所以需要开发一个快速下载/部署xdebug的脚本，能达到一键部署php的开发调试环境就最好了 ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:1","tags":["html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["工具"],"content":"\r基本思路 在shell上用which php查找到php的所在路径，并cd $(dirname $(which php))（将这个py脚本放置在php.exe的同级目录就行） 判断这个目录下是否有php.ini文件，如果没有的话，就cp php.development php.ini（这部分采用python来实现） 在shell上执行php -i phpinfo(); \u003e phpinfo.txt，将结果输出到文本上（在python中调用此shell指令，并将输出存放在变量中） 用输出的phpinfo信息粘贴在xdebug.org-custom installation instructions上的文本框上查询，这里面会检测到xdebug版本 具体的phpinfo的检测条件在phpinfo-scanner.php 这一步是关键，分析这个查询请求的Responses Headers和Form Data 采用bs4从html上提取php_xdebug_xxx.dll的下载链接 下载php_xdebug_xxx.dll到ext目录下 采用configparser来修改php.ini上的xdebug配置 ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:2","tags":["html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["工具"],"content":"\r代码实现 # !/user/bin/env python # -*- coding:utf-8 -*- import os, sys, subprocess, locale, shutil import requests, codecs, urllib, configparser from bs4 import BeautifulSoup from sys import stdout # 拿phpinfo在xdebug.org上查询并提取xdebug.dll的下载链接 def get_xdebug_download_page(phpinfo): url = 'https://xdebug.org/wizard' data = { \"data\": phpinfo, \"submit\": \"Analyse my phpinfo() output\" } headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36\", \"Origin\": \"https://xdebug.org\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\", \"Referer\": \"https://xdebug.org/wizard\", \"Accept-Encoding\": \"gzip, deflate, br\", \"Accept-Language\": \"zh-CN,zh;q=0.9\", } return requests.post(url=url, headers=headers, data=data).text # 从html上提取xdebug的下载链接 def find_xdebug_download_link(html): soup = BeautifulSoup(html, features=\"html.parser\") return soup.find(\"ol\").find(\"a\")[\"href\"] # 获取phpinfo def get_php_info(): phpinfo = read_commandline(\"php -i phpinfo();\") substr_flag = phpinfo.find(\"___________________\") return phpinfo[0:substr_flag] # 获取shell的输出结果 def read_commandline(command_str): output_str = \"\" ps = subprocess.Popen(command_str, stdin=subprocess.PIPE, stdout=subprocess.PIPE, shell=True) while True: data = ps.stdout.readline() if data == b'': if ps.poll() is not None: break else: output_str = output_str + data.decode(codecs.lookup(locale.getpreferredencoding()).name) return output_str # 下载文件 def download_file(url, file_path): r = requests.get(url) with codecs.open(file_path,'wb') as f: f.write(r.content) # Refer to : https://www.jb51.net/article/167786.htm def download_file_with_process(url, file_path): with codecs.open(file_path, \"wb\") as fw: with requests.get(url, stream=True) as r: filesize = r.headers[\"Content-Length\"] chunk_size = 128 times = int(filesize) // chunk_size show = 1 / times show2 = 1 / times start = 1 for chunk in r.iter_content(chunk_size): fw.write(chunk) if start \u003c= times: stdout.write(f\"download process : {show:.2%}\\r\") start += 1 show += show2 def check_php_cfg(php_cfg): default_php_cfg = php_cfg+\"-development\" if not os.path.exists(php_cfg): shutil.copy(default_php_cfg, php_cfg) # 更新php.ini上的xdebug配置 def update_php_cfg(php_cfg, xdebug_path): conf = configparser.ConfigParser() conf.read(php_cfg) xdebug_section_name = \"xdebug\" if conf.has_section(xdebug_section_name): pass else: conf.add_section(xdebug_section_name) conf.set(xdebug_section_name, \"zend_extension\", xdebug_path) conf.set(xdebug_section_name, \"xdebug.remote_enable\", \"1\") conf.set(xdebug_section_name, \"xdebug.remote_autostart\", \"1\") # conf.set(xdebug_section_name, \"xdebug.remote_host\", \"10.0.2.2\") # conf.set(xdebug_section_name, \"xdebug.remote_port\", \"9000\") outfile = codecs.open(php_cfg, \"w\") conf.write(outfile) outfile.close() if __name__ == '__main__': php_cfg = \"php.ini\" print(\"-------------check php.ini---------------\") check_php_cfg(php_cfg) print(\"-------------fetch phpinfo---------------\") phpinfo = get_php_info() print(\"-----fetch xdebug.dll download link------\") html = get_xdebug_download_page(phpinfo) download_link = find_xdebug_download_link(html) print(\"----------download xdebug.dll------------\") dir_path = \"./ext\" file_name = os.path.basename(download_link) file_path = os.path.join(dir_path, file_name) full_file_path = os.path.abspath(file_path) if not os.path.exists(file_path): # download_file(download_link, full_file_path) download_file_with_process(download_link, full_file_path) else: print(\"%(full_file_path)s already exists, skip download ……\" % {'full_file_path' : full_file_path}) update_php_cfg(php_cfg, full_file_path) 附件：php_xdebug_deploy.zip ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:3","tags":["html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["工具"],"content":"\r注意事项由于此脚本是基于xdebug.org里 custom installation instructions 提供的查询功能来实现的，如果这个站点的规则改动了，则脚本可能会失效 ps:其实在刚编写此脚本的时候，也曾考虑过采用selenium+headless browser()来处理ajax请求，不过考虑到这个脚本做的就是减法，用headless browser的方案会引入第三方可执行程序，比如chrormedriver.exe，这就太不友好了，所以还是自己分析下ajax请求，提取到[Analyse my phpinfo() output] Button的真正http请求 ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:4","tags":["html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["工具"],"content":"\r参考资料 Python3 requests文件下载 期间显示文件信息和下载进度代码实例 Python爬虫之selenium库(三)：Chrome无头模式与操作浏览器 selenium+Headless Chrome实现不弹出浏览器自动化登录–问题总结 selenium设置谷歌无头浏览器 downloading-with-chrome-headless-and-selenium ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:5","tags":["html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["装机","吐槽"],"content":" 最近入手了台Surface Pro6，然后又重新捣弄起各种常用的开发环境了，C++、Python、Php的开发环境搞起等，不过很快就遇到了各种状况，这里特此记录下来，以前很多笔记都丢到有道云笔记上了，这里重新拾遗吧。 ","date":"2019-05-07","objectID":"/posts/about-deploy-win10-environment/:0:0","tags":null,"title":"谈谈Win10系统的折腾","uri":"/posts/about-deploy-win10-environment/"},{"categories":["装机","吐槽"],"content":"\r触摸板无法正常拖动文件和截图了其实这个在Win 10里面是可以设置的，通过开始菜单 –\u003e 设置 –\u003e 设备 –\u003e 触摸板，然后勾选 ☐点击两次之后再拖动及可多选 即可，如下图所示： 另外，Win10内置的触摸板手势也可以在这个设置界面上看到哦O(∩_∩)O ","date":"2019-05-07","objectID":"/posts/about-deploy-win10-environment/:1:0","tags":null,"title":"谈谈Win10系统的折腾","uri":"/posts/about-deploy-win10-environment/"},{"categories":["装机","吐槽"],"content":"\r无法在第三方应用上打开浏览器 比如QQ、VSCode里面的url，点击之后无反应 这是因为url的默认打开程序被设置成无效程序了，可能因为之前的程序被卸载导致的，重新指定一个即可 ","date":"2019-05-07","objectID":"/posts/about-deploy-win10-environment/:2:0","tags":null,"title":"谈谈Win10系统的折腾","uri":"/posts/about-deploy-win10-environment/"},{"categories":["装机","吐槽"],"content":"\r一些应用无法正常添加到右键菜单，比如TortoiseGit、TortoiseSvn、Cmder一般是以下两种情况： 没有以管理员身份运行，比如Cmder 没有安装与Windows 系统对应的32bit/64bit版本应用，举个例子，TortoiseGit 32bit是无法在Win10 64bit上添加上右键菜单的 如果是电脑小白的话，其实还有一种是被安全管家类软件拦截导致的，这里就不赘述了==! ","date":"2019-05-07","objectID":"/posts/about-deploy-win10-environment/:3:0","tags":null,"title":"谈谈Win10系统的折腾","uri":"/posts/about-deploy-win10-environment/"},{"categories":["装机","吐槽"],"content":"\r更改TortoiseSVN的文件比较工具由于未知名原因，TortoiseIDiff工具无法在SVN Commit对话框上直接打开，因此将文本比较工具由 TortoiseIDiff更改为Beyond Compare 3， 打开TortoiseSVN的Setting，选择左边的 Diff Viewer，然后设置Diff configure，如：\"...\\BComp.exe\" %base %mine /title1=%bname /title2=%yname /leftreadonly，配置如下所示： 参考资料： TortoiseSVN比较工具设置为BeyondCompare 4 吐槽这个价位下的surface pro已经没啥性价比了，但是作为一枚伪软粉以及颜控党，终究充值了一波信仰（ps:真香定律无处不在啊），另外它的便捷性的确比普通笔记本好多了，作为一个后端狗，算是为自己的背包减肥了。 ","date":"2019-05-07","objectID":"/posts/about-deploy-win10-environment/:3:1","tags":null,"title":"谈谈Win10系统的折腾","uri":"/posts/about-deploy-win10-environment/"},{"categories":["开发工具链"],"content":"\rCMake官网\rhttps://cmake.org/\r","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:0","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["开发工具链"],"content":"\r前言CMake是一个跨平台项目构建工具，主要对标C/C++项目。其师出于automake，有其独有的DSL，详情请移步到CMake官网 ","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:1","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["开发工具链"],"content":"\r安装CMake对于Linux，这个挺简单的，CentOS执行 yum install cmake，Ubuntu执行 apt-get install cmake，如果觉得Linux发行版安装的cmake版本太旧，那么从官网上下载源码编译吧，当然，到cmake download page上下载也是个不错的途径 而对于Windows，个人是建议直接到cmake download page上下载二进制版本，将其添加到系统环境变量path上即可。电脑上安装了Msys2的话，也可以通过pacman -S cmake来安装；安装了cmder的话，在 .../vendor/init.bat 里插入 set path=%path%;xxx:/xxx/cmake-xxx/bin; 也是可以的，如下图所示： ","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:2","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["开发工具链"],"content":"\r入门教程 cmake由于其语法丰富，比较适合管理大型的跨平台c/c++工程，而在轻量级的项目里，premake、xmake、qmake都是不错的方案呢。在终端上输入 cmake -h 后，可以看到cmake 3.12.0中已经支持了vs、codeblocks、codelite、eclipse等IDE和高级文本编辑器了 至于cmake的入门教程，由于网上相关资料已经汗牛充栋了，这里就不重复了，读者可以直接移步到《CMake 入门实战》中文和《cmake-tutorial》官方英文，先过一遍中文教程，心里有底之后 ，再过一遍cmake官方教程即可入门了，剩下的知识点在项目需要用到时再学吧，毕竟只是个项目管理工具而已 下面整理了一些常用的操作命令说明: 函数 作用 project() 指定工程名称，在vs中就是.sln的名字 add_subdirectory() 设置子CMakeLists的所在路径 configure_file() 设置配置文件，一般用来预处理项目版本以及配合find_package、find_library、option等命令控制某些功能是否开启用的 add_executable() 添加一个可执行二进制项目，对应vs里的cli、gui项目 add_library() 添加一个动/静态链接库库项目，SHARED是动态链接库，STATIC是静态链接库 set() 设置变量，如果想多个CMakeLists.txt共用某个变量，那么需要将其指定为CACHE，如set(contribdir ${contribdir} ${CMAKE_CURRENT_SOURCE_DIR}/stb CACHE INTERNAL \"contrib library\" ) unset() 删除变量，通常用来删除临时变量 option() 设置操作项，可通过ON/OFF来控制开关，这个配置项在cmake-gui中以复选框的形式显示，通常与configure_file结合使用 message() 设置项目生成时的日志输出，甚至可以控制cmake的执行，比如FATAL_ERROR可终止cmake的往下执行 source_group() 将文件列表设为某个子群组，对应vs里的include、src等目录，如source_group(\"contrib/include\" ${CURRENT_HEADERS}) file() 快速搜索文件，将其存放在某个变量里，支持多路径搜索，多用于搜索头文件、资源文件什么的，配合source_group将之添加到工程里 aux_source_directory() 搜索指定路径下的源文件，通常是.cpp、.c、.cxx等后缀名的文件，结果存放在某个变量里 add_definitions() 添加预处理宏，针对当前CMakeLists下的所有项目，如果只想为某个项目添加特定的预处理宏，那么需要使用set_tests_properties，如set_tests_properties(person_dll PROPERTIES COMPILE_DEFINITIONS \"DEMO_USE_DLL\") add_custom_command() 添加自定义命令，可以设置执行时机(编译前、链接中、编译后)，比如生成了.dll后，想将其复制到主项目的可执行文件所在目录中，就需要它了，还有各种自定义生成指令也是用到了它 target_link_libraries() 设置要链接的库文件 include_directories() 添加头文件的搜索路径，只对当前CMakeLists.txt生效 link_directories() 添加链接库的搜索路径，只对当前CMakeLists.txt生效 find_package() 查找第三方包，比如某项目依赖了第三方开源库curl来实现一个下载器，那么就可以通过这条指令来判断开发者是否安装了curl，如果 没开启，则禁用下载功能，通常与CMAKE_MODULE_PATH组合使用，如SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) find_path() 搜索某路径下的文件，多用于搜索头文件、链接库，以此来控制功能的开关，举个例子，某个项目集成了一个未开源的第三方库svgload，这个第三方库时以显式调用的方式提供，也就是说，提供了.h、.dll和.lib这三个文件，但是不给源码，此时就可以通过这条指令来尝试搜索项目，看有没有这个svgload开发包了，如果没有的话，通过预编译关闭掉svg的加载功能，当然，也可以采用find_package()来实现 find_library() 搜索某路径下的链接库，find_pat其实也可以替代它，两者用法相似 ","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:3","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["开发工具链"],"content":"\r非官方例子由于工作中用到的东西有点多，脑子记不过来，因此在此特意记下几个常用的例子，这里以图片转换器为例: 基本功能：加载常见的图片格式，如jpg、png、bmp、svg等，将其转换成其它图片格式，目前仅提供CLI版本用作演示 技术选型如下: +--------\u003eImageLoadModule(gdi+、stb_image.h、libgif、naosvg、skia、freeimage等)，加载磁盘上的图片资源到内存中 | | ImageConverter--|---------\u003eAutoCompleteModule(linenoise、readline等)，为CLI程序提供命令自动补全的功能 | | +--------\u003eImageSaveModule(gdi+、stb_image_write.h、freeimage等)，将内存中的图片数据保存到磁盘 ImageConverter 0.1 这只是一个初始版，仅仅是搜索项目下的源文件，将其添加到VS上，可以编译执行了，附件：ImageConverter0.1.zip # 指定cmake的最小版本 cmake_minimum_required(VERSION 2.8) # 指定工程名称，ImageConverter.sln project(ImageConverter) # 搜索当前目录下的源码文件，用srcs存储起来 aux_source_directory(. srcs) # 配置一个可执行文件项目，ImageConverterDemo.vcxproj add_executable(ImageConverterDemo ${srcs}) ImageConverter 0.2 接下来搭建这个项目的基础部分，定好各种组件的接口，这里先以gdi+作为图片的编解码器，附件：ImageConverter0.2.zip # 指定cmake的最小版本 cmake_minimum_required(VERSION 2.8) # 指定工程名称，ImageConverter.sln project(ImageConverter) # 搜索目录下的源码文件 aux_source_directory(. srcs) FILE(GLOB_RECURSE coresrcs ./core/*.cpp ) FILE(GLOB_RECURSE miscsrcs ./misc/*.cpp ) # 搜索目录下的头文件 FILE(GLOB_RECURSE coreheaders ./core/*.h ) FILE(GLOB_RECURSE mischeaders ./misc/*.h ) # 添加到项目筛选器上 source_group(\"src\" FILES ${srcs}) source_group(\"src\\\\core\" FILES ${coresrcs}) source_group(\"src\\\\misc\" FILES ${miscsrcs}) source_group(\"include\\\\misc\" FILES ${mischeaders}) source_group(\"include\\\\core\" FILES ${coreheaders}) # 添加头文件搜索路径 include_directories(./core) include_directories(./misc) # 配置一个可执行文件项目，ImageConverterDemo.vcxproj add_executable(ImageConverterDemo ${srcs} ${coresrcs} ${miscsrcs} ${coreheaders} ${mischeaders}) ImageConverter 0.5 这里调用了第三方类库nanosvg来支持svg文件的读取，主要演示了如何通过Git来管理第三方类库，以及如何在cmake里面整合第三方类库源码的过程，简略描述如下： 借助option来配置svg的功能开启，如果为ON，则这里以SUPPORT_SVG_TYPE作为开启的条件，通过add_definitions(-DSUPPORT_SVG_TYPE)来添加预处理宏，源码里以SUPPORT_SVG_TYPE作为预编译宏，整理所有与svg相关的代码逻辑，另外，也要在CMakeLists.txt中，以if(SUPPORT_SVG_TYPE)判断是否执行追加相关头文件搜索路径，添加相关文件名到工程等命令 借助configure_file来配置一个外部的头文件，用来传入程序的版本号，当然，也可以配合option来做其他事情 附件：ImageConverter0.5.zip # 指定cmake的最小版本 cmake_minimum_required(VERSION 2.8) # 指定工程名称，ImageConverter.sln project(ImageConverter) # 配置版本号 set (APP_VERSION_MAJOR 1) set (APP_VERSION_MINOR 0) # 配置是否开启SVG的支持 option (SUPPORT_SVG_TYPE \"support .svg file\" ON) # 加入一个配置头文件，用于处理 CMake 对源码的设置 configure_file ( \"${PROJECT_SOURCE_DIR}/config.h.in\" \"${PROJECT_SOURCE_DIR}/config.h\" ) aux_source_directory(. srcs) source_group(\"src\" FILES ${srcs}) FILE(GLOB_RECURSE coresrcs ./core/*.cpp ) source_group(\"src\\\\core\" FILES ${coresrcs}) FILE(GLOB_RECURSE miscsrcs ./misc/*.cpp ) source_group(\"src\\\\misc\" FILES ${miscsrcs}) FILE(GLOB_RECURSE coreheaders ./core/*.h ) source_group(\"include\\\\core\" FILES ${coreheaders}) FILE(GLOB_RECURSE mischeaders ./misc/*.h ) source_group(\"include\\\\misc\" FILES ${mischeaders}) if(SUPPORT_SVG_TYPE) FILE(GLOB_RECURSE nanosvgheaders ./modules/nanosvg/src/*.h ./modules/nanosvg/example/*.h ) source_group(\"modules\\\\include\\\\nanosvg\" FILES ${nanosvgheaders}) include_directories(./modules/nanosvg/src) include_directories(./modules/nanosvg/example) add_definitions(-DSUPPORT_SVG_TYPE) endif(SUPPORT_SVG_TYPE) # 添加头文件搜索路径 include_directories(./core) include_directories(./misc) # 配置一个可执行文件项目，ImageConverterDemo.vcxproj add_executable(ImageConverterDemo ${srcs} ${coresrcs} ${miscsrcs} ${coreheaders} ${mischeaders} ${nanosvgheaders}) ImageConverter 0.6 目前发现Gdiplus里面的图片编码、解码的功能还是太弱了，支持的图片类型太少，比如无法正常加载psd类型，因此打算采用FreeImage来加强这个功能。由于FreeImage是以一个动态库的开发包形式分发的，因此需要更多的指令来控制依赖FreeImage库的工程生成，其中包括项目生成之后的dll文件拷贝、根据.dll、.lib的文件是否存在来判断是否生成ForFreeImage的工程等等，用到的关键指令如下所示： 函数 作用 FIND_PACKAGE() 用来查看cmake目录下的xxx.cmake文件，里面定义了这个模块的源码、开发包的搜索方式，注意，xxx.cmake里定义的参数可以传递到CMakeLists.txt里面哦 set_target_properties() 为指定项目配置特有属性，通常用来添加项目特有的宏定义，而add_definitions定义的宏会添加到所有生成的项目中，注意这个的区别哦 target_link_libraries() 让指定项目链接静态库/导入库，不是作用到所有项目哦 add_custom_command() 自定义生成命令，在此是为了让FreeImage项目生成后，自动拷贝FreeImage开发包下的.dll文件到.exe所在目录下，注意，这里面还用set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) 来重定向输出目录了哦 附件：ImageConverter0.6.7z ### 这里仅仅截取CMakeLists.txt的FreeImage配置相关代码段 SET(CMAKE_","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:4","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["开发工具链"],"content":"\rFAQ\r不熟悉xxx命令，如何快速检索相关资料呢 对于不熟悉的cmake command，有两种方法可以快速找到其使用说明，这里以find_path为例 直接在终端上输入cmake -h find_path来查询即可，如下图所示: 直接问度娘或谷歌，输入cmake find_path来搜索即可，通常搜索引擎前三就是cmake官方的文档，后面的搜索结果是网友的一些博客了 自2023年之后，可以借助ChatGpt4、Github Copilot之类的问答类大模型来快速查找相关函数用法，这个比搜索引擎更加便捷 SublimeText、VSCode等编辑器应该安装什么插件来快速编辑cmake呢 SublimeText—-CMakeEditor VSCode—-CMakeTool+CMake 如何调用cmake来编译工程 cd build/ cmake --build . ","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:5","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["开发工具链"],"content":"\r参考资料: cmake 设置vs工程的MT、MTd cmake:msvc编译第三方库时使用/MT静态库连接c/c++ runtime library ","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:6","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["工具"],"content":"宇宙第一IDE，yyds ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:0:0","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["工具"],"content":"\r快捷键配置","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:1:0","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["工具"],"content":"\rVisual Studio常用快捷键 快捷键 描述 ctrl+k+ctrl+c 代码注释 ctrl+shift+u 让被选中的文本里的字母全部转换为大写 ctrl+u 让被选中的文本里的字母全部转换为小写 ctrl+shift+space 当光标在函数的小括号里面的时候，会弹出此函数的参数列表 ctrl+i 向前导航跳转 ctrl+o 向后导航跳转 ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:1:1","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["工具"],"content":"\rVisual Assist常用快捷键 快捷键 描述 shift+alt+s Find Symbol shift+alt+f Find References alt+g Goto Implementation shift+alt+g Goto Related shift+alt+o Open File in Solution ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:1:2","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["工具"],"content":"\rVisual Assist插件配置","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:2:0","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["工具"],"content":"\rC++注释配置\r枚举类型注释[\\e] /** @brief $SymbolContext$ */ enum AnotherEnum { V1,/**\u003c value 1 */ V2 /**\u003c value 2 */ }; 函数注释[\\*] /** * @brief: $SymbolContext$ * @param[in] 参数类型 参数名 参数说明 * @param[in|out] 参数类型 参数名 参数说明 * @return 返回值说明 * @note * $end$ */ 类注释[\\c] /** * @class $ClassName$ * @brief $SymbolContext$ * @note * $end$ */ 文件头注释[\\h] /***************************************************************************** * @file $FILE_BASE$.$FILE_EXT$ * @brief $SymbolContext$ * @note * $end$ * *----------------------------------------------------------------------------* * Change History : * \u003cVersion\u003e | \u003cDescription\u003e *----------------------------------------------------------------------------* * 0.0.0.1 | 创建头文件 *----------------------------------------------------------------------------* * *****************************************************************************/ 注意，需要安装Visual Assist插件哦。具体需要【VAssisX】–\u003e【Tools】–\u003e【Edit VA Snippets】，然后将上面的注释宏添加到打开的VA Snippet Editor之中 ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:2:1","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["工具"],"content":"\r其他功能","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:3:0","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["工具"],"content":"\r显示特殊变量无需编写插件或修改配置文件，只需要将要显示的变量拉到监视调试窗口(Watch Windows)中，并在变量后面添加,xxx即可显示，目前支持以下功能 只需要将要显示的字符串拉到Watch中,并在变量后面添加,s8即可显示 变量显示标识 描述 ,数字 将变量拆分为数组显示, 数字是要显示多少位, 此法对const char*这类原始字符串非常有用 ,s8 转换为UTF-8字符串查看 ,x 转换成16进制查看 ,hr 转换成Windows HRESULT解释查看 ,wm 转换成Windows消息查看，例如0x0010, wm 显示 WM_CLOSE ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:3:1","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["工具"],"content":"\rFAQ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:4:0","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["工具"],"content":"\r编译错误’std::tuple’ : too many template arguments在VS 2012编译Gtest源码的时候，遇到了此错误，具体讨论看一下链接：《Google Test in Visual Studio 2012》 解决方法 只需要在VS工程中，添加预处理 _VARIADIC_MAX=10即可，如果此VS工程是通过qmake来生成的话，那么需要在指定的xxx.pro文件上添加上DEFINES += _VARIADIC_MAX=10语句即可。 ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:4:1","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["工具"],"content":"\risnan()和isinf()未定义此问题是本人在使用VS 2012编译log4z开源库时冒出来的，其实类似的问题集中在VC上出现，这是由于VC支持新标准不及时所引起的，详情可看：《isnan isinf》 解决方法 在报错的所在文件头上添加上以下代码段即可： inline int isnan(double x) { return x != x; } inline int isinf(double x) { return !isnan(x) \u0026\u0026 isnan(x - x); } ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:4:2","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["编程语言"],"content":"\rLua官网\rhttps://www.lua.org/\r","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:0","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r在Lua实现带默认参数的函数在lua之中，它没有提供像C++那样的不同参数列表的同名函数是不同的机制，在它的内部里面，其实现了一种很朴素的做法 假设定义了一个有n个形参的函数 SetArgs(arg1...argn)，那么若果开发者在实际调用此函数的时候，填充的参数的个数小于n，那么后面没有添加的参数的实参都默认被设为nil，此时通过or运算符来设定默认值即可；另外，也并不支持 SetArgs(arg1 = 1,arg2 = 2, argn = n )之类的语句，如下所示： myTable = { a= 1, b=2, c=3, d=4 } --一种难以言喻的操作 function myTable:SetParam(a1,b1,c1,d1) self.a = a1 or \"a1\" self.b = b1 or \"b1\" self.c = c1 or \"c1\" self.d = d1 or \"d1\" end --并没有这种骚操作 --function myTable:SetParam(a1 = \"a1\",b1 = \"b1\",c1 = \"c1\",d1 = \"c1\") -- self.a = a1 -- self.b = b1 -- self.c = c1 -- self.d = d1 --end local temp = myTable temp:SetParam(\"Adobe\") print(temp.a) print(temp.b) print(temp.c) print(temp.d) print(\"end\") ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:1","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r模拟C++的类的继承机制更多相关资料请看Metatable In Lua 浅尝辄止 --lua仿写类似C++的类 --注意，lua的默认参数比较奇葩，在成员函数内部，直接添加xxx1 or xxx2即可 people = { } function people:new( newName, newIdentity ) obj = {} obj.name = newName or \"unknown name1\" obj.identity = newIdentity or \"unknown identity1\" setmetatable(obj,self) self.__index = self return obj end --添加成员函数 function people:GetName() return self.name end function people:GetIdentity() return self.identity end function people:PrintInfo() print(\"object belong to people\") end --student继承people，此时是相当于将people的元表拷贝到student里面了 student = people:new() --为了避免类实例在创建的时候修改了类的成员变量，因此采用了临时表obj来作为缓冲 --毕竟Lua本身是没有Lua这个概念的，如果不采用临时Table作为缓冲，是无法把类实例和类之间的联系切断 function student:new( newName, newIdentity, newClassroom, newIndex ) obj = people:new( newName, newIdentity ) setmetatable(obj, self) --self.__index = self使得自身的属性都能被obj访问到 self.__index = self --添加成员变量 obj.classroom = newClassroom or \"unknown classroom2\" obj.index = newIndex or \"unknown index2\" return obj end --添加成员变量到子类里 function student:GetClassroom() return self.classroom end function student:GetIndex() return self.index end --重载基类的成员函数 function student:PrintInfo() print(\"object belong to student\") end print(\"startup\") temp = student:new(\"childname\", 56579887, \"classroom1st\", \"1\") --开启了下面语句之后可以发现，此时temp的数值会被temp3所影响 temp3 = student:new(\"childname3\", 4987, \"classroom3rd\", 10) baseObj =people:new(\"basename\", 110) baseObj3 =people:new(\"basename3\", 10000000) print(\"---------打印类实例的信息--------\") print(\"在子类实例中调用基类成员函数\") print(temp:GetIdentity()) print(temp:GetName()) print(\"在子类实例中调用子类成员函数\") print(temp:GetClassroom()) print(temp:GetIndex()) temp:PrintInfo() print(\"调用基类实例的成员函数\") print(baseObj:GetName()) print(baseObj:GetIdentity()) print(\"---------打印当前定义的基类与子类类型的数据--------\") print(\"以下为基类的信息\") --而name和name是在执行new函数的时候，才为其类实例追加的成员变量， --而这些成员变量在原本的people里是没有的，因而为nil，正如people = {} print(people.name) print(people.name) people:PrintInfo() print(\"以下为子类类型的信息\") --name和identity是从people继承过来的，并且，在继承的时候，通过new函数临时为其创建的，因此数值有效 print(student.name) print(student.identity) --而classroom和index是在执行new函数的时候，才为其类实例追加的成员变量， --而这些成员变量在原本的student是没有的，因而为nil，正如student = people:new{} print(student.classroom) print(student.index) student:PrintInfo() print(\"end\") --注意，在new()内，修改self里面的数值的时候，会导致类的成员变量也同时改变，因为，在Lua里面，本身是没有类这个概念的，我们只可以通过Table来模拟类似的类行为，为了绕过Lua的固有限制，我们在通过new()等函数进行类实例创建的时候，使用临时Table来存放此类的特有的成员变量以及成员变量。 --在上述代码里面，student里的classroom和index是无效数值，都为nil，在student:new()函数体内，使用了临时变量obj来存放其基类的成员变量以及成员函数，通过setmetatable(obj,self)语句，让obj拥有了student里面的成员函数以及基类的特性。而之所以需要执行student = people:new()语句，这是为了可以让student继承people的特性了，否则，所有调用了student类实例所有用到基类的方法都将无效，总而言之，这个metatable的作用有点像C++里面的虚表，专门用来定位子类实例和基类之间的成员函数以及成员变量的地址的 ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:2","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r控制Table类型的访问权限要想实现此效果，需要使用Table里面__index和__newindex变量，更多详情请看《用__index和__newindex来限制访问》，如下所示： --访问权限控制函数 function cannotModifyHp(object) local proxy = {} local mt = { __index = object, __newindex = function(k,v) if k ~= \"hp\" then object[k] = v end end } setmetatable(proxy,mt) return proxy end object = {hp = 10,age = 11} --function object.sethp(self,newhp) -- self.hp = newhp --end function object:sethp(newhp) self.hp = newhp end o = cannotModifyHp(object) o.hp = 100 --修改失效 print(o.hp) o:sethp(111) --修改失效 print(o.hp) object:sethp(100) --修改生效 print(o.hp) ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:3","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\rLua上的语法糖收集 v:name(args) 可以被解析成 v.name(v,args) 或者 v.name(self,args) 举个栗子，如下所示： object = {hp = 10,age = 11} function object.SetHp1st(self,newHp) self.hp = newHp end function object:SetHp2nd(newHp) self.hp = newHp end function funcname() body end 等效于 funcname = function() body end function table.a.b.c.funcname() body end 等效于 table.a.b.c.funcname = function() body end local function funcname() body end 等效于 local funcname; funcname = function() body end 不等效于 local funcname = function() body end哦 ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:4","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r重载运算符Lua的运算符在Lua之中，我们可以通过Metatable(元表)来重载非数值运算符，能够重载的运算符如下所示： 运算符 在Lua里的关键字 意义 + add 加法运算 - sub 减法运算 * mul 乘法运算 / div 除法运算 % mod 取模运算，获取余值 ^ pow 幂运算 – urm 一元**-**操作符 .. concat 连接操作 # len 取数据类型的长度，比如table长度等 == eq 关系运算符：相等 \u003c lt 关系运算符：小于 \u003c= le 关系运算符：小于或等于 [] index 通过下标访问Table[key]，仅用于读取数据 [] newindex 通过下标Table[key] ，仅用于修改数据，如Table[key] = value 未知 call 当Lua调用一个值时调用 以下演示了如何重载支持特定格式的表的运算符操作，如+和- --定义2个表 --a = {5, 6,10,8,69,10,\"hello\"} a = {5, 6} b = {7, 8} --用c来做Metatable c = {} --重定义加法操作 c.__add = function(op1, op2) -- 将所有元素进行配对相加 local result = {} local lenght1 = table.maxn(op1) local lenght2 = table.maxn(op2) if lenght1 == lenght2 then for index,item in ipairs(op1) do table.insert(result,op1[index]+op2[index]) end end return result -- --枚举op2的所有元素，将其插入到op1之中，相当于C++里面的重载运算符+ -- for key, item in ipairs(op2) do -- print(\"key = \"..key) -- print(\"item = \"..item) -- --将item插入到op1之中 -- table.insert(op1, item) -- end -- return op1 end c.__sub = function (op1,op2) local result = {} local lenght1 = table.maxn(op1) local lenght2 = table.maxn(op2) if lenght1 == lenght2 then for index,item in ipairs(op1) do table.insert(result,op1[index]-op2[index]) end end return result end --将a的Metatable设置为c --将__add的方法应用到类b的Table数据中 --setmetatable(a, c) setmetatable(b, c) --d现在的样子是{5,6,7,8} d = a + b --d = b + a for key1,value1 in ipairs(d) do print(value1) end --print(c.__add(a,b)[1]) --print(c.__add(a,b)[1]) e = a - b --d = b + a for key2,value2 in ipairs(e) do print(value2) end ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:5","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r和C++相比，那些常见的知识盲区 Lua没有关系操作符!=，以~=来代替，其它的倒是和C++一样 --如果a不为10的话，那么打印a if a ~= 10 then print(a) end Lua的函数体不要用{body}来包裹起来，只需要在后面添加上end即可，另外在Lua之中，if代码块不需要用(body)来包裹起来，只需要在判断之中，通过空格区分开来，然后在后面添加then即可，注意，有elseif而没有else if的语句哦，比如if exp then body end 和 elseif exp then body function IsMatchedID(oldID, newID) if oldID == newID then return true elseif oldID \u003e newID then print(\"oldID \u003e newID\") return false else print(\"oldID \u003c newID\") return false end end print(IsMatchedID(10,13)) print(IsMatchedID(10,10)) print(IsMatchedID(18,10)) 获取Table、字符串等类型的长度，不需要length()等函数来获取，直接用*#*即可 tempTable = {897,8,78,7,87,87,8,78,78,7,87,8,7} print(#tempTable) tempString = \"fadfadfadf\" print(#tempString) ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:6","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r参考资料 云风的 BLOG Lua 教程 ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:7","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["技术选型"],"content":"当摩尔定律的影响力逐渐消退，我们有必要回顾那段硬件资源受限、成本高昂的岁月。在那个时代，开发者们不得不发挥创造力，深入挖掘机器的潜力，精心优化任务调度，从而孕育出一系列高效的并发处理策略，这里，主要是探讨下主流的Actor模型和CSP模型 核心内容是来自《Actor模型和CSP模型的区别》\rhttp://www.jdon.com/concurrent/actor-csp.html\r","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:0","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["技术选型"],"content":"\rActor模型在Actor模型中，主角是Actor，类似一种worker，Actor彼此之间直接发送消息，不需要经过什么中介，消息是异步发送和处理的： Actor模型描述了一组为了避免并发编程的常见问题的公理: 所有Actor状态是Actor本地的，外部无法访问。 Actor必须只有通过消息传递进行通信。 一个Actor可以响应消息:推出新Actor，改变其内部状态，或将消息发送到一个或多个其他参与者。 Actor可能会堵塞自己，但Actor不应该堵塞它运行的线程。 更多可见Actor模型专题 ","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:1","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["技术选型"],"content":"\rChannel模型Channel模型中，worker之间不直接彼此联系，而是通过不同channel进行消息发布和侦听。消息的发送者和接收者之间通过Channel松耦合，发送者不知道自己消息被哪个接收者消费了，接收者也不知道是哪个发送者发送的消息。 Go语言的CSP模型是由协程Goroutine与通道Channel实现： Go协程goroutine 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。 通道channel 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。 ","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:2","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["技术选型"],"content":"\rActor模型和CSP区别Actor模型和CSP区别图如下： Actor之间直接通讯，而CSP是通过Channel通讯，在耦合度上两者是有区别的，后者更加松耦合。 同时，它们都是描述独立的流程通过消息传递进行通信。主要的区别在于：在CSP消息交换是同步的(即两个流程的执行\"接触点\"的，在此他们交换消息)，而Actor模型是完全解耦的，可以在任意的时间将消息发送给任何未经证实的接受者。由于Actor享有更大的相互独立，因为它可以根据自己的状态选择处理哪个传入消息，自主性更大些。 在Go语言中为了不堵塞流程，程序员必须检查不同的传入消息，以便预见确保正确的顺序。CSP好处是Channel不需要缓冲消息，而Actor理论上需要一个无限大小的邮箱作为消息缓冲。 ","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:3","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["技术选型"],"content":"\r发展现状 Actor模型最初由Erlang推出，后已被多种编程语言实现了，其中c语言里面，出名的有云风大大维护的skynet，采用c/lua混合开发，而c++有caf，java有akka等等 CSP模型也是如此，目前在Golang这里最为出名 现如今，在游戏服务端开发领域里，Actor模型在c/c++/lua、erlang这几块发展得红红火火，而CSP模型则以Golang技术栈马首是瞻 ","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:4","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["技术选型"],"content":"\r参考资料 《Actor模型和CSP模型的区别》 《为什么Actor模型是高并发事务的终极解决方案？》 《Actors编程模型》 《The Actor Model (everything you wanted to know…)》 《ActorLite: 一个轻量级Actor模型实现》 《Comparison between 4 actor frameworks》 《一个轻量级Actor并发框架的c++实现， libgsc(Game Server Communication Library)》 《详解Theron通过Actor模型解决C++并发编程的一种思维》 The C++ Actor Framework官网 吐槽近十多年来，在摩尔定律大抵还生效的时期里，App开发采取的技术方案越来越耗机器资源了，达到了一种不可理喻的程度，比如有些App开发者采用了各种Web App开发策略、桌面软件开发者采用了类似Electron框架来进行客户端开发等，导致网上许多功能简单的程序，安装包体积巨大，这实际是对机器资源的一种巨大浪费，怀念以前的小巧精致的App 很多方案是跨平台需求带进来的妥协，好在，有开发者顶不住Electron巨大的分发体积，搞出了tauri方案，而在原生跨平台开发领域里，Google推出了Flutter，发展势头也非常好 ","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:5","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["代码规范"],"content":"\rGoogle 开源项目风格指南\rhttps://zh-google-styleguide.readthedocs.io\r","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:0:0","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r前言在c++这个大联盟里，有许许多多领导组织，微软、Google、IBM，还有国内各个大厂内部因地制宜定下的各种代码规范，而在我目前的职业生涯里，先后经历了两种c++代码规范洗礼，其实项目内部具体用什么代码规范，一般都由leader定下的，新加入团队的成员理应遵循已有的代码规范，保证团队工程风格的一致性 但是，作为开发大军里的一员，除开企业内的团队开发，我们私下也会有自己的创造欲望，去捣弄自己的小项目，那么在这个时候，就需要定下一个从一而终的代码规范了，如果机遇一到，拉到融资或者和其它小伙伴一起创业，它就能作为团队规范的一部分了 目前在业界之内，谷歌的开源氛围是较为浓厚的，它提供了许多深受业界认可的开源项目，比如chromium、grpc、protobuf、gson……，还往业界输出了它的《Google 开源项目风格指南》，而之前自己在c++学习的过程中，也用到了其中一些开源库 而刚毕业那会，由于做的是windows下的win32软件开发，因此最开始用的是mfc那套规范；后续进了游戏行业，一直从事游戏服务端开发，此时起就采用google的代码规范了。现今反思了一些东西，自己要想长远发展的话，采用谷歌这套会更好些 ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:1:0","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r命名规范","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:2:0","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r通用命名规则 函数命名，变量命名，文件命名要有描述性；少用缩写。 尽可能给有描述性的命名，别心疼空间，毕竟让代码易于新读者理解很重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个字母来缩写单词。 //示例： int price_count_reader; // 无缩写 int num_errors; // “num” 本来就很常见 int num_dns_connections; // 人人都知道 “DNS” 是啥 //反例： int n; // 莫名其妙。 int nerr; // 怪缩写。 int n_comp_conns; // 怪缩写。 int wgc_connections; // 只有贵团队知道是啥意思。 int pc_reader; // \"pc\" 有太多可能的解释了。 int cstmr_id; // 有删减若干字母。 ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:2:1","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r文件命名 文件名要全部小写, 可以包含下划线 (_) 或连字符 (-). 按项目约定来. 如果并没有项目约定，_ 更好。接受的文件命名: my_useful_class.cc my-useful-class.cc myusefulclass.cc muusefulclass_test.cc // _unittest 和 _regtest 已弃用。 C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾，参见:ref:self-contained headers。 不要使用已经存在于 /usr/include 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如db.h. 通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好. 定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar. 内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中. ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:2:2","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r类型命名 类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum. 所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举 —— 均使用相同约定. 例如: // classes and structs class UrlTable { ... class UrlTableTester { ... struct UrlTableProperties { ... // typedefs typedef hash_map\u003cUrlTableProperties *, string\u003e PropertiesMap; // enums enum UrlTableErrors { ... ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:2:3","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r变量命名 变量名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用，如::a_local_variable, a_struct_data_member, a_class_data_member_. 【普通变量命名】: //举例: string table_name; // 可 - 用下划线。 string tablename; // 可 - 全小写。 //反例: string tableName; // 差 - 混合大小写。 【类数据成员】： 不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样, 但要接下划线。 class TableInfo { private: string table_name_; // 可 - 尾后加下划线。 string tablename_; // 可。 static Pool\u003cTableInfo\u003e* pool_; // 可。 }; 【结构体变量】: 不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样, 不用像类那样接下划线: struct UrlTableProperties { string name; int num_entries; } 【全局变量】: 对全局变量没有特别要求, 少用就好, 但如果你要用, 可以用 g_ 或其它标志作为前缀, 以便更好的区分局部变量. 【常量命名】 在全局或类里的常量名称前加 k: kDaysInAWeek. 且除去开头的 k之外每个单词开头字母均大写。 所有编译时常量, 无论是局部的, 全局的还是类中的, 和其他变量稍微区别一下. 这规则适用于编译时的局部作用域常量，不过要按变量规则来命名也可以。 k后接大写字母开头的单词: const int kDaysInAWeek = 7; 【函数命名】 常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable(), 自定义函数不能与系统或库函数同名. [常规函数]: 函数名的每个单词首字母大写, 没有下划线。 如果您的某函数出错时就要直接 crash, 那么就在函数名加上 OrDie. 但这函数本身必须集成在产品代码里，且平时也可能会出错。 AddTableEntry() DeleteUrl() OpenFileOrDie() [取值和设值函数]: 取值（Accessors）和设值（Mutators）函数要与存取的变量名匹配. 这儿摘录一个类,num_entries_ 是该类的实例变量: class MyClass { public: ... int GetNumEntries() const { return num_entries_; } void SetNumEntries (int num_entries) { num_entries_ = num_entries; } private: int num_entries_; }; 其它非常短小的内联函数名也可以用小写字母, 例如. 如果你在循环中调用这样的函数甚至都不用缓存其返回值, 小写命名就可以接受. 【名字空间命名】 名字空间用小写字母命名. 【枚举命名】 枚举的命名应当和常量或宏一致: kEnumName 或是 ENUM_NAME. 单独的枚举值应该优先采用常量的命名方式. 但宏方式的命名也可以接受. 枚举名 UrlTableErrors(以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式. enum UrlTableErrors { kOK = 0, kErrorOutOfMemory, kErrorMalformedInput, }; enum AlternateUrlTableErrors { OK = 0, OUT_OF_MEMORY = 1, MALFORMED_INPUT = 2, }; 【宏命名】 你并不打算使用宏 \u003cpreprocessor-macros\u003e, 对吧? 如果你一定要用, 像这样命名:MY_MACRO_THAT_SCARES_SMALL_CHILDREN. 通常不应该使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线: #define ROUND(x) ... #define PI_ROUNDED 3.0 【命名规则的特例】 [X]如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略. ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:2:4","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r注释规范这块倾向使用doxgen提供的注释规范，因为如果后续需要自动生成一份开发文档，这个就比较方便 不过，注释固然很重要, 但好的代码本身应该是自文档化的，有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字 【注释风格】 使用 // 或 /* */, 统一就好 // 或 /* */ 都可以; 但 // 更常用些 要在如何注释及注释风格上确保统一 【文件注释】 .h 文件要对所声明的类的功能和用法作简单说明，如果可以的话，可以在文件头上罗列一份feature_list或者todo_list .cc 文件通常包含了更多的实现细节或算法技巧讨论 如果你感觉这些实现细节或算法技巧讨论对于理解.h文件有帮助, 可以该注释挪到.h, 并在.cc中指出文档在.h中 不要简单的在.h和.cc间复制注释. 这种偏离了注释的实际意义 文件头举例如下: /***************************************************************************** * @file auto_register_factory.h * @brief 可注册的工厂类模板 * @note * C++反射机制的一种实现，基于类行为抽象而成 *****************************************************************************/ 【类注释】 每个类的定义都要附带一份注释, 描述类的功能和用法. 举例如下: /** * @class CSigleRegisterFactory * @brief 一个支持自动注册的工厂类模板 * @note * 注意，如果TKey是自定义数据类型，那么请重载其关系运算符哦， * 具体看std::map的条件，通常仅需要重载运算符“\u003c”，详情请看 * https://msdn.microsoft.com/ZH-CN/library/s44w4h2s(v=VS.100,d=hv.2).aspx * 在gcc下编译可能遇到的问题：http://blog.csdn.net/pb1995/article/details/49532285 * 仅仅支持一对一的模式 */ template\u003ctypename TKey, typename TBase\u003e class CSingleRegisteredFactory { ... }; 【函数注释】 函数声明处注释描述函数功能，定义处描述函数实现 [函数声明]: 注释位于声明之前, 对函数功能及用法进行描述. 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情 函数声明处注释的内容: 函数的输入输出. 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数. 如果函数分配了空间, 需要由调用者释放. 参数是否可以为 NULL. 是否存在函数使用上的性能隐患. 如果函数是可重入的, 其同步前提是什么? 使用brief、param、return、note等来描述具体的注释块 举例如下: /** * @brief: 将某类注册到工厂类实例之中 * @param[in] TKey Key 某类在外部检索时所用到的条件，通常采用字符串或枚举等类型 * @param[in|out] IForwarder\u003cTBase\u003e* pobj 待注册到工厂类实例的基类指针，自动跳过空指针 * @param[in] bool bIsOverWrite 如果为true，则重新注册此类，否则，直接释放待注册的基类指针 * @return 无 * @note * 本类会自动管理所有想要注册到本类工厂的基类指针，因此需要对重复注册的类指针自动进行释放 */ void RegisterFactory(TKey key, ImpForwarder *ptr_obj, bool is_overWrite = false) 但也要避免啰啰嗦嗦, 或做些显而易见的说明. 下面的注释就没有必要加上 “returns false otherwise”, 因为已经暗含其中了: // Returns true if the table cannot hold any more entries. bool IsTableFull(); 注释构造/析构函数时, 切记读代码的人知道构造/析构函数是干啥的, 所以 “destroys this object” 这样的注释是没有意义的. 注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的. [函数定义]: 每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要. 不要 从 .h 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上. 【变量注释】 通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明. [类数据成员]: 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明. 比如: private: // Keeps track of the total number of entries in the table. // Used to ensure we do not go over the limit. -1 means // that we don't yet know how many entries the table has. int num_total_entries_; [全局变量]: 和数据成员一样, 所有全局变量也要注释说明含义及用途. 比如: // The total number of tests cases that we run through in this regression test. const int kNumTestCases = 6; 【实现注释】 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释. [代码前注释]: 巧妙或复杂的代码段前要加注释. 比如: // Divide result by two, taking into account that x // contains the carry from the add. for (int i = 0; i \u003c result-\u003esize(); i++) { x = (x \u003c\u003c 8) + (*result)[i]; (*result)[i] = x \u003e\u003e 1; x \u0026= 1; } [行注释]: 比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如: // If we have enough memory, mmap the data portion too. mmap_budget = max\u003cint64\u003e(0, mmap_budget - index_-\u003elength()); if (mmap_budget \u003e= data_size_ \u0026\u0026 !MmapData(mmap_chunk_bytes, mlock)) return; // Error already logged. 注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志. 如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性: DoSomething(); // Comment here so the comments line up. DoSomethingElseThatIsLonger(); // Comment here so there are two spaces between // the code and the comment. { // One space before comment when opening a new scope is allowed, // thus the comment lines up with the following comments and code. DoSomethingElse(); // Two spaces before line comments normally. } NULL, true/false, 1, 2, 3...: 向函数传入 NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意. 例如, 对比: bool success = CalculateSomething(interesting_value, 10, false, NULL); // What are these arguments?? 和: bool success = CalculateSomething(interesting_value, 10, // Default base value. false, // Not the first time we're calling this. NULL); // No callback. 或使用常量或描述性变量: const int kDefaultBase","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:3:0","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r参考资料 Google 开源项目风格指南 - C++风格指南 Google C++ Style Guide ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:4:0","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["自述"],"content":"\r关于我\r与Bug兄打交道良久~ o(￣▽￣)o熟悉VS、VSCode、Vim、Idea、Sublime等软件的安装/卸载技巧，掌握C/C++、Lua、Erlang、Python、JavaScript等单词的各种拼写方式 世界那么大，总想去看看QAQ希望足迹可以遍布大江南北，目前只是到过广西北海、湖南岳麓书院、张家界、广东清远古龙峡、杭州、苏州、南京、厦门等地方，出国只游过泰国，想想啥时候可以组队去趟日本溜达下，果然还是太弱鸡了23333 杂食的音乐路人甲音乐无国界啦，本人尤爱中国风，喜欢在KTV里鬼哭狼嚎O(∩_∩)O 挂念着小霸王、街机的游戏爱好者OMG早前喜欢在模拟器上玩玩拳皇、热血格斗、风卷残云什么的，不过现在也配上了Switch和Quest2了，玩得范围也更广些，手游上目前比较喜欢决斗链接、荒野乱斗啦 关于本博客目前本人私下会用到好几个笔记/博客工具，主要如下： Hexo=\u003eHugo：主要做对外分享的 之所以转到Hugo是因为Hexo那边的Npm包依赖太重了，本人多台机器上复原发布环境过于麻烦（本人Hack了Hexo官网的主题），遂改成了Hugo amWiki：更多用于记录自己工作上的一些笔记 因为之前本人特意为它开发了一款amWikiForVSCode，一直用到现在，也习惯了 Logseq：这个是新入手的笔记工具，用来作为OKR管理工具和ToDo管理工具 因为之前做年度总结的时候，苦于之前的记录过于分散，此工具的双向链接解决了这个问题，并且还提供了一个知识图谱，刚好解决了这个问题 至于为啥不再使用有道云笔记，这是因为还在读书那会，不幸遇到了一次新旧版本有道云笔记在进行跨设备数据同步时，目录层级丢失以及大量笔记找不回的问题，一直对此心有戚戚，现在更偏好于自己管理自己的数据，以避免类似的事情发生 ","date":"0001-01-01","objectID":"/abouts/about_me/:0:0","tags":["自述"],"title":"争取做个懂生活的IT人","uri":"/abouts/about_me/"}]