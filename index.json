[{"categories":["开发技巧"],"content":"在整个工作生活中，我们都扮演着各种角色，亦因此需要用到各种工具，比如需求分析、架构设计、技术方案讲解等等，这里记录了本人用到的一些常用工具 ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:0:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["开发技巧"],"content":"\r日常工具 IDE VSCode IntelliJ IDE 截图\u0026标注软件 ScreenPinKit Snipaste PixPin 类ChatGpt kimi deepseek ChatGpt MiniCPM-V 多模态类ChatGpt工具，对标ChatGpt-V的功能，可以支持手机端部署 AI编程助手 CodeGeex(VSCode/IntelliJ IDE) 免费 Github Copilot(VSCode/IntelliJ IDE) 收费 marscode豆包AI编程助手，类似Copilot screenshot-to-code 截图到代码，主要针对HTML 前端开发利器—图片生成代码 翻译工具 PDFMathTranslate 科学 PDF 文档翻译及双语对照工具 沉浸式翻译也有类似效果，但是不够它好 Chrome扩展-沉浸式翻译 为网页提供双语翻译 可以用在Discord上，但需要点击扩展图标才能正常翻译，或者开启悬停长按识别 笔记应用 logseq 密码破解 ciphey docker run -it –rm remnux/ciphey ciphey -t “aGVsbG8gbXkgbmFtZSBpcyBiZWU=” 域名注册 namebeta namecheap 已购买 自建博客 hexo nodejs各种第三方npm包依赖太重了，而且版本间兼容性差，已经改到hugo了 hugo 由于互联网上的第三方文章链接可能会失效，如果遇到不错的文章，建议生成离线html文件保存到本地，本人在此采用 简悦 - SimpRead Chrome插件里的 【动作】-\u003e 【导出为 离线 HTML】功能来达成这一目的，它会将文章图片转换为base64编码，这样即使文章链接失效，各种图片也能正常显示 ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:1:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["开发技巧"],"content":"\r商业源码购买\u0026出售 sellmyapp ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:2:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["开发技巧"],"content":"\r教学讲解 算法演示 Hello 算法 算法运行演示 UML PlantUML drawio excalidraw asciiflow 思想卡片 napkin Napkin AI：这款免费AI工具，能把复杂的想法变成精彩的卡片，效率高到飞起！（Lisp提示词那样） 开源IM tinode ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:3:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["开发技巧"],"content":"\r游戏开发 Unity UE Godot 防破解 unity 游戏源码防破解 防作弊 pyod-异常行为检测库 对局内的玩家某段时间的操作行为记录，并使用该库进行分析，发现异常行为，进行封号、警告等处理 ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:4:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["开发技巧"],"content":"\rOCR识别 PaddleOCR-多国语言文本识别 CnOCR-中英文文本识别 surya-OCR、布局分析、读取顺序、表格识别 TexTeller-LaTeX识别 OcrMyPdf-给扫描PDF添加OCR文本层 ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:5:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["开发技巧"],"content":"\r分布式存储技术\u0026应用 ipfs-docs libp2p-webrtc 基于这套技术，我们可以在浏览器中构建一个P2P网络，实现文件的共享和传输或者游戏联网 御宅室 ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:6:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["开发技巧"],"content":"\r美术资产 AI出图 StableDiffusion Flux midjourny 可灵 人物表情迁移 HelloMeme：集成空间编织注意力，在扩散模型中嵌入高级别和保真度丰富的条件 https://songkey.github.io/hellomeme/ 可以将一些经典表情迁移到其它人物身上，并且不挑美术风格 人物训练 NovelAI-人物训练及炼丹embedding指南 图片格式转换 SVGcode：将位图转换成svg图片 图片转文本：将位图转换成文字艺术，类似Bug佛祖图片 开源-将位图转换为svg图像 Live2D live2d Live2Diff-通过单向视频扩散模型处理 Live2d 视频流的 Pipeline 头部说话演示 talking-head-anime-demo 如何使用Stable Difusion制作Live2D角色 抠图 BiRefNet-AI抠图 batchtool 效率不高，不建议使用 ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:7:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["开发技巧"],"content":"\r影视后期 剪辑类 LosslessCut 视频编码转换 小丸工具箱 Medlexo ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:8:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["开发技巧"],"content":"\r开发环境搭建\rGolang # windows # winget search golang winget install GoLang.Go Miniconda3 curl https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe -o miniconda.exe start /wait \"\" .\\miniconda.exe /S del miniconda.exe Miniconda Python conda create -n python_env python=3.9 conda activate python_env NoeJs conda create -c conda-forge --name nodejs_env nodejs conda activate nodejs_env ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:9:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["开发技巧"],"content":"\r日常工具安装\rwindows建议使用choco包管理进行安装即可，如果有其它偏好，下面有个对比图 choco config set installLocation D:\\ProgramData choco upgrade -y choco install powertoys choco install everythingpowertoys choco install 7zip.install alt+space=\u003e打开快捷搜索面板 win+ctrl+shitf+t =\u003e 窗口裁剪和锁定 win+ctrl+t =\u003e 让某个窗口置顶 遇到某个文件被占用，无法删除，可以使用【使用文件锁定程序解锁】菜单项 按住Shift键，拖动窗口，重新排版屏幕窗口布局 ctrl+space =\u003e 快速预览当前选中文件 选择多个文件【使用PowerRename重命名】 win+ctrl+` =\u003e 打开工作区 期望支持 支持设置窗口透明度 按住win+ctrl+滚轮时，可以往上或者往下设置窗口透明度 ","date":"2024-07-16","objectID":"/abouts/dev_tools_instruction/:10:0","tags":["工具"],"title":"常用工具整理","uri":"/abouts/dev_tools_instruction/"},{"categories":["原创工具"],"content":"本人之前比较常用Snipaste+剪贴板OCR方案，但是随着时间推移，发现这套方案过于繁琐，并且想要一个屏幕标注功能，苦于Snipaste没有插件系统，并且市面上的屏幕标注工具没有用着舒服的，遂有了这个小工具 ScreenPinKit\rhttps://github.com/YaoXuanZhi/ScreenPinKit\r","date":"2024-06-06","objectID":"/posts/screen_pin_kit/:0:0","tags":["原创工具","截图标注","屏幕绘图","屏幕标注"],"title":"自用工具-ScreenPinKit","uri":"/posts/screen_pin_kit/"},{"categories":["原创工具"],"content":"\r前言在多年工作中，逐渐将Snipaste+离线ocr整合到自己的工作流上了，一般使用场景如下： Snipaste的贴图功能使用场景(已满足) 讨论需求细节的时候，通常会提前将要讨论的要点截图并贴到屏幕上 Review代码、追踪Bug的时候 OCR识别功能(基本可用) 遇到防拷贝网页时 观看视频时 遇到PPT、Excel、PDF等文档时 得益于AI大爆发，目前一些常用IM应用(比如QQ、微信)上已内置了图片OCR功能，但一般办公电脑出于安全考虑从不登微信和QQ，为此捣鼓了一个离线OCR方案，它由CnOcr/PaddleOcr实现ocr识别，并结合AutoHotKey=\u003euTools提供的双击Alt触发剪贴板OCR识别 虽然自己搞的这个剪贴板OCR方案可用，但是个人其实更喜欢微信图片OCR这种选择文本的交互方式，它更加无感一些。后续发现PixPin复刻了这个功能，而且OCR速度相当快 屏幕标注(待满足)后面发现在做教学讲解的时候，一个屏幕标注功能也变得不可或缺了，经过一番调研，ppInk、gInk、shareX等的操作要不过于复杂，要不界面过于老旧，逐渐有了这个小工具的需求雏形 自用需求汇总整体的截图、贴图体验参考Snipaste的交互方式，绘图体验则借鉴excalidraw，在截图标注、屏幕标注的时候共用同一套绘画操作逻辑，截图OCR识别则参考微信OCR功能，它最好能跨平台，易于维护拓展 ","date":"2024-06-06","objectID":"/posts/screen_pin_kit/:0:1","tags":["原创工具","截图标注","屏幕绘图","屏幕标注"],"title":"自用工具-ScreenPinKit","uri":"/posts/screen_pin_kit/"},{"categories":["原创工具"],"content":"\r方案选型在将这些想法一一整理之后，在Flutter、Electron、Qt等技术上做了一次技术对比选型，但是一直不太满意 在我看来，易于拓展意味着开发环境尽可能简单，想做离线OCR识别离不开Python，所以迟迟没动手；直至看到了 PyQt-Fluent-Widgets 项目的演示，一下子被它所吸引了，之后陆陆续续基于PyQt5复刻了Snipaste上自己常用到的功能，并且结合excalidraw的操作方式封装了一套绘图层和相关示例 技术方案 UI风格 开发难度 拓展开发 是否支持开发热更新 是否已掌握 备注 Flutter 较为现代化 一般 麻烦 支持 仅了解 得掌握一门Dart语言，该语言比较小众，收益比太低，AndroidStudio内置了开发热更新支持，易于开发GUI，但是跨平台开发比较费功夫，配置开发环境复杂，不利于其它贡献者参与 Qt 相对硬核，但是结合QML机制，可以改得很好看 一般 麻烦 不支持 熟悉C++，但不熟悉Qt框架 需要学习Qt框架，并且有多个Qt版本，网上资料丰富，但是配置Qt开发环境复杂，由于采用C++开发，这会过滤掉很多贡献者 Electron 较为现代化 一般 一般 不支持 有所耳闻 该方案会内置一个Web内核，过于重了，而且应用分发体积比较大，TypeScript比较少用，收益比太低 PyQt-Fluent-Widgets(PyQt5) 较为现代化 一般 容易 支持，PyCharm安装Roadium插件即可 熟悉Python，但不熟悉Qt框架 它相当于一套FluentUI风格的PyQt5，而且Python易于学习上手，大多数开发者都掌握，另外以后若有商业化考虑可以无缝转译到Qt(C++)上 后续如果需要开发一些重Web端的移植项目，还可以采用pywebview方案；如果需要开发某些针对性需求，又不想暴露源码的情况下提供给别人试用，也可以使用PyQt快速开发一个原型，然后用nuitka转换成C源码再编译成exe分发，后续反馈不错再用c++完全重写也是一个快捷开发思路；要想开发跨平台的应用，只需要使用PyApp，就可以一键生成跨平台可执行文件，省时省力 ","date":"2024-06-06","objectID":"/posts/screen_pin_kit/:0:2","tags":["原创工具","截图标注","屏幕绘图","屏幕标注"],"title":"自用工具-ScreenPinKit","uri":"/posts/screen_pin_kit/"},{"categories":["原创工具"],"content":"\r安装演示 ","date":"2024-06-06","objectID":"/posts/screen_pin_kit/:0:3","tags":["原创工具","截图标注","屏幕绘图","屏幕标注"],"title":"自用工具-ScreenPinKit","uri":"/posts/screen_pin_kit/"},{"categories":["原创工具"],"content":"\r运行截图 ","date":"2024-06-06","objectID":"/posts/screen_pin_kit/:0:4","tags":["原创工具","截图标注","屏幕绘图","屏幕标注"],"title":"自用工具-ScreenPinKit","uri":"/posts/screen_pin_kit/"},{"categories":["原创工具"],"content":"\r后记在这个过程中，也留意到有个PixPin应用，该作者的开发动机同本人蛮接近的，如下图所示： 经过一番对比后发现，他想做的东西无疑更大更全，它的截图OCR速度非常快，并且还支持滚动截图等方式，可谓是Snipaste的加强版，作者目前更新比较活跃。而我只是想要个自用的称手工具而已，很多高级特性根本用不上，因此本练手项目就继续推进了，另外，也给PixPin提了个屏幕标注的需求，希望能采纳吧 Python版本升级太快了，目前社区很多库跟不上，现在这个小工具的兼容性一般，在Python 3.8和Python 3.9上可以完美运行，在更高级Python版本上，system_hotkey包、pillow等第三方包相继出现了问题，最终兼容性等我空闲之余再处理了 这个练手项目里，会逐步将一些精华部分整理成文档放在doc目录内，有兴趣的童鞋可以用logseq加载该目录浏览；当然Snipaste还是有不少拿手绝活的，有一些机制我也暂且复刻不出来，但是不影响我目前的使用，以后随缘复刻吧，研究这个也挺有意思的 ","date":"2024-06-06","objectID":"/posts/screen_pin_kit/:0:5","tags":["原创工具","截图标注","屏幕绘图","屏幕标注"],"title":"自用工具-ScreenPinKit","uri":"/posts/screen_pin_kit/"},{"categories":["原创工具"],"content":"\r吐槽本次练手项目是在一个陌生的技术栈上进行的，在这个过程中大量用到了类ChatGpt等AI工具辅助开发，经过对比，Kimi目前准确度是比ChatGpt3.5好上一些，这个小工具的一些源码和思路提取自网络，有一些是从c++转译成PyQt版本的，总体上来说，效率确实有所提升，并且免去了各种广告，但是它只能解决一些常规性的问题，其无中生有的本事不小，需要我们仔细甄别；对于一些稍微专业性的需求开发，只能靠自己去摸索，拆解同类软件的实现思路了，至于具体用到哪些API，API使用示例之类的，这块倒是相信AI 虽然瑕疵不少，但是类ChatGpt的出现，确实大大降低了我们跨技术栈开发的难度了，毕竟有个初中级的助手在旁辅助给思路还是挺爽的，对于单体的战斗力提升帮助还是巨大的，常规CURD的末路已经来临了，各种低代码平台解决的常规问题会逐步被它替换掉，而专业性强的应用护城河还是存在的，而且会一直存在~~ 经过这一番折腾，基本将PyQt需要踩的坑也过一遍了，逐渐熟悉了Qt框架；另外，随着对PyQt-Fluent-Widgets的熟悉，也逐渐发现了它的一些不足或者说Bug，后续给作者提个PR吧 ","date":"2024-06-06","objectID":"/posts/screen_pin_kit/:0:6","tags":["原创工具","截图标注","屏幕绘图","屏幕标注"],"title":"自用工具-ScreenPinKit","uri":"/posts/screen_pin_kit/"},{"categories":["原创工具"],"content":"\r参考资料 辅助教学与文件注解利器｜5个免费又好用的屏幕画笔软件 在触摸屏上轻松手写涂鸦与注记 Snipaste: Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上 excalidraw: Design guidelines and toolkits for creating native app experiences PyQt-Fluent-Widgets: A fluent design widgets library based on C++ Qt/PyQt/PySide. Make Qt Great Again. ShareX: Screen capture, file sharing and productivity tool ppInk: An easy to use on-screen annotation software inspired by Epic Pen. PixPin: 功能强大使用简单的截图/贴图工具，帮助你提高效率 ","date":"2024-06-06","objectID":"/posts/screen_pin_kit/:0:7","tags":["原创工具","截图标注","屏幕绘图","屏幕标注"],"title":"自用工具-ScreenPinKit","uri":"/posts/screen_pin_kit/"},{"categories":["Linux技术","开发技巧"],"content":"ubuntu镜像相对较大，并且UI风格相对老旧，后面遇到了Debian，看中它的全社区维护、永久开源的承诺和更现代的UI风格，因此入了坑，在此爬坑留痕 ","date":"2024-05-13","objectID":"/posts/debian_notes/:0:0","tags":["Linux","Debian","Docker","Yarn","NodeJs"],"title":"Debian的折腾笔记","uri":"/posts/debian_notes/"},{"categories":["Linux技术","开发技巧"],"content":"\r账户权限设置创建非root用户，并且设置ALL权限，否则不能使用sudo命令，想创建文件夹、安装docker等行为就无从谈起 su root sudo adduser brew sudo vim /etc/sudoers 添加上这行 brew ALL=(ALL:ALL) ALL ","date":"2024-05-13","objectID":"/posts/debian_notes/:1:0","tags":["Linux","Debian","Docker","Yarn","NodeJs"],"title":"Debian的折腾笔记","uri":"/posts/debian_notes/"},{"categories":["Linux技术","开发技巧"],"content":"\rdocker相关解决了国内docker被禁止之后，Linux下的docker安装部署问题，详情看这里：解决Docker国内网络问题 ","date":"2024-05-13","objectID":"/posts/debian_notes/:2:0","tags":["Linux","Debian","Docker","Yarn","NodeJs"],"title":"Debian的折腾笔记","uri":"/posts/debian_notes/"},{"categories":["Linux技术","开发技巧"],"content":"\r安装docker sudo curl -fsSL https://gitee.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun # 参考自：https://www.runoob.com/docker/docker-compose.html sudo curl -L \"https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose # 验证docker-compose命令是否安装成功 docker-compose version ","date":"2024-05-13","objectID":"/posts/debian_notes/:2:1","tags":["Linux","Debian","Docker","Yarn","NodeJs"],"title":"Debian的折腾笔记","uri":"/posts/debian_notes/"},{"categories":["Linux技术","开发技巧"],"content":"\r新增镜像站点 sudo vim /etc/docker/daemon.json 输入下列内容，最后按ESC，输入 :wq! 保存退出 { \"registry-mirrors\": [ \"https://docker.m.daocloud.io\", \"https://docker.1panel.live\", \"https://hub.rat.dev\" ] } 重启docker，让新增的镜像站点生效 sudo service docker restart ","date":"2024-05-13","objectID":"/posts/debian_notes/:2:2","tags":["Linux","Debian","Docker","Yarn","NodeJs"],"title":"Debian的折腾笔记","uri":"/posts/debian_notes/"},{"categories":["Linux技术","开发技巧"],"content":"\r镜像操作 # 查看已pull的镜像 sudo docker images # 移除镜像 sudo docker images remove mzz2017/v2raya # 将已经pull下来的镜像打包成tar sudo docker save -o v2raya.tar mzz2017/v2raya # 加载离线镜像 sudo docker load -i v2raya.tar ","date":"2024-05-13","objectID":"/posts/debian_notes/:2:3","tags":["Linux","Debian","Docker","Yarn","NodeJs"],"title":"Debian的折腾笔记","uri":"/posts/debian_notes/"},{"categories":["Linux技术","开发技巧"],"content":"\r容器实例操作 # 查看docker实例运行情况 sudo docker ps -a # 进入容器实例内部的bash sudo docker exec -it \u003ccontainer_id\u003e /bin/bash # 运行容器实例 sudo docker start \u003ccontainer_id\u003e # 停止容器实例 sudo docker stop \u003ccontainer_id\u003e # 移除容器实例 sudo docker remove \u003ccontainer_id\u003e ","date":"2024-05-13","objectID":"/posts/debian_notes/:2:4","tags":["Linux","Debian","Docker","Yarn","NodeJs"],"title":"Debian的折腾笔记","uri":"/posts/debian_notes/"},{"categories":["Linux技术","开发技巧"],"content":"\r安装npm和yarn sudo apt install npm # 如果apt/yum安装的node版本太低，可以用以下方式 ## 一键安装node脚本 # curl -sL https://deb.nodesource.com/setup_20.x ## 使用nvm来管理多个Node版本 # curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash # cd $HOME/.nvm # nvm ls-remote # nvm install 22 sudo npm install -g yarn --registry=https://registry.npmmirror.com ","date":"2024-05-13","objectID":"/posts/debian_notes/:3:0","tags":["Linux","Debian","Docker","Yarn","NodeJs"],"title":"Debian的折腾笔记","uri":"/posts/debian_notes/"},{"categories":["Linux技术","开发技巧"],"content":"\r禅道部署 # - [docker安装zentao](https://www.zentao.net/book/zentaopms/docker-1111.html) sudo mkdir ~/Software sudo mkdir ~/Software/zentao_data sudo docker run -d -v ~/Software/zentao_data:/data -p 90:80 -e MYSQL_INTERNAL=true hub.zentao.net/app/zentao:20.6 ","date":"2024-05-13","objectID":"/posts/debian_notes/:4:0","tags":["Linux","Debian","Docker","Yarn","NodeJs"],"title":"Debian的折腾笔记","uri":"/posts/debian_notes/"},{"categories":["Linux技术","开发技巧"],"content":"\r网络安全注意事项 MongoDB的默认策略导致的安全问题 ","date":"2024-05-13","objectID":"/posts/debian_notes/:5:0","tags":["Linux","Debian","Docker","Yarn","NodeJs"],"title":"Debian的折腾笔记","uri":"/posts/debian_notes/"},{"categories":["生活经验"],"content":"这两三年播客发展得如火如荼，本人也关注了好几个播客节目，由于在家里更希望通过音箱外放来收听播客频道，而手头的小米音箱本身不允许安装非官方App，因此有了这篇文章，希望能帮助到有同样需求的朋友 xiaomusic\rhttps://github.com/hanxi/xiaomusic\r","date":"2024-04-25","objectID":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/:0:0","tags":["xiaomimusic","博客","小宇宙","日常工具"],"title":"通过小米音箱来播放小宇宙播客(非手机蓝牙)","uri":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/"},{"categories":["生活经验"],"content":"\r前言随着播客频道的质量逐年走高，本人也关注了诸如出海去、忽左忽右等等播客节目，现在已经养成了在通勤、排队、编码的时候听播客的习惯，主要使用小宇宙App 一般而言，在外都是戴耳机来收听播客，免得影响其他人，而在家里，自然更想通过音响外放来收听啦，正好手头有个小米音箱，虽然通过手机蓝牙连到音箱的方式也可以播放播客，但是依然不甚方便，因为手机此时可能要玩游戏、刷视频等，并且如果有电话打过来，也会导致播客播放中断，因此，需要找到一种非手机蓝牙的方式来让小米音箱播放播客 暂时采用了xiaomusic+cosmos-enhanced来结合实现 ","date":"2024-04-25","objectID":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/:1:0","tags":["xiaomimusic","博客","小宇宙","日常工具"],"title":"通过小米音箱来播放小宇宙播客(非手机蓝牙)","uri":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/"},{"categories":["生活经验"],"content":"\r操作步骤","date":"2024-04-25","objectID":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/:2:0","tags":["xiaomimusic","博客","小宇宙","日常工具"],"title":"通过小米音箱来播放小宇宙播客(非手机蓝牙)","uri":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/"},{"categories":["生活经验"],"content":"\r1. 安装Chrome扩展-Cosmos-Enhanced在Chrome浏览器上安装 Chrome插件-cosmos-enhanced，此时小宇宙官网会新增一些下载菜单项，如下图所示： 在搜索引擎上搜索 【小宇宙 播客节目名】，定位到对应播客节目，然后下载相关音频资源到本地 ","date":"2024-04-25","objectID":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/:2:1","tags":["xiaomimusic","博客","小宇宙","日常工具"],"title":"通过小米音箱来播放小宇宙播客(非手机蓝牙)","uri":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/"},{"categories":["生活经验"],"content":"\r2. 安装xiaomusic由于xiaomimusic项目主页已经有详尽的使用说明和FAQ了，这里不再复述，详情请看 文档汇总 ","date":"2024-04-25","objectID":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/:2:2","tags":["xiaomimusic","博客","小宇宙","日常工具"],"title":"通过小米音箱来播放小宇宙播客(非手机蓝牙)","uri":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/"},{"categories":["生活经验"],"content":"\r3.将下载好的音频资源复制到对应的xiaomimusic搜刮目录下 ","date":"2024-04-25","objectID":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/:2:3","tags":["xiaomimusic","博客","小宇宙","日常工具"],"title":"通过小米音箱来播放小宇宙播客(非手机蓝牙)","uri":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/"},{"categories":["生活经验"],"content":"\r4. 最终效果 ","date":"2024-04-25","objectID":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/:2:4","tags":["xiaomimusic","博客","小宇宙","日常工具"],"title":"通过小米音箱来播放小宇宙播客(非手机蓝牙)","uri":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/"},{"categories":["生活经验"],"content":"\r参考资料 闲聊交流｜分享一个下载小宇宙节目音频的方法 ","date":"2024-04-25","objectID":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/:2:5","tags":["xiaomimusic","博客","小宇宙","日常工具"],"title":"通过小米音箱来播放小宇宙播客(非手机蓝牙)","uri":"/posts/play_xiaoyuzhou_audio_by_xiaomi_music_box/"},{"categories":["UE"],"content":"公司高层做了一个从头再来的决策，团队由Unity3D引擎切换到UE5，我和一些小伙伴被留下来配合新大佬做UE Demo，这里记录了一些踩坑经历 UnrealCircle《Lyra初学者游戏包工程解读》 | quabqi\rhttps://www.bilibili.com/video/BV1Ce4y1X7k5\r看到一些开源UE项目，想知道它某个UI归属于哪个蓝图，怎么做？使用Tools -\u003e Debug -\u003e Widget Reflector(控件反射器)工具，如下图所示： WidgetReflector官方介绍 Lyra上面的Esc键是如何进行响应的？先在cpp代码里定义这个Esc按键对应的Tag，并在这里面编写它的逻辑，如下图所示： 在CommonUI Input Settings上添加这个Tag对应的键盘配置，如下图所示： 在实际项目开发中，采用啥脚本语言？有啥优劣？这次主程决定引入了Unlua，这个由tx内部维护并开源，但是目前该插件已经是搁置维护的状态了，但是好在它基本够用，坑相对较少，但是它对GameplayMessageSubsystem的支持不好，下图是Unlua官方群上的说法 早前还讨论过要不引入AngelScript，但是最终选了Unlua，私下了解到AngelScript在【双人成行】项目里被成功应用，但是国内目前是没有团队做这个事情的，所以选它风险是比较大的，不过它有一个好处，该团队改造了GameplayMessageSubsystem源码，针对AngelScript做了适配。不过还存在一个问题，就是它访问蓝图的变量这块做的一般，而且反射这块做得糙了些，没有Unlua那边做得那么齐全，并且官方也没有一个相对完整的可借鉴的项目示例(类似LyraWithUnLua)用来搭建新项目的Gameplay业务框架，举个例子：Gameplay的逻辑散布在cpp、蓝图、angelscript等脚本里，得自己去推导这整块流程，而且还无法借鉴Unlua的流程，属实不太方便。如果对该脚本方案实在感兴趣的话，推荐加入QQ讨论群：993011485 参考资料 Lyra跨平台UI开发(官方字幕) Lyra中AbilitySystem的应用 | Epic 陈宝康 Lyra初学者游戏包概览(官方字幕) Lyra导览与问答(官方字幕) 分析Lyra中的动画(官方字幕) UE5虚幻引擎5Lyra框架解析与扩展 UE5 CommonUI 框架 (一) UE5 CommonUI 框架 (二) 【UE5】Lyra UI框架解析 虚幻5引擎上的脚本语言-AngelScript ","date":"2023-11-10","objectID":"/posts/question_and_answer_on_ue_lyra/:0:0","tags":["CommonUI","Lyra","UE"],"title":"关于UE Lyra的Q\u0026A","uri":"/posts/question_and_answer_on_ue_lyra/"},{"categories":["开源技术"],"content":"以前网络上收集到不少扫描版本的PDF文档，没有文字层，非常蛋疼，偶然发现了这个开源工具，非常推荐 OCRmyPDF\rhttps://github.com/ocrmypdf/OCRmyPDF\r","date":"2023-05-13","objectID":"/posts/ocrmypdf/:0:0","tags":["pdf","ocr识别应用","ocrmypdf"],"title":"给扫描PDF添加OCR文本层 - OcrMyPdf","uri":"/posts/ocrmypdf/"},{"categories":["开源技术"],"content":"\rWindows下安装\r安装Python依赖项 conda create -n pdf_env python=3.11 # 执行这一步，会将运行ocrmypdf的第三方包都一并安装好 pip install pip install ocrmypdf 安装OCR等依赖项 # 以管理员身份运行cmd，执行以下命令： @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\" \u0026\u0026 SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" # 或者以管理员身份运行PowerShell，执行以下命令： Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) choco install --pre tesseract choco install ghostscript choco install pngquant 由于默认安装tesseract只包含了English语言包，要想支持多种语言的话，从tessdata上下载其它语言包，解压里面的扩展名为traineddata的文件，复制到 C:\\Program Files\\Tesseract-OCR\\tessdata 上 ","date":"2023-05-13","objectID":"/posts/ocrmypdf/:0:1","tags":["pdf","ocr识别应用","ocrmypdf"],"title":"给扫描PDF添加OCR文本层 - OcrMyPdf","uri":"/posts/ocrmypdf/"},{"categories":["开源技术"],"content":"\r运行 ocrmypdf -l chi_sim --pdf-renderer tesseract --output-type pdf source.pdf ocr.pdf ","date":"2023-05-13","objectID":"/posts/ocrmypdf/:0:2","tags":["pdf","ocr识别应用","ocrmypdf"],"title":"给扫描PDF添加OCR文本层 - OcrMyPdf","uri":"/posts/ocrmypdf/"},{"categories":["开源技术"],"content":"\r源码调试由于官方忽略了.vscode等ide配置，所以我fork了仓库，并将vscode的调试配置放在learn分支下 git clone https://github.com/YaoXuanZhi/OCRmyPDF git checkout learn 用vscode打开仓库根目录，F5运行调试即可 ","date":"2023-05-13","objectID":"/posts/ocrmypdf/:0:3","tags":["pdf","ocr识别应用","ocrmypdf"],"title":"给扫描PDF添加OCR文本层 - OcrMyPdf","uri":"/posts/ocrmypdf/"},{"categories":["开源技术"],"content":"\rFAQ\r在Qt里如何加载Pdf？ # PyQt通过pdf.js来加载PDF文件，实现OCR文本选择层 # pip install PyQtWebEngine import sys from PyQt5 import QtCore, QtWidgets from PyQt5.QtWebEngineWidgets import QWebEngineView PDFJS = 'file:///D:/OpenSources/ScreenPinKit/src/third_party/pdfjs-4.6.82-dist/web/viewer.html' # PDF = 'file:///path/to/my/sample.pdf' PDF = 'file:///D:/OpenSources/ScreenPinKit/src/third_party/pdfjs-4.6.82-dist/web/compressed.tracemonkey-pldi-09.pdf' class Window(QWebEngineView): def __init__(self): super().__init__() self.load(QtCore.QUrl.fromUserInput('%s?file=%s' % (PDFJS, PDF))) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.setGeometry(600, 50, 800, 600) window.show() sys.exit(app.exec_()) ","date":"2023-05-13","objectID":"/posts/ocrmypdf/:0:4","tags":["pdf","ocr识别应用","ocrmypdf"],"title":"给扫描PDF添加OCR文本层 - OcrMyPdf","uri":"/posts/ocrmypdf/"},{"categories":["开源技术"],"content":"\r后记之所以想要源码调试它，是想从其之中汲取到添加OCR文本层的思路，后续会将这块的分析整理成博客分享 ","date":"2023-05-13","objectID":"/posts/ocrmypdf/:0:5","tags":["pdf","ocr识别应用","ocrmypdf"],"title":"给扫描PDF添加OCR文本层 - OcrMyPdf","uri":"/posts/ocrmypdf/"},{"categories":["开源技术"],"content":"\r参考资料 关于win10原生系统下 OCRmyPDF安装使用 三年磨一剑——微信OCR图片文字提取 PDF.js实现个性化PDF渲染（文本复制） PyQt 如何在PyQt中使用pdf.js查看器渲染PDF ","date":"2023-05-13","objectID":"/posts/ocrmypdf/:0:6","tags":["pdf","ocr识别应用","ocrmypdf"],"title":"给扫描PDF添加OCR文本层 - OcrMyPdf","uri":"/posts/ocrmypdf/"},{"categories":["开源技术"],"content":"发现了一个终端会话录制工具，非常不错，这里特意做下记录 asciinema\rhttps://github.com/asciinema/asciinema\r","date":"2023-05-13","objectID":"/posts/asciinema/:0:0","tags":["录制工具","PowerSession","asciinema"],"title":"终端会话录制工具-asciinema/PowerSession-rs","uri":"/posts/asciinema/"},{"categories":["开源技术"],"content":"\r使用场景 特别适用于各种服务器部署使用等指导场景 是演示各种cli工具使用的最佳方式，比起单纯的截图、视频录制更方便，它还能转换成svg动画，可以无损缩放，非常强大 ","date":"2023-05-13","objectID":"/posts/asciinema/:0:1","tags":["录制工具","PowerSession","asciinema"],"title":"终端会话录制工具-asciinema/PowerSession-rs","uri":"/posts/asciinema/"},{"categories":["开源技术"],"content":"\rLinux下安装看官方仓库ReadMe即可，这里不赘述 asciinema ","date":"2023-05-13","objectID":"/posts/asciinema/:0:2","tags":["录制工具","PowerSession","asciinema"],"title":"终端会话录制工具-asciinema/PowerSession-rs","uri":"/posts/asciinema/"},{"categories":["开源技术"],"content":"\rWindows下安装由于官方asciinema实际上是不支持windows系统的，Github Issues上已有相关讨论，感兴趣的可以移步到这： Please clarify whether asciinema is expected to work on Windows #47 Windows not supported, right? #47 有开发者采用Rust为其开发了一个Windows的兼容版本，该项目是PowerSession-rs，安装教程非常简单，这里做下简单记录 winget install Watfaq.PowerSession # 命令同asciinema完全一样，并且可以生成兼容的cast文件 PowerSession.exe -h # 开启一个新终端会话，并开始录制，将结果保存到example.cast上 PowerSession.exe rec example.cast # 回放example.cast上面的终端会话操作 PowerSession.exe play example.cast ","date":"2023-05-13","objectID":"/posts/asciinema/:0:3","tags":["录制工具","PowerSession","asciinema"],"title":"终端会话录制工具-asciinema/PowerSession-rs","uri":"/posts/asciinema/"},{"categories":["开源技术"],"content":"\r配套工具介绍\rsvg-term这个工具在OCRmyPDF上发现的，此项目将命令行操作过程录制下来，并将其转换成svg，放在ReadMe上，个人觉得效果非常惊艳，比转换成gif图片好多了，体积小，而且无损缩放 #创建NodeJs环境 conda create -c conda-forge --name nodejs_env nodejs conda activate nodejs_env # 安装 npm install -g svg-term-cli # 使用示例 svg-term --in=misc/screencast/demo.cast --out=misc/screencast/demo.svg --window ","date":"2023-05-13","objectID":"/posts/asciinema/:0:4","tags":["录制工具","PowerSession","asciinema"],"title":"终端会话录制工具-asciinema/PowerSession-rs","uri":"/posts/asciinema/"},{"categories":["开源技术"],"content":"\r演示效果 ","date":"2023-05-13","objectID":"/posts/asciinema/:0:5","tags":["录制工具","PowerSession","asciinema"],"title":"终端会话录制工具-asciinema/PowerSession-rs","uri":"/posts/asciinema/"},{"categories":["开源技术"],"content":"\r参考资料 asciinema PowerSession-rs ","date":"2023-05-13","objectID":"/posts/asciinema/:0:6","tags":["录制工具","PowerSession","asciinema"],"title":"终端会话录制工具-asciinema/PowerSession-rs","uri":"/posts/asciinema/"},{"categories":["开源技术","技术选型"],"content":"提取自ET 7.2，仅保留核心框架层，相关业务层基本都被剔除，便于用来理解学习 MiniEtLibDemos\rhttps://github.com/YaoXuanZhi/MiniEtLibDemos\r这个仓库是本人在项目接入ET框架后，出于推广学习需要搞的ET精简版，剔除了ET上的各种业务逻辑，仅仅保留了ET框架的核心ECS模块、事件模块、网络模块以及消息模块等，同AOGame思路差不多，只是个人偏好不一样，并在此基础上搞了WinForm GUI Demo和UnityDemo等，完整版可以在官网查看 ","date":"2023-05-11","objectID":"/posts/mini_et_lib_demos/:0:0","tags":["ET Framework","双端开发框架"],"title":"MiniEtLibDemos","uri":"/posts/mini_et_lib_demos/"},{"categories":["开源技术","技术选型"],"content":"\r目录结构 AppClientCLI：一个命令行客户端Demo AppClientGUI：一个WinForm客户端Demo AppModel：该程序集包含了各种与UI无关Component声明 AppModelView：包含了各种与UI相关Component声明 AppHotFix：该程序集存放了AppModel上的各种Component的方法 AppHotFixView：该程序集存放了AppModelView上的各种Component的方法，这里由于WinForm的限制，已被合并到AppClientGUI/ModelVeiw上了 AppServer：一个命令行服务端Demo CLI_Loader：用于加载CLI DLL的加载程序集 Config：放置配置表的地方，这里还集成了Luban工具 GUI_Loader：用于加载GUI DLL的加载程序集 MiniEtLib：剥离出来的ET核心，位置已经挪到了xxx\\UnityDemo\\Assets\\Scripts\\Core\\MiniEtLib SimpleBenchmarkDemo：ET官方示例里的基准示例 UnityDemo：一个UnityDemo ","date":"2023-05-11","objectID":"/posts/mini_et_lib_demos/:0:1","tags":["ET Framework","双端开发框架"],"title":"MiniEtLibDemos","uri":"/posts/mini_et_lib_demos/"},{"categories":["开源技术","技术选型"],"content":"\r碎碎念该框架在项目落地之后，其信息量没变，只是代码组织形式由原本的OOP转变成了ECS了，不过它带来了一个好处，巧妙的程序集拓扑设计让它前后端都可以开发热重载，并且大大节省了团队内部自己对双端框架的演进时间，只不过，ECS带来的心智负担着实不小，在推进过程受到的阻力也有一些，但是凭着对热重载机制的喜爱，最终还是与组内伙伴集思广益，基于现有业务开发和后续的开发量产管线考虑，捋顺了它的开发流程和配套工具链 本人之前用过Erlang，也尝鲜过Flutter，它们的热重载机制都比较完善，开发体验一级棒，一图胜千言 最后再逼逼一句，无论何种框架，总会遇到众口难调的情况，作为团队的一员，没上升到可以做技术决策的地位之前，在技术方案选型阶段，多参与讨论，在方案落地时，多参与建设，这样于己于团队都是有利的，多种不同思想碰撞能带来技术视野、架构能力上的长进 ","date":"2023-05-11","objectID":"/posts/mini_et_lib_demos/:1:0","tags":["ET Framework","双端开发框架"],"title":"MiniEtLibDemos","uri":"/posts/mini_et_lib_demos/"},{"categories":["开源技术","技术选型"],"content":"\r参考资料 ET 7.2 MiniET剥离自该版本 X-ET7 从这之中提取了Luban的整合代码 AOGame unity3d c#热重载-边运行边改代码 ","date":"2023-05-11","objectID":"/posts/mini_et_lib_demos/:2:0","tags":["ET Framework","双端开发框架"],"title":"MiniEtLibDemos","uri":"/posts/mini_et_lib_demos/"},{"categories":["生活经验"],"content":"在2023年，由于各种AI应用的大爆发，简体中文互联网的高质量内容被各种量产垃圾内容掩盖住了，再叠加上各大日常App的大数据推荐系统，我们生活在一个个信息茧房中，为了避免坐井观天，需要整合国内外的高质量信息源，因此有了这篇笔记 ","date":"2023-03-21","objectID":"/posts/global_network_build/:0:0","tags":["日常工具"],"title":"全球互联笔记","uri":"/posts/global_network_build/"},{"categories":["生活经验"],"content":"\rDiscord推荐使用英国手机号，偶尔也可以使用国内手机号 购买国外手机号的号码平台-freeNumbers 大多活跃中的开源项目都会开通配套的Discord，对某个开源项目比较感兴趣的话，可以加入项目Discord里蹲一手消息 ","date":"2023-03-21","objectID":"/posts/global_network_build/:0:1","tags":["日常工具"],"title":"全球互联笔记","uri":"/posts/global_network_build/"},{"categories":["生活经验"],"content":"\rWeb3版的“公众号”Mirrorhttps://mirror.xyz https://www.huxiu.com/article/590554.html mirror周报 https://mcdao.mirror.xyz/ 自建频道与Github活动绑定大部分开源项目团队自建的Discord都会接入一个Github Bot，将每次Github上的行为转发到Discord上，这里做下简单记录 在Discord上创建一个频道，并赋予频道管理员权限，并且在服务器设置上创建一个Webhook，如下图所示： 在Github Repo上设置该仓库的Webhook，如下图所示： 参考资料 How to Connect GitHub repo to Discord bot || Full Step By Step Process Explained ","date":"2023-03-21","objectID":"/posts/global_network_build/:0:2","tags":["日常工具"],"title":"全球互联笔记","uri":"/posts/global_network_build/"},{"categories":["生活经验"],"content":"\rTelegram这是一个匿名 IM工具，有一些比较硬核的技术在这里分享传播着 ","date":"2023-03-21","objectID":"/posts/global_network_build/:0:3","tags":["日常工具"],"title":"全球互联笔记","uri":"/posts/global_network_build/"},{"categories":["生活经验"],"content":"\rX(旧称Twitter)这是一个各大政要，名人都会在此开通账号发表意见的地方，国际资讯的一手来源地 ","date":"2023-03-21","objectID":"/posts/global_network_build/:0:4","tags":["日常工具"],"title":"全球互联笔记","uri":"/posts/global_network_build/"},{"categories":["生活经验"],"content":"\r自建透明代理\r购买国外VPS在上面部署一个SSR-Server，然后提供一个账号给自己的手机使用，并且在电脑和手机上安装v2ray应用，当然，这个vps上也可以部署一些其它服务，比如gogs、svn服务器啥的 在Vps部署SSR-Server # 建议在centos上安装 # 本人用这个，需要安装python2.x # 下载并运行ssh.sh脚本 wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh \u0026\u0026 chmod +x ssr.sh \u0026\u0026 bash ssr.sh # python2_installer.sh # sudo apt install python2 #这个在ubuntu24上无法正常安装了，建议使用py_env来编译安装 # 安装py_env git clone https://github.com/pyenv/pyenv.git ~/.pyenv echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.bashrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.bashrc echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init -)\"\\nfi' \u003e\u003e ~/.bashrc # exec \"$SHELL\" # 安装Python编译依赖 sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev # 安装Python版本 pyenv install 2.7.18 # 设置全局Python版本 # pyenv global 2.7.18 # 关联上/usr/bin/python路径 cp /root/.pyenv/shims/python /usr/bin/python 使用SSR-Clientssr客户端介绍 windows推荐 v2rayN android推荐 v2rayNG linux推荐：v2raya，它自带了一个web设置后台，使用它不需要再手动设置linux的浏览器代理，在http://xxx:2017上导入ssr信息，并且设置好透明代理就行了 v2raya installation 使用docker安装即可，由于国内已经ban掉了https://hub.docker.com/，目前虚拟机上要想正常安装使用docker，可以移步到这里看操作详情 🤞 sudo mkdir /etc/v2raya docker run -d \\ --restart=always \\ --privileged \\ --network=host \\ --name v2raya \\ -e V2RAYA_LOG_FILE=/tmp/v2raya.log \\ -e V2RAYA_V2RAY_BIN=/usr/local/bin/v2ray \\ -e V2RAYA_NFTABLES_SUPPORT=off \\ -e IPTABLES_MODE=legacy \\ -v /lib/modules:/lib/modules:ro \\ -v /etc/resolv.conf:/etc/resolv.conf \\ -v /etc/v2raya:/etc/v2raya \\ mzz2017/v2raya:latest # curl http://127.0.0.1:2017 # 查询当前公网ip # curl ifconfig.me 如果群晖上也想有一个全局梯子(比如想下载youtube上的视频)，建议通过ssh进入群晖内部，也通过上面命令行来启动v2raya docker 一般来说，这上面会增加不少延迟，并且比单独在justmysocks的速度会差上一些的，这个就看vps的服务器质量了， 可以通过一个测速工具来进行实际测试，或者跑一个国外的测速网站 ","date":"2023-03-21","objectID":"/posts/global_network_build/:0:5","tags":["日常工具"],"title":"全球互联笔记","uri":"/posts/global_network_build/"},{"categories":["开发技巧"],"content":"需要协助跟进一个真机上手游包特有的登录问题，初步定位到问题出在包体上，但该包在首次安装启动的时候，需要下载10G+的资源包，每次出包，资源包都会有变更，而公司的内网资源服务器空间有限，并且wifi信道存在多人相互抢占的情况，最终导致资源下载特别慢，为了排查这么个问题，需要等待1h+才能进游戏；如果让手机通过usb线使用pc电脑上网，这样就能规避上述问题了，最终借助了gnirehtet来达成目的 gnirehtet\rhttps://github.com/Genymobile/gnirehtet\r","date":"2023-03-13","objectID":"/posts/mobile_internet_sharing_via_usb_to_pc/:0:0","tags":["gnirehtet"],"title":"手机通过usb线使用pc电脑上网","uri":"/posts/mobile_internet_sharing_via_usb_to_pc/"},{"categories":["开发技巧"],"content":"\r使用步骤 手机端准备 在手机上进行以下步骤：【打开开发者选项】=\u003e【打开USB调试】=\u003e【打开USB安装】=\u003e【打开USB调试（安全设置）】，以下以小米手机为例截图说明： 电脑端准备 第一步：将 \\\\server1\\软件安装包\\自助出包相关\\gnirehtet-toolkit.zip 拷贝到本地并解压 第二步：准备好一条可以支持数据传输的usb数据线，并且将电脑与手机连接，并选择【文件传输模式】 第三步：运行gnirehtet-run.cmd命令即可，顺利的话，此时手机会收到推送过来的gnirehtet.apk让你提示安装，信任它并允许安装即可，该app安装上手机后，此时 ","date":"2023-03-13","objectID":"/posts/mobile_internet_sharing_via_usb_to_pc/:1:0","tags":["gnirehtet"],"title":"手机通过usb线使用pc电脑上网","uri":"/posts/mobile_internet_sharing_via_usb_to_pc/"},{"categories":["开发技巧"],"content":"\r参考资料： 教你如何将手机通过USB连接的方式 共享电脑高速稳定的网络 ","date":"2023-03-13","objectID":"/posts/mobile_internet_sharing_via_usb_to_pc/:2:0","tags":["gnirehtet"],"title":"手机通过usb线使用pc电脑上网","uri":"/posts/mobile_internet_sharing_via_usb_to_pc/"},{"categories":["生活技巧"],"content":"前段时间，剁手购买了群晖Nas，正在向仓鼠的路上狂奔，经过一番捣鼓后，Nas上已经囤了好几T的资源了，怎么便捷地访问这些资源呢？ rclone官网\rhttps://rclone.org\r","date":"2022-10-26","objectID":"/posts/via_rclone_map_nas_as_network_disk/:0:0","tags":["rclone","Nas","网络磁盘"],"title":"通过rclone将Nas映射为网络磁盘(非局域网)","uri":"/posts/via_rclone_map_nas_as_network_disk/"},{"categories":["生活技巧"],"content":"\r需求\u0026痛点本人并不想借助WinScp之类的第三方软件的GUI界面来访问Nas资源，如果能做到像本地磁盘那样的访问体验就好了。实际上如果访问设备在同一局域网内，是可以通过SMB协议来达到类似效果，但是当人在外面，这种方式就莫得了 ","date":"2022-10-26","objectID":"/posts/via_rclone_map_nas_as_network_disk/:1:0","tags":["rclone","Nas","网络磁盘"],"title":"通过rclone将Nas映射为网络磁盘(非局域网)","uri":"/posts/via_rclone_map_nas_as_network_disk/"},{"categories":["生活技巧"],"content":"\r方案选型经过一番检索，目前Nas的外部访问，提供了多种方式，如下： SMB协议：这个协议是局域网共享文件专用的，只能内网使用，外部设备可以通过VPN服务器跳入到家庭局域网内，进行访问，需要额外搭建一个VPN服务器，其实这种方式还是比较安全的，通过ssh流程，而不是http流量，一般家庭宽带不会被封，但是本人在部署LT2P/IPSE的时候遇到了其他棘手问题，尚未解决，暂且不表 WebDav协议：基于Http协议的，将其包装成本地磁盘访问方式，因此检索到采用WebDav的方式共享到网络上，然后，在WebDav考虑到想要让多台办公设备都可以像访问本地磁盘那样访问了，目前发现RaiDrive，可以做到类似网络磁盘映射的效果，不过广告有点多，而且对第三方网盘的支持得付费支持；还有一个就是rclone，这个就是本文的最终选型 其他的就不再罗列了，详情可看群晖Nas的网络协议支持列表 ","date":"2022-10-26","objectID":"/posts/via_rclone_map_nas_as_network_disk/:2:0","tags":["rclone","Nas","网络磁盘"],"title":"通过rclone将Nas映射为网络磁盘(非局域网)","uri":"/posts/via_rclone_map_nas_as_network_disk/"},{"categories":["生活技巧"],"content":"\r动手参考 rclone-webdav 的配置，结合网上相关文章，这边做下统一整理 rclone的配置项放在rclone.conf文件上，其路径在%APPDATA%/rclone/rclone.conf上 rclone的webui需要额外从github.com上下载到本地磁盘上，其路径在%LOCALAPPDATA%/rclone 进入Home/New Config上进行设置，选择WebDav，然后配置WebDav上的参数即可， 默认端口：http:5005、https:5006 url：http://myhome.yaoxuanzhi.xyz:5005 选择Owncloud 用户名：user_name 密码：passwrd breatoken: nas_config 测试是否配置成功：罗列根目录:rclone lsd nas: ./rclone.exe mount nas:/ M: --cache-dir D:Temp --vfs-cache-mode writes \u0026 ","date":"2022-10-26","objectID":"/posts/via_rclone_map_nas_as_network_disk/:3:0","tags":["rclone","Nas","网络磁盘"],"title":"通过rclone将Nas映射为网络磁盘(非局域网)","uri":"/posts/via_rclone_map_nas_as_network_disk/"},{"categories":["生活技巧"],"content":"\rPortable化处理在摸索的过程中，为了方便重装电脑等情况下也能够快速部署回来，做了一定的资源整合，核心思路是：基于Windows系统的系统环境变量在程序间的传递关系链，将rclone用到的一些系统路径整合到rclone的运行目录上 将 %USERPROFILE%、%APPDATA%、%LOCALAPPDATA% 都重定向到user目录里 由于rclone挂载到系统磁盘上，需要有一个临时目录，将它也放在user同级目录下了 详情如下所示： # set_rclone_env.bat @echo off set rclone_dir=rclone-v1.60.1-windows-amd64 set mine_root=%~dp0 set USERPROFILE=%mine_root%user set APPDATA=%USERPROFILE%\\AppData\\Roaming set LOCALAPPDATA=%USERPROFILE%\\AppData\\Local set rclone_path=%mine_root%%rclone_dir% set temp=%mine_root%temp set path=%rclone_path%;%path% 基于这个思路，你也可以使用rclone来直接挂载OneDrive等第三方网盘 附件：rclone_toolkit.zip ","date":"2022-10-26","objectID":"/posts/via_rclone_map_nas_as_network_disk/:3:1","tags":["rclone","Nas","网络磁盘"],"title":"通过rclone将Nas映射为网络磁盘(非局域网)","uri":"/posts/via_rclone_map_nas_as_network_disk/"},{"categories":["生活技巧"],"content":"\rFAQ\r为啥url填入了http://example.com依然无法正常访问，账号密码都是正确的？检查你的WebDav服务的端口和端口转发端口，如果不是80端口，则需要在host上追加port信息，比如如果WebDav服务采用的是默认端口–http协议默认访问端口是5005、https协议默认访问端口为5006，此时url应该填：http://example.com:5005、https://example.com:5006 如何指定WebDav根目录呢？rclone.exe mount conf_name(配置名):relative_path(根目录相对路径) ","date":"2022-10-26","objectID":"/posts/via_rclone_map_nas_as_network_disk/:4:0","tags":["rclone","Nas","网络磁盘"],"title":"通过rclone将Nas映射为网络磁盘(非局域网)","uri":"/posts/via_rclone_map_nas_as_network_disk/"},{"categories":["生活技巧"],"content":"\r参考资料 Windows平台下使用 Rclone 挂载 OneDrive 为本地硬盘 使用Rclone实现网盘挂载 【超详细】Windows利用rclone将GoogleDrive等网盘/云盘挂载到本地 ","date":"2022-10-26","objectID":"/posts/via_rclone_map_nas_as_network_disk/:5:0","tags":["rclone","Nas","网络磁盘"],"title":"通过rclone将Nas映射为网络磁盘(非局域网)","uri":"/posts/via_rclone_map_nas_as_network_disk/"},{"categories":["生活技巧"],"content":"\r后记本人在LT2P/IPSE碰了壁，但是后续还了解到存在其它虚拟组网技术，比如ZeroTier，SMB协议在这种虚拟局域网内也是可以使用的，如果双方设备可以成功进行P2P打通的话(最好双方设备有IPV6，这样P2P打通成功率极高)，基本可以打满家里宽带上行速度的上限，否则的话，得经过中转服务器做流量转发，这种体验就一般了 ","date":"2022-10-26","objectID":"/posts/via_rclone_map_nas_as_network_disk/:6:0","tags":["rclone","Nas","网络磁盘"],"title":"通过rclone将Nas映射为网络磁盘(非局域网)","uri":"/posts/via_rclone_map_nas_as_network_disk/"},{"categories":["IDE技巧","开发技巧"],"content":"由于本人在日常开发工作中会在多种开发环境上切换，用得较多的是vscode、ideac、rider、pycharm等IDE，因此有了统一多个ide快捷键习惯的需求，这里记录了一套个人自用的快捷键设置方案，采取了【IDE插件开发】+【IDE设置配置】组合的方式来达成目的 自用IDE快捷键设置地址\rhttps://github.com/YaoXuanZhi/ide_setting_sync\r","date":"2022-04-13","objectID":"/posts/cross-ide_keymapping_solution/:0:0","tags":["vscode","visual studio","idea","rider","JeBrains系列"],"title":"一套自用的跨IDE键盘映射方案","uri":"/posts/cross-ide_keymapping_solution/"},{"categories":["IDE技巧","开发技巧"],"content":"\r跨IDE快捷键配置","date":"2022-04-13","objectID":"/posts/cross-ide_keymapping_solution/:1:0","tags":["vscode","visual studio","idea","rider","JeBrains系列"],"title":"一套自用的跨IDE键盘映射方案","uri":"/posts/cross-ide_keymapping_solution/"},{"categories":["IDE技巧","开发技巧"],"content":"\rIDE快捷键速记 快捷键 描述 ctrl+/ 代码注释或取消 alt+i 悬浮显示当前符号的声明 ctrl+i 向前导航跳转 ctrl+o 向后导航跳转 shift+alt+r 重命名当前选中的符号 shift+alt+s 在当前 [项目工程/工作区] 做全局文本查找 shift+alt+f 在当前 [项目工程/工作区] 做全局文本查找 shift+ctrl+r 在当前 [项目工程/工作区] 做全局文本替换 alt+g 跳转到该 符号 的定义处或悬浮显示它的所有引用 alt+m 弹窗显示当前文档的所有符号 alt+f7 在独立窗口里显示当前选中符号的所有引用 shift+alt+g Goto Related shift+alt+o 在当前 [项目工程/工作区] 通过名字检索文件 shift+ctrl+~ 打开IDE的终端窗口 ctrl+k ctrl+f 将选中文本进行代码格式对齐 ctrl+k ctrl+k 在当前行插入或移除标签 shift+f11 在独立窗口上显示当前 [项目工程/工作区] 的所有标签 ctrl+k ctrl+n 切换到下一个标签 ctrl+k shift+n 切换到上一个标签 f9 添加断点 f5 启动调试 f10 step over，单步执行，遇到子函数时不会进入子函数内单步执行 f11 step into，单步执行，遇到子函数就进入并且继续单步执行 ","date":"2022-04-13","objectID":"/posts/cross-ide_keymapping_solution/:1:1","tags":["vscode","visual studio","idea","rider","JeBrains系列"],"title":"一套自用的跨IDE键盘映射方案","uri":"/posts/cross-ide_keymapping_solution/"},{"categories":["IDE技巧","开发技巧"],"content":"\rVim快捷键速记 Vim操作 作用 esc 切换到普通模式 j k h l 控制光标 上 下 左 右 移动 :w 保存编辑 :wq 保存编辑并退出 :number 跳转到某行 v 切换到选择模式，并选中当前字符，此时能通过jkhl进行文本选择 V 切换到选择模式，并选中当前行，此时能通过jkhl进行文本选择 i 在普通切换到输入模式，输入光标移动到当前字符左侧 a 在普通切换到输入模式，输入光标移动到当前字符右侧 I 切换到输入模式，光标移动到行的起始位置，如果是当前选择了多行，那么还会切换到多行编辑模式 A 切换到输入模式，光标移动到行的结尾位置，如果是当前选择了多行，那么还会切换到多行编辑模式 在普通模式下按o 在下面新起一行并切到插入模式 在普通模式下按O 在上面新起一行并切到插入模式 ctrl+f 切到下一页 ctrl+b 切到上一页 在选择模式下按u 让被选中的文本里的字母全部转换为小写 在选择模式下按U 让被选中的文本里的字母全部转换为大写 在普通模式下按gg 直接跳转到文件首行 在普通模式下按g 直接跳转到文件尾行 在普通模式下按u 撤销 ctrl+r 重做 在选择模式下按v 复制当前选中的文本内容 在普通模式下按p 在当前字符的右侧粘贴文本 在普通模式下按P 在当前字符的左侧粘贴文本 常用开发工具的最佳推荐和自构建的IDE配置环境 vscode rider、pycharm、idea等 plugins：vim、markdown、plantuml、drawio、bookmark等、package manager ","date":"2022-04-13","objectID":"/posts/cross-ide_keymapping_solution/:1:2","tags":["vscode","visual studio","idea","rider","JeBrains系列"],"title":"一套自用的跨IDE键盘映射方案","uri":"/posts/cross-ide_keymapping_solution/"},{"categories":["开源技术"],"content":"从识字以来，已经遭遇了不少烂尾或太监的网络小说，每次遇到，都有很强的动力去想将它续写或者改变它虎头蛇尾的后半段，但是本人的写作水平一般，短篇都未曾驾驭过，更不用说那种动辄几百万字的网络小说，一直没去做，当然也是没那个闲工夫啦。幸运的是，现在在OpenAI等科技巨头的带动下，涌现了很多AI工具，其中就包括一些AI写作应用，ChatGpt4 和通义千问等问答语言模型。这些工具为写作提供了强大的辅助支持。在下面，我将整理下AI_Writer 的开源 AI 写作工具的试用体验 AI-Writer仓库地址\rhttps://github.com/BlinkDL/AI-Writer\r环境部署基于anaconda3的集成环境 # 创建独立的python3运行环境 conda create -n ai_writer python=3.8 conda activate ai_writer # 安装相关依赖包 pip install torch==1.9.1 pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118 pip install numpy pip install onnxruntime 克隆仓库 git clone https://github.com/BlinkDL/AI-Writer ","date":"2022-01-05","objectID":"/posts/ai_writer/:0:0","tags":["自动写作","AI-Writer","AI写作"],"title":"AI写作尝鲜","uri":"/posts/ai_writer/"},{"categories":["开源技术"],"content":"\r模型部署 ","date":"2022-01-05","objectID":"/posts/ai_writer/:0:1","tags":["自动写作","AI-Writer","AI写作"],"title":"AI写作尝鲜","uri":"/posts/ai_writer/"},{"categories":["开源技术"],"content":"\r运行Demo修改run.py的默认配置，官方默认为gpu运行模式，其运行环境配置复杂，尝鲜还是采用cpu模式更简便 cd AI-Writer python run.py ","date":"2022-01-05","objectID":"/posts/ai_writer/:0:2","tags":["自动写作","AI-Writer","AI写作"],"title":"AI写作尝鲜","uri":"/posts/ai_writer/"},{"categories":["开源技术"],"content":"\r参考资料 开源：小说 AI 网文写作（支持N卡A卡I卡和CPU）有玄幻和言情模型 炼丹分享：AI 写网文小说的 GPT 模型（100M参数量），以及一种新采样方法 ","date":"2022-01-05","objectID":"/posts/ai_writer/:0:3","tags":["自动写作","AI-Writer","AI写作"],"title":"AI写作尝鲜","uri":"/posts/ai_writer/"},{"categories":["原创工具"],"content":"这是一个简单且易用的条件组分词器，提供了c#、c++、python等多种语言的实现和示例，如果你的项目需要支持复杂的条件组合和分层嵌套机制，那么它将非常适合你 简易的条件组分词器\rhttps://github.com/YaoXuanZhi/condition_group_tokenizer\r","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:0:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["原创工具"],"content":"\r前言为了说明这个工具库怎么用，这里以一个游戏项目为例，在这类项目中，条件配置通常会被高频修改，一个通用且可维护性强的条件支持机制在此显得尤为重要。 而在理想情况下，该模块的开发者只需在新增条件类型时才维护一次，至于怎么组合这个条件配置，全由策划折腾才对 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:1:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["原创工具"],"content":"\r需求分析假设该游戏项目采用csv文件作为游戏数值配置，现在策划童鞋设计了一个功能开启需求，并在需求文档里罗列了一些配置示例，如下所示： 系统功能名 开启条件 武器系统 玩家等级达到5级 坐骑系统 玩家等级达到15级 天赋系统 武器系统升到10级【且】开启了坐骑系统 聊天系统 玩家等级达到30级【且】充值过 公会系统 玩家等级达到100级【或】累计登录30天 收到这个需求之后，我们直接面临以下问题： 怎么设计配置表？ 多种条件组合配置得怎么设计，如何尽可能做到条件类型复用呢？ 如果后续策划需要修改具体的条件组合，怎么尽可能减少程序的维护工作量？ 总不能我在忙着其它开发任务，然后策划童鞋改个已有条件类型的配置还得找上我来配合着改代码吧 如果再发散下思维，成就模块、任务模块也会用到类似的东西，能不能将这套条件机制提供给其它系统模块复用呢？ 只需要维护一次条件类型变动就能为多个模块提供了机制支持，岂不省时省力 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:2:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["原创工具"],"content":"\r配置表设计将罗列的开启条件进行整理，如下所示： 配置格式设计如下：Type-Param1-Param2-Param3 Type(条件类型) Desc(描述) Template(模板) Example(示例) is_system_open 系统A是否开启 is_system_open-system_id 武器系统是否开启:is_system_open-weapon_sys system_level 系统A达到B等级 system_level-system_id-need_level 武器系统是否达到10级: system_level-weapon_sys-10 player_level 玩家达到A等级 player_level-need_level 玩家是否达到10级：player_level-10 acc_charge_total 累计充值总额达到A acc_charge_total-need_total 是否累计充值总额已达1000元：acc_charge_total-1000 acc_login_days 累计登录天数达到A acc_login_days-need_days 是否累计登录了30天：acc_login_days-30 上述已经将配置示例上的条件内容共性部分拆解成一个个条件类型了，那么怎么表述它们组合时的逻辑关系呢，在此，引入了另外两个特殊符号，如下所示： 符号 作用 \u0026\u0026 完成条件A和条件B的且运算 || 完成条件A和条件B的或运算 现在，我们终于可以配置复杂的条件内容了，如下所示： 描述：玩家等级达到30级【且】充值过 ==\u003e 配置项：player_level-30 \u0026\u0026 acc_charge_total-1 描述：玩家等级达到100级【或】累计登录30天 ==\u003e 配置项：player_level-100 || acc_login_days-30 最终的配置表格式如下： 系统功能名 注释 开启条件 武器系统 玩家等级达到5级 player_level-5 坐骑系统 玩家等级达到15级 player_level-15 天赋系统 武器系统升到10级【且】开启了坐骑系统 system_level-weapon_sys-10 \u0026\u0026 is_system_open-mount_sys 聊天系统 玩家等级达到30级【且】充值过 player_level-30 \u0026\u0026 acc_charge_total-1 公会系统 玩家等级达到100级【或】累计登录30天 player_level-100 || acc_login_days-30 老司机应该能很快意识到，上述的条件配置内容已经很像编程语言的条件表达式了，比如C++里面的if statement，与之相比我们还差了一个小括号()的功能和逻辑运算符:非的支持，不过非一般用不上，可以酌情考虑要不要搞，有了小括号()的支持后，我们还加上了条件嵌套机制，如下所示： 描述：(武器系统升至50级 【且】锻造系统升至30级) 或 玩家充值达到10000元 配置项：(system_level-weapon_sys-50 \u0026\u0026 system_level-mount_sys-30) || acc_charge_total-10000 给这类复杂条件起个名字，叫做条件组，因为每个小括号包裹住的条件配置都被视为一个条件组，如果条件配置没有小括号，可以视为其最外层有个隐藏的小括号，同策划童鞋沟通好，达成共识 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:2:1","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["原创工具"],"content":"\r程序设计既然配置表、配套测试配置都就位了，那接下来就是条件模块的功能设计啦，它需要将这些字符串解析成一个个条件类型，并且进行各种逻辑判断，返回最终判断结果 程序实现步骤拆解： 实现一个Tokenizer：解析这个配置项文本，依据其设计好的分割规则，拆分成一个Token数组，然后提取里面的条件块和逻辑运算符和层级关系，举个简单例子：将 system_level-weapon_sys-50 \u0026\u0026 system_level-mount_sys-30 解析成一个数组：system_level-weapon_sys-50、\u0026\u0026、system_level-mount_sys-30 将ConditionToken进行解析并返回结果：将上述例子里的 system_level-weapon_sys-50、system_level-mount_sys-30 进一步解析，并且调用各个系统的数据判断该条件的结果，将结果结合\u0026\u0026逻辑运算符得出最终结果，可以简化成 result1 \u0026\u0026 result2 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:3:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["原创工具"],"content":"\r功能实现参考condition_group_tokenizer 里的Demo示例，重载ProxyCondition()方法，直接进入到步骤2即可 这里贴了Python版的测试用例，其它语言依葫芦画瓢就行 # coding=utf-8 from condition_group_tokenizer import ConditionGroupTokenizer import unittest class PlayerFakeDataComponent: ''' 伪造玩家数据 ''' def __init__(self) -\u003e None: self.buildFakeDatas() def buildFakeDatas(self): ''' 测试用例可以重载该函数 ''' # 已开启的系统数据 self.systemDatas = { \"weapon_sys\" : {\"level\":39}, \"mount_sys\" : {\"level\":31}, } # 累计登录天数 self.accLoginDays = 3 # 累计充值金额 self.accChargeTotal = 3 # 玩家等级 self.level = 3 class PlayerConditionComponent(ConditionGroupTokenizer): \"\"\" 玩家条件组件 \"\"\" def __init__(self, playerDataComponent:PlayerFakeDataComponent) -\u003e None: super().__init__() self.playerDataComponent = playerDataComponent def proxyCondition(self, source:str, isPromt:bool) -\u003e bool: elements = source.split(\"-\") atomType = elements[0] params = elements[1:] result = self.checkConditionAtom(atomType, params) if isPromt: print(f\"判断：{atomType}:{params} 结果为：{result}\") return result def checkConditionAtom(self, atomType, params) -\u003e bool: \"\"\" 根据条件类型来逐个判断 \"\"\" if atomType == \"is_system_open\": systemId = params[0] return systemId in self.playerDataComponent.systemDatas elif atomType == \"system_level\": systemId = params[0] needSystemLevel = int(params[1]) if systemId in self.playerDataComponent.systemDatas: systemInfo = self.playerDataComponent.systemDatas[systemId] return systemInfo[\"level\"] \u003e= needSystemLevel return False elif atomType == \"player_level\": needPlayerLevel = int(params[0]) return self.playerDataComponent.level \u003e= needPlayerLevel elif atomType == \"acc_charge_total\": needAccTotal = int(params[0]) return self.playerDataComponent.accChargeTotal \u003e= needAccTotal elif atomType == \"acc_login_days\": needAccDays = int(params[0]) return self.playerDataComponent.accLoginDays \u003e= needAccDays else: assert False, f\"条件类型：{atomType} 还没支持，请完善相关条件判断逻辑\" return False class TestConditionGroupComponent(unittest.TestCase): def __init__(self, methodName: str = \"且运算逻辑\") -\u003e None: super().__init__(methodName) def test_and_operator_success(self): ''' 测试用例-\u0026\u0026运算符:成功 ''' class TestDataComponent(PlayerFakeDataComponent): def buildFakeDatas(self): # 已开启的系统数据 self.systemDatas = { \"weapon_sys\" : {\"level\":50}, \"mount_sys\" : {\"level\":60}, } # 累计登录天数 self.accLoginDays = 3 # 累计充值金额 self.accChargeTotal = 3 # 玩家等级 self.level = 3 source = \"system_level-weapon_sys-50 \u0026\u0026 system_level-mount_sys-30\" dataComponent = TestDataComponent() conditionComponent = PlayerConditionComponent(dataComponent) result = conditionComponent.directCheck(source, False) self.assertTrue(result, f\"判断：{source} 结果为：{result}\") def test_and_operator_fail(self): ''' 测试用例-\u0026\u0026运算符:失败 ''' class TestDataComponent(PlayerFakeDataComponent): def buildFakeDatas(self): ''' 伪造玩家数据 ''' # 已开启的系统数据 self.systemDatas = { \"weapon_sys\" : {\"level\":50}, \"mount_sys\" : {\"level\":29}, } # 累计登录天数 self.accLoginDays = 3 # 累计充值金额 self.accChargeTotal = 3 # 玩家等级 self.level = 3 source = \"system_level-weapon_sys-50 \u0026\u0026 system_level-mount_sys-30\" dataComponent = TestDataComponent() conditionComponent = PlayerConditionComponent(dataComponent) result = conditionComponent.directCheck(source, False) self.assertFalse(result, f\"判断：{source} 结果为：{result}\") def test_or_operator_success(self): ''' 测试用例-||运算符:成功 ''' class TestDataComponent(PlayerFakeDataComponent): def buildFakeDatas(self): ''' 伪造玩家数据 ''' # 已开启的系统数据 self.systemDatas = { \"weapon_sys\" : {\"level\":50}, \"mount_sys\" : {\"level\":29}, } # 累计登录天数 self.accLoginDays = 12 # 累计充值金额 self.accChargeTotal = 3 # 玩家等级 self.level = 3 source = \"is_system_open-pet_system || (acc_charge_total-100 || acc_login_days-10) || player_level-5\" dataComponent = TestDataComponent() conditionComponent = PlayerConditionComponent(dataComponent) result = conditionComponent.directCheck(source, False) self.assertTrue(result, f\"判断：{source} 结果为：{result}\") def test_or_operator_fail(self): ''' 测试用例-||运算符:失败 ''' class TestDataComponent(PlayerFakeDataComponent): def buildFakeDatas(self): ''' 伪造玩家数据 ''' # 已开启的系统数据 self.systemDatas","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:3:1","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["原创工具"],"content":"\r结尾在游戏项目里，我们仅需实现一次通用条件组件模块，然后在奖励发放、任务触发\u0026完成、成就事件达成等业务模块上，都调用这个通用组件来返回条件判断结果，就能大大减少重复配置设计了 当然，在集成到项目的过程中，还得完善配置格式合法化检测、条件判断套娃检测等机制，这里就不展开了 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:4:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["原创工具"],"content":"\r后记 为UE定制一个条件组插件，时间充足的话，还可以支持上DataTable ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:5:0","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["原创工具"],"content":"\r参考资料 游戏内条件集合(与或非组合)的判定处理 C#版 ","date":"2021-08-25","objectID":"/posts/simple_condition_group_tokenizer/:5:1","tags":["条件组判断","条件判断","逻辑符运算"],"title":"简易的条件组分词器","uri":"/posts/simple_condition_group_tokenizer/"},{"categories":["原创工具"],"content":"由于新工作的服务器开发环境相对麻烦，遂编写了一个集成脚本来简化了服务器环境部署和运行流程 ","date":"2021-06-12","objectID":"/posts/improve_msys2/:0:0","tags":["原创工具","msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["原创工具"],"content":"\r前言新项目的服务器框架基于skynet，后续考虑到Windows开发下的便捷性，支持了skynet for windows，基于msys2+gcc来编译并运行，因此，日常开发工作中，需要经常打开msys2终端来输入各种shell指令，但这并不方便 另外，本人更加偏好有个集成好的bat脚本，在上面输入1 2 3等数字之后，就能执行相应的构建 启动 测试等命令，最终调用msys2上的类linux环境来执行透传过来的命令，而且这种脚本也可以同配套环境打包给策划、测试童鞋，让他们快捷自建服务器完成功能验收和测试 ","date":"2021-06-12","objectID":"/posts/improve_msys2/:1:0","tags":["原创工具","msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["原创工具"],"content":"\r为msys2的追加镜像源基于 《MSYS2 镜像使用帮助》提供的实现思路，最初使用Python来快速实现了一个脚本 append_extra_mirror_source.py\r# !/user/bin/env python # -*- coding:utf-8 -*- import os, glob, codecs, re, argparse def add_mirror_url(mirror_url): mirror_paths = glob.glob(\"mirrorlist*\") re_pattern = r'(Server = )(https.*.org)(.*)' for path in mirror_paths: with codecs.open(path, mode=\"r\", encoding=\"utf-8\", errors='ignore') as f: config = f.read() f.close() search_re = re.search(re_pattern, config, re.M|re.I) exist_same_re = re.search(mirror_url, config, re.M|re.I) if not exist_same_re and search_re: mirror_url_item = search_re.group() temp = re.compile(re_pattern) mirror_url_item = temp.sub(r'\\1%(mirror_url)s\\3' % {'mirror_url': mirror_url}, mirror_url_item) new_config = '%(mirror_url)s\\n%(source)s' % {'mirror_url': mirror_url_item, 'source': config} outfile = codecs.open(path, 'w', 'utf-8') outfile.write(new_config) outfile.close() if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument(\"-url\", \"--mirror_url\", help=\"输入其他镜像源\", default=\"https://mirrors.cloud.tencent.com/msys2\") parser.add_argument(\"-msys2\", \"--msys2_dir\", help=\"msys2安装目录\", default=\"C:/msys64\") args = parser.parse_args() pacman_mirror_dir = \"%s/etc/pacman.d\" % (args.msys2_dir) os.chdir(pacman_mirror_dir) add_mirror_url(args.mirror_url) 但考虑到后续会推广给不会撸码的童鞋使用这个集成脚本，而这些童鞋大部分都是首次安装msys2的，因此，基于Python实现的脚本显然是不行的，又重新实现了一个bash脚本 由于bash脚本本身对文件、字符串等操作的支持极其有限，在此使用了msys2内置的sed、cp、cat、grep等工具来实现 在编写这个bash脚本的时候，遇到了一些知识盲区，特意记录下来： ✔ grep正则查找 ✔ sed正则替换需要对双引号、小括号等特殊字符进行前置转义 ✔ 在shell函数内修改传参变量的内容 ✔ 在文件首行插入新内容 append_extra_mirror_source.sh\r#!/bin/bash # sed 需要对斜杆和括号等字符进行转义后才能正常正则替换 replace_escape_string(){ eval $2=\\\"$(eval echo \"\\${$1}\" | sed \"s/\\//\\\\\\\\\\//g; s/(/\\\\\\\\(/g; s/)/\\\\\\\\)/g\")\\\" } # 在文件头上加入其它镜像源 push_front_mirror_url(){ _source_config_file=$1 _backup_config_file=$(dirname $1)/bak_$(basename $1) _old_mirror_pattern=$2 _new_mirror_host=$3 # 备份原本的镜像源配置 if [ ! -f ${_backup_config_file} ]; then cp $_source_config_file ${_backup_config_file} fi # 找到镜像源配置模板 mirror_temp_url=$(grep -r -P \"$_old_mirror_pattern\" ${_backup_config_file}) replace_escape_string _old_mirror_pattern _old_mirror_pattern replace_escape_string _new_mirror_host _new_mirror_host # 根据模板镜像源修改成新的镜像源 new_mirror_url=$(echo $mirror_temp_url | sed \"s/$_old_mirror_pattern/\\\\1$_new_mirror_host\\\\3/g\") # 在文件头上插入新的镜像源链接 (echo $new_mirror_url \u0026\u0026 cat ${_backup_config_file}) \u003e $_source_config_file } main(){ # 腾讯云镜像源 # new_mirror_host=\"https://mirrors.cloud.tencent.com/msys2\" # 清华镜像源 new_mirror_host=\"https://mirrors.tuna.tsinghua.edu.cn/msys2\" old_mirror_pattern=\"(Server.*)(http.*repo.msys2.org)(.*)\" if [ ${#} == 1 ]; then new_mirror_host=$1 fi # 遍历pacman的镜像源配置 for file in /etc/pacman.d/mirror*; do push_front_mirror_url $file $old_mirror_pattern $new_mirror_host done } main $1 ","date":"2021-06-12","objectID":"/posts/improve_msys2/:2:0","tags":["原创工具","msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["原创工具"],"content":"\r拓展msys2","date":"2021-06-12","objectID":"/posts/improve_msys2/:3:0","tags":["原创工具","msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["原创工具"],"content":"\r让msys2支持在dos上直接执行shell指令在着手实现过程中，以下这些点是挺有意思的： ✔ 在dos中调用msys2来直接执行shell指令 详情看msys2_shell.cmd里面的!SHELL_ARGS!参数，其实它实现了：一个外部参数若果并不是msys2_shell.cmd的内置参数的话，其将会原样传递到终端上，结合bash -c cmd即可实现外部调用 ✔ 如何指定msys2的启动目录 详情看msys2_shell.cmd的参数列表：-where dir ✔ 在msys2里，将父bash的alias传递给子bash，并且执行其它指令 bash --noprofile --rcfile \u003c(alias) ","date":"2021-06-12","objectID":"/posts/improve_msys2/:3:1","tags":["原创工具","msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["原创工具"],"content":"\r将msys2添加到右键菜单上 ✔ 在目录下或者文件夹上执行该菜单命令时，启动msys2并定位到该目录下 ✔ 在某个文件上执行该菜单命令时，启动msys2，定位到该文件所在目录，并用Vim打开该文件 msys2_vim_installer.bat\r@echo off ::判断是否已经获取了管理员身份 Md \"%WinDir%\\System32\\test_permissions\" 2\u003eNUL||(Echo 请使用右键管理员身份运行\u0026\u0026Pause \u003eNUL\u0026\u0026Exit) Rd \"%WinDir%\\System32\\test_permissions\" 2\u003eNUL SetLocal EnableDelayedExpansion call %~dp0create_depends_env.bat ::设置右键菜单项的名称 set desc=\"Msys2-Vim\" ::设置搭建编译环境的BAT set runbat=\"run_msys2_vim.bat\" ::设置子路径名称 set subname=\"msys2_vim\" ::去掉双引号，主要是为了兼容包含了空格的文件名或路径 call :removequotes runbat call :removequotes subname ::添加注册表信息 reg add \"HKEY_CLASSES_ROOT\\Directory\\background\\shell\\%subname%\" /v \"\" /t REG_SZ /d %desc% reg add \"HKEY_CLASSES_ROOT\\Directory\\background\\shell\\%subname%\\command\" /v \"\" /t REG_EXPAND_SZ /d \"\\\"%~dp0%runbat%\\\" \\\"%%V\\\" reg add \"HKEY_CURRENT_USER\\Software\\Classes\\*\\shell\\%subname%\" /v \"\" /t REG_SZ /d %desc% reg add \"HKEY_CURRENT_USER\\Software\\Classes\\*\\shell\\%subname%\\command\" /v \"\" /t REG_EXPAND_SZ /d \"\\\"%~dp0%runbat%\\\" \\\"%%V\\\" reg add \"HKEY_CLASSES_ROOT\\Directory\\shell\\%subname%\" /v \"\" /t REG_SZ /d %desc% reg add \"HKEY_CLASSES_ROOT\\Directory\\shell\\%subname%\\command\" /v \"\" /t REG_EXPAND_SZ /d \"\\\"%~dp0%runbat%\\\" \\\"%%V\\\" :removequotes FOR /F \"delims=\" %%A IN ('echo %%%1%%') DO set %1=%%~A GOTO :eof run_msys2_vim.bat\r@echo off call %~dp0config.bat set ROOT=%1 call :removequotes ROOT pushd \"%ROOT%\" 2\u003enul \u0026\u0026 (call :folder \"%ROOT%\" \u0026 popd) || call :file \"%ROOT%\" GOTO :eof :file call :filename ROOT file_name call :dirname ROOT dir_name set command_args=%msys2_type% -where \"%dir_name%\" call %msys2_shell_bat% %command_args% -outside_exec \"vim '%file_name%'\" GOTO :eof :folder set command_args=%msys2_type% -where \"%ROOT%\" call %msys2_shell_bat% %command_args% GOTO :eof :removequotes FOR /F \"delims=\" %%A IN ('echo %%%1%%') DO set %1=%%~A GOTO :eof :dirname FOR /F \"delims=\" %%A IN ('echo %%%1%%') DO set %2=%%~dpA GOTO :eof :filename FOR /F \"delims=\" %%A IN ('echo %%%1%%') DO set %2=%%~nxA GOTO :eof 提供一个脚本来关联msys2和当前脚本的关系 create_depends_env.bat\r@echo off REM 创建目录关联 echo 将msys2目录粘贴到这里 set /p msys2_dir= call :removequotes msys2_dir @REM 自动生成config.bat set config_path=\"%~dp0config.bat\" if not exist %config_path% ( echo @echo off\u003e\u003e %config_path% echo set msys2_install_dir=\"%msys2_dir%\"\u003e\u003e %config_path% echo set msys2_shell_bat=\"%msys2_dir%\\msys2_shell.cmd\"\u003e\u003e %config_path% echo set msys2_type=-mingw64\u003e\u003e %config_path% echo set pause_cmd=read -p 'Please press any key after'\u003e\u003e %config_path% ) GOTO :eof :removequotes FOR /F \"delims=\" %%A IN ('echo %%%1%%') DO set %1=%%~A GOTO :eof GOTO :eof 最终成品：msys2_vim ","date":"2021-06-12","objectID":"/posts/improve_msys2/:3:2","tags":["原创工具","msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["原创工具"],"content":"\r参考资料 MSYS2 镜像使用帮助 forward aliases to child process invoking-msys-bash-from-windows-cmd executing-msys-from-cmd-exe-with-arguments how-do-i-integrate-msys2-shell-into-visual-studio-code-on-window ","date":"2021-06-12","objectID":"/posts/improve_msys2/:4:0","tags":["原创工具","msys2","vim"],"title":"拓展Msys2","uri":"/posts/improve_msys2/"},{"categories":["原创工具"],"content":" 本人在收集一些文章正文的时候，中途被一些采用图文混合形式加密保护的网页卡着了，这篇文章记录下了我针对该类网页的处理方式 ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:0","tags":["原创工具","图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["原创工具"],"content":"\r前言由于自己的某些学习需求，不想一直联网浏览某些网页内容，因此想将这些站点的某些内容缓存到本地。另外，该网站为了防止内容被爬虫抓取或被盗稿，因此在页面渲染时对内容进行了一些加密处理：将纯文本内容拆分成图文混合形式渲染，格式如下所示： \u003cp\u003e生活就像海洋，只有意\u003cimg src=\"/image/data/3452027561.png\" /\u003e坚强的人，才 \u003cimg src=\"/image/data/0001716716.png\" /\u003e\u003cimg src=\"/image/data/4356266290.png\" /\u003e达彼岸。 ——马克思 \u003c/p\u003e 分析了一下这个html源码，摸索出了它的加密规律：每个页面的字符图片都是随机的，也就是说，无法写一套[图片名 =\u003e 字符]的模板来批量替换，需要频繁对字符图片来进行OCR识别 但目前的免费OCR服务，都有体验次数限制，毕竟识别精度一般较高，而且维护这套识别服务也是挺费钱的。而按照本人的估计，假设要全部缓存这个站点的内容，采用在线OCR服务来识别这些字符图片肯定要凉，当天免费次数铁定不够；那么，相对靠谱的方案就是自建OCR服务或者搞个Native OCR工具来做OCR识别了，这些方案没有商用服务的体验限制 ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:1","tags":["原创工具","图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["原创工具"],"content":"\rOCR开源技术调研思路确定了，但是面临了一个新问题，本人并没有OCR相关的开发经验，只能采用开源OCR项目来达成自己的目的，在网上检索一轮之后，找到了这些方案： pandaocr 在线ocr服务的聚合工具，实际上还是有体验次数限制 chineseocr-lite 识别准度可靠，需要自行编译，windows下部署环境相对复杂，费时间，服务方式调用 tesseract 这个开源方案虽然是最有历史的，部署简单，但是官方提供的模型数据给出的识别效果最差，耗时最多，要想获得较高的识别精度，需要自己花费非常多精力去调教，或者尝试其它训练模型，是故不推荐 paddleocr 它是百度开源ocr项目，基于paddle深度学习框架实现的，部署难度一般，国内资料非常丰富，并且整个项目非常庞大，使用官方提供的模型数据即可有较高识别精度，但是耗时一般，对于复杂的文字排版的识别结果可用。如果有识别各种广告营销图的OCR需求，那么它将是目前较好的开源方案 cnocr 它是起源于爱因互动 Ein+ 内部的项目需求，后续开源出来，其部署简单，使用官方提供的模型数据即可有较高识别精度，并且耗时最少，对于复杂的文字排版的识别结果准度一般。如果只是单纯的文字图片识别，比如微信聊天截图啥的，那么它的识别准度和识别速度都是较好的，但是不建议使用它来识别广告营销图 本人在Windows系统下分别跑通了tesseract、cnocr、paddleocr这些开源项目，以下是本次技术调研的总结： OCR方案 部署难度 文字图片识别精度 复杂文字排版识别精度 识别速度 tesseract 简单 较差 不可用 慢 cnocr 简单 准确 勉强能用 快 paddleocr 复杂 准确 可用 一般 经过调研对比，最终采取cnocr作为字符图片的ocr方案 其实在windows下，Tim的Ctrl+Alt+O快捷键呼出来的[相框识别文字]的识别精度更高 ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:2","tags":["原创工具","图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["原创工具"],"content":"\r设计识别流程在调研过程中，发现每次ocr识别耗时是秒级的，并且字符图片的识别准度不如合并后的图片识别准度，为了提升最终的ocr识别准度以及减少耗时，需要先合并多个字符图片，再进行ocr识别，流程图如下所示： ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:3","tags":["原创工具","图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["原创工具"],"content":"\r开发思路确定具体的OCR方案后，梳理此工具的实现思路，大致步骤如下： 使用wget来爬取这个网站的资源 wget -c -r -np -k -p -nc \"http://www.xxx.com/xxx/\" \u003eWindows下，建议使用msys2来执行 识别该站点里的字符图片文件夹，将ocr识别结果按照[字符图片=\u003e字符]的映射关系导出为json文件 读取json文件里面的字符图片映射数据，将html里面的字符图片标签替换成正常的字符 继续执行正常的网络爬虫 ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:4","tags":["原创工具","图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["原创工具"],"content":"\r成品 功能特性 添加帮助文档 支持合成单行文字图片 支持合成多行文字图片 支持可选调试信息输出 支持可选保存合并后的图片 支持cnocr识别，并将映射结果导出到json 支持外部OCR结果校正 直接替换html里的字符图片标签 增加Windows右键菜单集成支持 附件：char_images_ocr_tool.zip ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:5","tags":["原创工具","图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["原创工具"],"content":"\r参考资料 字符图片合并 初探cnocr ","date":"2021-04-25","objectID":"/posts/char_images_ocr_tool/:0:6","tags":["原创工具","图片合并","ocr识别","字符图片识别"],"title":"字符图片OCR工具","uri":"/posts/char_images_ocr_tool/"},{"categories":["开源技术"],"content":"在知乎上看到一篇不错的文章 更轻量的中文OCR—— cnocr-V1.2.2 ：最小模型只有 4.7M，作者分享了一个体积小、横版中文识别速度快且准度高、部署简单且易用的中英文OCR Python库，因此试用下，结果发现还挺不错的，在它之上还搞了个自用的OCR工具 cnocr仓库地址\rhttps://github.com/breezedeus/cnocr\r","date":"2021-04-08","objectID":"/posts/cnocr/:0:0","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r在线安装 virtualenv/anaconda3 win32OpenSSL conda create -n cnocr python=3.7 conda activate cnocr pip install cnocr pip install cnstd 注意，执行pip install cnstd之后，shapely的在线安装是有问题的，需要下载离线的shapely_xxx.whl文件(如Shapely-1.7.1-cp37-cp37m-win_amd64.whl)进行离线安装，如下所示： pip uninstall Shapely pip install your_path/Shapely-1.7.1-cp37-cp37m-win_amd64.whl ","date":"2021-04-08","objectID":"/posts/cnocr/:0:1","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r源码安装 cd cnstd/ pip install -r requestment.txt python setup.py build python setup.py install ","date":"2021-04-08","objectID":"/posts/cnocr/:0:2","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r离线包部署如果不想折腾这个cnocr的环境配置，这里提供了一个本人整合的离线工具包，只需要在一个不包含中文或空格的路径上解压，直接以管理员身份执行ocr_deploy.bat即可 下载链接：cnocr离线工具包-cnocr_toolkit.zip，提取码：y80u 该离线包仅仅支持x64bit Windows系统 ","date":"2021-04-08","objectID":"/posts/cnocr/:0:3","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r代码片段\r纯文本识别 # 识别纯文字图片 def ocr_single_png_from_cache(image): nd_array = np.asarray(image.convert('RGB')) res = cn_ocr.ocr(nd_array) res = [''.join(line_p) for line_p in res] temp_res = '\\n'.join(res) return temp_res # 识别纯文字图片 def ocr_single_png_from_cache_bak(image): img_bytes = BytesIO() image.save(img_bytes, format='PNG') nd_array = mx.image.imdecode(img_bytes.getvalue()) res = cn_ocr.ocr(nd_array) res = [''.join(line_p) for line_p in res] temp_res = '\\n'.join(res) return temp_res 外部调用cnocr # 读取shell命令输出结果 def popen_wrapper(cmd_line): p = subprocess.Popen(cmd_line, shell=True, stdout=subprocess.PIPE) lines = p.stdout.readlines()[1:] temp_str = \"\" for str in lines: utf8_str = str.decode(\"utf8\") temp_str = temp_str + utf8_str return temp_str # 尝试进行OCR识别 def try_ocr_image(image_path): cmd_line = \"xxx/try_ocr_image.bat %s\" % (image_path) ocr_str = popen_wrapper(cmd_line).strip() return ocr_str 剪贴板OCR # -*- coding: utf-8 -*- import win32.win32clipboard as win32clipboard from PIL import Image, ImageDraw, ImageGrab import os # 读取PIL image进行OCR识别 def ocr_image_from_pil(image): from cnocr import CnOcr import numpy as np cn_ocr = CnOcr() nd_array = np.asarray(image.convert('RGB')) res_lines = cn_ocr.ocr(nd_array) res = [''.join(line_p) for line_p in res_lines] temp_res = '\\n'.join(res) return temp_res # 读取剪贴板上的图像数据进行OCR识别 def try_ocr_clipboard(): ocr_result = \"\" im = ImageGrab.grabclipboard() if not im == None: return ocr_image_from_pil(im) return ocr_result def set_text_to_clipboard(text): text_bytes = bytes(text, encoding=\"utf8\") win32clipboard.OpenClipboard() win32clipboard.SetClipboardText(text) win32clipboard.CloseClipboard() def ocr_clipboard(): ocr_result = try_ocr_clipboard() if (len(ocr_result) \u003e 0): set_text_to_clipboard(ocr_result) print(\"剪贴板OCR结果：\\n%s\" % (ocr_result)) os.system(\"pause\") ocr_clipboard() 剪贴板OCR工具-ocr_clipboard.zip 注意，Tim上有一个屏幕OCR功能，只需要Ctrl+Alt+O即可唤出，识别准度更高 训练新字体\r生成新字体的训练集先通过以下脚本来快速生成字体的训练集 pre_train_for_font.py\r# !/user/bin/env python # -*- coding:utf-8 -*- import os import argparse from PIL import Image,ImageFont,ImageDraw # 根据文本生成图片 def save_chars_image(text, image_path, font, is_debug = False): chars_x, chars_y = 0, 0 chars_w, chars_h = font.getsize(text) if is_debug == True: chars_w = chars_w + 2 chars_h = chars_h + 2 im = Image.new(\"RGB\", (chars_w, chars_h), (255, 255, 255)) dr = ImageDraw.Draw(im) # 绘制文字边框 if is_debug == True: coords = [(chars_x+1, chars_y+1), (chars_x+1, chars_y+chars_h-1), (chars_x+chars_w-1, chars_y+chars_h-1), (chars_x+chars_w-1,chars_y+1)] dr.polygon(coords, outline=(255, 0, 10)) # 居中绘制文字 dr.text((chars_x, chars_y), text, font=font, fill=(0,0,0), align='center') im.save(image_path) def indexing(standards, new_chars, text): res = [] for i in range(len(text)): try: res.append(standards.index(text[i])+1) except: new_chars.append(text[i]) res.append(len(standards)+len(new_chars)+1) return res def clear_invalid_chars(char_array): for i in range(len(char_array)): char_array[i] = char_array[i].strip('\\n') def main(): parser = argparse.ArgumentParser(description='生成用于CnOcr训练的数据集') parser.add_argument(\"-root\", \"--root_dir\", default=\"data\", type=str, help=\"预训练配置目录\", ) parser.add_argument(\"-examples\", \"--examples_dir\", default=\"examples\", type=str, help=\"图片样本所在目录\", ) parser.add_argument(\"-font\", \"--font_path\", default=\"fonts/卷卷桃心中文字体.ttf\", type=str, help=\"待训练的字体路径\", ) parser.add_argument(\"-font_size\", \"--font_size\", default=20, type=int, help=\"待训练的字体大小\", ) parser.add_argument(\"-label\", \"--label_path\", default=\"label_cn.txt\", type=str, help=\"文本原料\", ) parser.add_argument(\"-train\", \"--train_name\", default=\"train.txt\", type=str, help=\"训练样本名\", ) parser.add_argument(\"-test\", \"--test_name\", default=\"test.txt\", help=\"测试样本名\", ) parser.add_argument(\"-is_test\", \"--is_test\", action=\"store_true\", help=\"是否生成测试图片\", ) parser.add_argument(\"-test_text\", \"--test_text\", default=\"\", help=\"测试文本\", ) args = parser.parse_args() root_dir = args.root_dir images_dir = args.examples_dir label_path = args.label_path train","date":"2021-04-08","objectID":"/posts/cnocr/:0:4","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r学习计划 ✔ 跑通cnocr的识别流程 ✔ 制作成离线部署包，方便在其它电脑上快速部署 ✔ 用来制作一些自用小工具，比如剪贴板上的图片OCR识别等 ✔ 跑通它的训练流程，持续改善识别精度 ✔ 提供新字体的预训练脚本 ✔ 提供适合在windows下使用的脚本-Makefile.bat ✔ 尝试改进它的文本方向纠正效果 现在它的文本校正方向很容易出现180度倒转的情况，看有没有啥办法处理下，已经找到问题了，OpenCv4.5的bug，通过pip install opencv-python==4.4.0.46降版本就行了，不过竖版文本的识别官方是暂不支持的，这个要另外想办法了 ","date":"2021-04-08","objectID":"/posts/cnocr/:0:5","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r后记在Python3.8下部署时候遇到问题，因此推荐使用Python3.7及其以下版本，详情看官方教程 个人比对了一下各个ocr项目，cnocr对纯文本图片的识别的准确度非常高，并且速度较快，但限于文本方向必须正确，一旦出现文本垂直或水平翻转，精度会严重下降；另外它对于那些广告图的识别效果也较差，不过无论如何，肯定甩tesseract不止一条街 如果你的需求大多集中在广告图等非纯文本图片上，那么建议使用paddleocr或chinesecor-lite，不过这些ocr项目的部署也相对复杂些 ps:mxnet库有个Warning一直很烦人，但是其不影响使用，直接在site-packages\\mxnet\\symbol\\symbol.py里注释掉line 925的warning输出 离线工具包制作离线工具包 = python3环境(从anaconda3中提取而得) + 系统环境变量关联脚本 + 官方模型 同理，这个也是网络上各种开源AI工具离线包的制作方式 ","date":"2021-04-08","objectID":"/posts/cnocr/:0:6","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["开源技术"],"content":"\r参考资料 更轻量的中文OCR—— cnocr-V1.2.2 ：最小模型只有 4.7M OCRSpace 支持超长图片的OCR识别 ","date":"2021-04-08","objectID":"/posts/cnocr/:0:7","tags":["ocr","cnocr","cnstd"],"title":"初探Cnocr","uri":"/posts/cnocr/"},{"categories":["原创工具"],"content":"在ocr识别当中，单字识别效果一般不够准确，另外，对于一个ocr功能而言，最耗时的莫过于每次执行ocr识别了，假设现今有几百张字符图片，为了快速生成{图片名：字符}的映射关系，需要耗时更少的方案 这个时候图片合并就需要安排上了，将几百次的字符图片识别转换为识别若干次单行或多行文字图片，减少ocr识别次数，就能有效减少耗时了，另外，经过合并后的文字图片在保留合理的字符间隔后，其识别准度也会有所提升，可谓一箭双雕 ","date":"2021-04-07","objectID":"/posts/char_image_merge/:0:0","tags":["原创工具","图片合并","ocr识别"],"title":"字符图片合并","uri":"/posts/char_image_merge/"},{"categories":["原创工具"],"content":"\r合并成单行文字图片实现思路上还是比较简单的，大致拆分成以下步骤： 设定单行文字图片里的文字数量 遍历文件夹下的字符图片，存储即将进行图片合并的图片路径列表 计算每个字符图片的尺寸大小 根据单行文字数量和尺寸大小来计算出最终合并后的图片尺寸，并在内存里创建一张该尺寸的纯色背景图 注意，如果字符图片的尺寸过小，为了让各个字符之间有足够的间隔，最好增加一个参数来拓展字符图片的边界 计算每张字符图片的混合贴图的位置信息，将各个字符图片平铺到这个背景图片上 保存图片到磁盘上 # 合并成单行文字图片 def combine_image_with_lite(paths, merge_times, is_debug = False): count = len(paths) src_image = Image.open(paths[0]) image_width, image_height = src_image.size x = image_width + extra_bound_as_single_line y = image_height + extra_bound_as_single_line # 计算合并之后的大小 full_x = x * count full_y = y full_size = (full_x, full_y) full_image = Image.new('RGBA', full_size, (255,255,255)) full_image.format = \"PNG\" # print(\"full rect : {%d,%d,%d,%d}\" % (0, 0, full_x, full_y)) # 将图片块平铺到这个大图片上 start_x = 0 start_y = 0 end_x = x end_y = y index = 1 draw = ImageDraw.Draw(full_image) for path in paths: if is_debug == True: # 绘制每个填充区域的边界 print(\"{%d,%d,%d,%d}\" % (start_x, start_y, end_x, end_y)) draw.rectangle((start_x+1, start_y+1, end_x-1, end_y-1), outline = get_random_color()) # 居中绘制填充的图片索引 index_str = \"%d\"%(index) font_size_x, font_size_y = draw.textsize(index_str) draw.text((start_x + (x-font_size_x)/2, start_y + (y-font_size_y)/2), index_str, fill='black') else: # 由于字符图片边界过小，如果直接平铺的话，就会显得太挤，OCR识别效果很差 # 为此拓展字符图片的填充区域，并将图片在此中间叠加上去 src_image = Image.open(path) start_x0 = start_x + (x-image_width)//2 start_y0 = start_y + (y-image_height)//2 end_x0 = start_x0 + image_width end_y0 = start_y0 + image_height full_image.paste(src_image, (start_x0, start_y0, end_x0, end_y0), src_image) index = index + 1 if end_x \u003e= full_x: # 从左往右填充，遇到边界之后切换到下一行 start_x = 0 end_x = start_x + x start_y = start_y + y end_y = start_y + y else: # 继续从左往右平铺 start_x = start_x + x end_x = end_x + x current_dir = os.getcwd() output_path = '%s/../single_line_%d.png' % (current_dir, merge_times) full_image.save(output_path) ","date":"2021-04-07","objectID":"/posts/char_image_merge/:0:1","tags":["原创工具","图片合并","ocr识别"],"title":"字符图片合并","uri":"/posts/char_image_merge/"},{"categories":["原创工具"],"content":"\r合并成多行文字图片实现思路上同上述差不多，但是需要注意计算好图片的行列数，尽可能减少空白区域，步骤如下： 遍历文件夹下的所有字符图片得到待合并的图片路径列表 计算每个字符图片的尺寸大小 根据合并的图片数量，开根号后计算行列数 根据行列数来计算出最终合并后的图片尺寸，并在内存里创建一张该尺寸的纯色背景图 注意，如果字符图片的尺寸过小，为了让各个字符之间有足够的间隔，最好增加一个参数来拓展字符图片的边界 计算每张字符图片的混合贴图的位置信息，将各个字符图片平铺到这个背景图片上，如果当前行已经平铺满了，就切换到下一行继续平铺 平铺顺序：从左到右 从上到下 保存图片到磁盘上 # 合并成多行文字图片 def combine_image_with_multi(paths, merge_times, is_debug = False): count = len(paths) src_image = Image.open(paths[0]) image_width, image_height = src_image.size x = image_width + extra_bound_as_multi_line y = image_height + extra_bound_as_multi_line # 根据待合并的图片总数来计算平铺的行列数 sqrt2 = math.sqrt(count) row_num = round(sqrt2) column_num = row_num if sqrt2 \u003e column_num: column_num = column_num + 1 print(\"总数：%d 开根号：%f 行：%d 列：%d\" % (count, sqrt2, row_num, column_num)) # 计算合并之后的图片尺寸 full_x = x * column_num full_y = y * row_num full_size = (full_x, full_y) full_image = Image.new('RGBA', full_size, (255,255,255)) print(\"full rect : {%d,%d,%d,%d}\" % (0, 0, full_x, full_y)) # 将图片块平铺到这个大图片上 start_x = 0 start_y = 0 end_x = x end_y = y index = 1 draw = ImageDraw.Draw(full_image) for path in paths: if is_debug == True: # 绘制每个填充区域的边界 print(\"{%d,%d,%d,%d}\" % (start_x, start_y, end_x, end_y)) draw.rectangle((start_x+1, start_y+1, end_x-1, end_y-1), outline = get_random_color()) # 居中绘制填充的图片索引 index_str = \"%d\"%(index) font_size_x, font_size_y = draw.textsize(index_str) draw.text((start_x + (x-font_size_x)/2, start_y + (y-font_size_y)/2), index_str, fill='black') else: src_image = Image.open(path) start_x0 = start_x + (x-image_width)//2 start_y0 = start_y + (y-image_height)//2 end_x0 = start_x0 + image_width end_y0 = start_y0 + image_height full_image.paste(src_image, (start_x0, start_y0, end_x0, end_y0), src_image) index = index + 1 if end_x \u003e= full_x: # 从左往右填充，遇到边界之后切换到下一行 start_x = 0 end_x = start_x + x start_y = start_y + y end_y = start_y + y else: # 继续从左往右平铺 start_x = start_x + x end_x = end_x + x current_dir = os.getcwd() output_path = '%s/../multi_line_%d.png' % (current_dir, merge_times) full_image.save(output_path) 附件：char_image_merge_tool.zip ","date":"2021-04-07","objectID":"/posts/char_image_merge/:0:2","tags":["原创工具","图片合并","ocr识别"],"title":"字符图片合并","uri":"/posts/char_image_merge/"},{"categories":["开发技巧"],"content":"之前在《谈一种页面加密技术》里谈到了自己捣弄了一个页面加密方案，并且也开发了一个cli工具用来对html或tag进行打包加密，由于本人的文章都是采用hexo来发布的，因此就需要将这个打包工具整合成hexo plugin了 ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:0","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["开发技巧"],"content":"\r前言这篇博客仅仅整理了本人开发这个加密插件的大体流程，由于互联网上关于Hexo插件的开发笔记早已汗牛充栋，在此就不再赘述了 ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:1","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["开发技巧"],"content":"\r使用方式本人希望借助这款插件，只需要让那些想要加密的md的文件头上添加password: your_pwd，即可在执行hexo g的时候，自动对生成的html的文章正文进行加密 ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:2","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["开发技巧"],"content":"\r开发笔记以下是本人在开发该插件时所检索到的有效资料和具体执行的插件学习\u0026开发流程： 了解hexo的插件工作机制 插件|Hexo 找出处理文章正文的插件接口或示例 在 hexo-blog-encrypt 里找到了关键接口 新建一个插件项目 《hexo教程之为hexo编写一个插件》 整合加密打包功能到这个插件项目上 已上传到 hexo-encrypted-package-html 仓库上了 将这款插件发布到npmjs.com上 《如何发布自己的NPM包（模块）？》 将这款插件发布到hexo插件市场上 插件|Hexo ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:3","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["开发技巧"],"content":"\r插件调试目前没有找到vscode直接断点调试hexo插件的方式以及相关的文章教程，这里采用的是根据hexo.log()或console.log()的日志输出来跟踪问题的 ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:4","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["开发技巧"],"content":"\r注意事项由于GithubPage是部署在墙外的，部分国内的cdn国外无法正常访问，所以需将bootstrap.min.css的国内url要改成国外url ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:5","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["开发技巧"],"content":"\r后记其实hexo 插件市场上也有好几款文章正文加密插件，其中一款也做得更加完善，具体看这里：hexo-blog-encrypt，本人开发的此款加密插件可当作另一种实现思路 这些同类插件是在本人实现一遍页面加密技术之后才发现的，为了不让自己的折腾变成瞎折腾，因此硬着头皮在搞多一款同类插件出来了\u003e\u003c ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:6","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["开发技巧"],"content":"\r参考资料 插件|Hexo hexo-blog-encrypt 《hexo教程之为hexo编写一个插件》 《如何发布自己的NPM包（模块）？》 《谈一种页面加密技术》 ","date":"2021-03-25","objectID":"/posts/how_to_write_a_hexo_plugin/:0:7","tags":["encrypted html","hexo plugin","base64_with_xor"],"title":"Hexo插件-文章加密","uri":"/posts/how_to_write_a_hexo_plugin/"},{"categories":["原创工具","技术选型"],"content":"在一次练车的时候突发奇想，发现自己有些私密分享的需求，然后有了这次技术探索 ","date":"2021-03-15","objectID":"/posts/a_way_of_html_encryption/:0:0","tags":["原创工具","html","hexo","encrypted"],"title":"谈一种页面加密技术","uri":"/posts/a_way_of_html_encryption/"},{"categories":["原创工具","技术选型"],"content":"\r前言这段时间边练车边整理工作笔记，然后突然发现，有一些内容不适合直接公开分享，但是也希望发布出去，被那些想看的亲朋好友可以正常浏览，因此有了html的加密访问需求，另外，考虑到这些加密分享的内容并不适合被搜索引擎检索到它的正文，所以正文内容也是有加密需求的。于是就在网上检索有没有相关的技术实现的文章。然后找到了这些技术博客或在线工具： HTML的简单页面加密代码 基本流程上是没啥问题，但是这个示例里面，密码完整验证的方式已经被明文存储在页面上了，纵使密码存放在其它地方，采用Ajax方式获取之后再对比也毫无意义，开发者很容易在浏览器上通过F12修改这个密码验证逻辑从而正常浏览到，并且，由于这里面的内容也是明文存放着的，也会被搜索引擎检索到 HTML网页加密解密 无法正常体验，并且访问体验也不是我想要的 总而言之，虽然找到了各种貌似可用的实现，但是都没有get到我的需求痛点，决定自己开搞一个 ","date":"2021-03-15","objectID":"/posts/a_way_of_html_encryption/:0:1","tags":["原创工具","html","hexo","encrypted"],"title":"谈一种页面加密技术","uri":"/posts/a_way_of_html_encryption/"},{"categories":["原创工具","技术选型"],"content":"\r基本思路实际上，本人对访问的加密强度没啥追求，只需要以下特性即可： 正文不能被搜索引擎爬虫到 需要输入密码访问 针对这两个需求点，采用以下两种加密方式混合使用即可达到： base64 (一种可逆加密方式，将明文或字节流转换成base64字符串，在此解决首次xor加密生成的字节流存储在页面的问题) xor (一种可逆加密方式，提供密钥验证支持，在正确的密钥下，进行两次该加密即可获得原文) 页面加密打包思路读取需要加密的html文件的特定标签内容，将其进行base64+xor加密之后，塞到一个可以进行密码验证访问的模板标签上，删掉这个已加密的正文标签后，将模板标签再重新拼接成新的html。具体流程流程看代码啦，也是比较直观的 页面验证访问思路游客打开这个加密后的html之后，已加密的标签上会显示一个密码验证的界面，如果密码输入错误，浏览器会弹框提醒，如果输入密码正确，则解密后的正文标签outHtml会直接替换掉这个密码验证标签的outHtml，此时浏览器会自动将正文内容加载出来 密码验证思路核心思路是提供一个 前缀字符串(prefix_str) 来作为判断依据，最终整个流程如下所示： 加密打包：base64(xor(prefix_str+content)) 解密验证：xor(unbase64(encode_str))，再从中匹配前缀字符串是否刚好为 prefix_str，如果是，则密码正确，反之，提醒用户重新输入 加密/解密思路从html上提取到需要加密的正文tag之后，其加密、解密的流程设计如下所示： html encrytion html decrytion +--------------+ +--------------+ | | | | |input html tag| |input html tag| | | | | +--------------+ +--------------+ | | | | | | +-------v--------+ +---------v---------+ | | | | | xor encryption | | base64 encryption | | | | | +----------------+ +-------------------+ | | | | | | +--------v----------+ +-------v--------+ | | | | | base64 encryption | | xor encryption | | | | | +-------------------+ +----------------+ | | | | | | +------v--------+ +------v--------+ | | | | |output html tag| |output html tag| | | | | +---------------+ +---------------+ 技术选型此工具基于nodejs技术栈实现，经过对比，选择了下面这几个第三方库： js-base64 utf8支持良好的base64库 cheerio 能够解析修改html的html库，多用于爬虫项目 yargs 能轻松配置命令，解析多个参数，并设置快捷方式等，还能自动生成帮助菜单的命令行辅助库 代码实现 base64+xor加密解密库 html加密打包工具 后续迭代由于目前本人的博客都是采用hexo发布的，因此需要将这个加密逻辑整合成hexo插件，期间找到了一款同类型的插件hexo-blog-encrypt，这款hexo插件基本满足我最开始的要求了，但由于它是在我完成了base64+xor加密解密库和html加密打包工具后，打算整合到hexo的时候才找到的，本着不断学习的态度，借鉴这个插件的思路，自己也重写了一个 OMG，感兴趣的可前往hexo-encrypted-package-html ","date":"2021-03-15","objectID":"/posts/a_way_of_html_encryption/:0:2","tags":["原创工具","html","hexo","encrypted"],"title":"谈一种页面加密技术","uri":"/posts/a_way_of_html_encryption/"},{"categories":["开发技巧"],"content":"在我们生活中有各种各样排行榜，比如电商、社交网站上的各种热度榜、周榜、月榜等等，而在游戏里，这类排行榜也是比较常见，比如战力榜、积分榜、鲜花榜啥的，下面谈谈它们在不同游戏服务器架构下的实现 ","date":"2020-05-19","objectID":"/posts/global_rank_server_imp/:0:0","tags":["排行榜","全区全服","分区分服"],"title":"排行榜实现的二三事","uri":"/posts/global_rank_server_imp/"},{"categories":["开发技巧"],"content":"\r全区全服架构各种社交类游戏，比如房间类PVP，Moba、棋牌、赛车类项目，这种比较常见，这种游戏一般都有一个登录大厅，然后匹配进到同一个房间PK，服务器的压力主要在于匹配大厅的承载量，以及全服排行榜、全服聊天等等公共服务上 这类游戏一般会用到Redis中间件，可以直接基于Redis的有序集合zset来实现通用排行榜，这样一来该服务还拥有了备份、容灾及高可用等能力；不过如果项目没有使用到redis，那么自己手撸一个跳跃表(skip list)也可以做到，zset的底层实现是跳跃表，但是这样高可用以及容灾能力都得自己另外支持了，个人并不推荐 技术Demo基于以上思路，本人实现了一个简单的技术 Demo，如下图所示： 开启负载均衡 运行 global_rank_server\\deps\\openresty-1.27.1.1-win64\\nginx.exe 则可以开启负载均衡，访问：http://127.0.0.1:8020/ 即可看到效果 附件 global_rank_server.zip ","date":"2020-05-19","objectID":"/posts/global_rank_server_imp/:0:1","tags":["排行榜","全区全服","分区分服"],"title":"排行榜实现的二三事","uri":"/posts/global_rank_server_imp/"},{"categories":["开发技巧"],"content":"\r分区分服架构一般来说，分区分服多出现在各种MMO游戏项目，比如MMO 回合制、MMO Arpg、MMO SLG之类的，这类单服玩家数相对较少，因此即便排行榜采用全排序也能满足需求。然而，对于跨服排行榜，考虑到它的玩家规模不定，通常是高于单服至少一个数量级，建议借鉴全区全服的排行榜解决思路，如果项目里没有引入Redis，那就基于跳跃表实现一个高效通用的排行榜机制，这样可以确保排行榜的响应速度和数据处理能力，满足大规模玩家的需求 ","date":"2020-05-19","objectID":"/posts/global_rank_server_imp/:0:2","tags":["排行榜","全区全服","分区分服"],"title":"排行榜实现的二三事","uri":"/posts/global_rank_server_imp/"},{"categories":["开发技巧"],"content":"\r参考链接 游戏全区全服和分区分服 QQ斗地主的设计 ","date":"2020-05-19","objectID":"/posts/global_rank_server_imp/:0:3","tags":["排行榜","全区全服","分区分服"],"title":"排行榜实现的二三事","uri":"/posts/global_rank_server_imp/"},{"categories":["原创工具"],"content":"目前在项目里做导表工具改版，由于这个导表工具采用php实现的，希望在idea ide上可以断点调试php，需要安装配套版本的xdebug ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:0","tags":["原创工具","html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["原创工具"],"content":"\r前言在idea里的php settings上有其安装指导，如下图所示： 经过网上检索可知，安装php-xdebug的步骤如下： 查询phpinfo 拿phpinfo去xdebug wizard查询其匹配的xdebug版本及其下载链接 然后下载dll并在php.ini里修改xdebug的配置项 但由于本人有多台办公设备，并且其php版本都不太一样，所以需要开发一个快速下载/部署xdebug的脚本，能达到一键部署php的开发调试环境就最好了 ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:1","tags":["原创工具","html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["原创工具"],"content":"\r基本思路 在shell上用which php查找到php的所在路径，并cd $(dirname $(which php))（将这个py脚本放置在php.exe的同级目录就行） 判断这个目录下是否有php.ini文件，如果没有的话，就cp php.development php.ini（这部分采用python来实现） 在shell上执行php -i phpinfo(); \u003e phpinfo.txt，将结果输出到文本上（在python中调用此shell指令，并将输出存放在变量中） 用输出的phpinfo信息粘贴在xdebug.org-custom installation instructions上的文本框上查询，这里面会检测到xdebug版本 - 具体的phpinfo的检测条件在phpinfo-scanner.php 这一步是关键，分析这个查询请求的Responses Headers和Form Data 采用bs4从html上提取php_xdebug_xxx.dll的下载链接 下载php_xdebug_xxx.dll到ext目录下 采用configparser来修改php.ini上的xdebug配置 ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:2","tags":["原创工具","html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["原创工具"],"content":"\r代码实现 # !/user/bin/env python # -*- coding:utf-8 -*- import os, sys, subprocess, locale, shutil import requests, codecs, urllib, configparser from bs4 import BeautifulSoup from sys import stdout # 拿phpinfo在xdebug.org上查询并提取xdebug.dll的下载链接 def get_xdebug_download_page(phpinfo): url = 'https://xdebug.org/wizard' data = { \"data\": phpinfo, \"submit\": \"Analyse my phpinfo() output\" } headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36\", \"Origin\": \"https://xdebug.org\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\", \"Referer\": \"https://xdebug.org/wizard\", \"Accept-Encoding\": \"gzip, deflate, br\", \"Accept-Language\": \"zh-CN,zh;q=0.9\", } return requests.post(url=url, headers=headers, data=data).text # 从html上提取xdebug的下载链接 def find_xdebug_download_link(html): soup = BeautifulSoup(html, features=\"html.parser\") return soup.find(\"ol\").find(\"a\")[\"href\"] # 获取phpinfo def get_php_info(): phpinfo = read_commandline(\"php -i phpinfo();\") substr_flag = phpinfo.find(\"___________________\") return phpinfo[0:substr_flag] # 获取shell的输出结果 def read_commandline(command_str): output_str = \"\" ps = subprocess.Popen(command_str, stdin=subprocess.PIPE, stdout=subprocess.PIPE, shell=True) while True: data = ps.stdout.readline() if data == b'': if ps.poll() is not None: break else: output_str = output_str + data.decode(codecs.lookup(locale.getpreferredencoding()).name) return output_str # 下载文件 def download_file(url, file_path): r = requests.get(url) with codecs.open(file_path,'wb') as f: f.write(r.content) # Refer to : https://www.jb51.net/article/167786.htm def download_file_with_process(url, file_path): with codecs.open(file_path, \"wb\") as fw: with requests.get(url, stream=True) as r: filesize = r.headers[\"Content-Length\"] chunk_size = 128 times = int(filesize) // chunk_size show = 1 / times show2 = 1 / times start = 1 for chunk in r.iter_content(chunk_size): fw.write(chunk) if start \u003c= times: stdout.write(f\"download process : {show:.2%}\\r\") start += 1 show += show2 def check_php_cfg(php_cfg): default_php_cfg = php_cfg+\"-development\" if not os.path.exists(php_cfg): shutil.copy(default_php_cfg, php_cfg) # 更新php.ini上的xdebug配置 def update_php_cfg(php_cfg, xdebug_path): conf = configparser.ConfigParser() conf.read(php_cfg) xdebug_section_name = \"xdebug\" if conf.has_section(xdebug_section_name): pass else: conf.add_section(xdebug_section_name) conf.set(xdebug_section_name, \"zend_extension\", xdebug_path) conf.set(xdebug_section_name, \"xdebug.remote_enable\", \"1\") conf.set(xdebug_section_name, \"xdebug.remote_autostart\", \"1\") # conf.set(xdebug_section_name, \"xdebug.remote_host\", \"10.0.2.2\") # conf.set(xdebug_section_name, \"xdebug.remote_port\", \"9000\") outfile = codecs.open(php_cfg, \"w\") conf.write(outfile) outfile.close() if __name__ == '__main__': php_cfg = \"php.ini\" print(\"-------------check php.ini---------------\") check_php_cfg(php_cfg) print(\"-------------fetch phpinfo---------------\") phpinfo = get_php_info() print(\"-----fetch xdebug.dll download link------\") html = get_xdebug_download_page(phpinfo) download_link = find_xdebug_download_link(html) print(\"----------download xdebug.dll------------\") dir_path = \"./ext\" file_name = os.path.basename(download_link) file_path = os.path.join(dir_path, file_name) full_file_path = os.path.abspath(file_path) if not os.path.exists(file_path): # download_file(download_link, full_file_path) download_file_with_process(download_link, full_file_path) else: print(\"%(full_file_path)s already exists, skip download ……\" % {'full_file_path' : full_file_path}) update_php_cfg(php_cfg, full_file_path) 附件：php_xdebug_deploy.zip ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:3","tags":["原创工具","html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["原创工具"],"content":"\r注意事项由于此脚本是基于xdebug.org里 custom installation instructions 提供的查询功能来实现的，如果这个站点的规则改动了，则脚本可能会失效 ps:其实在刚编写此脚本的时候，也曾考虑过采用selenium+headless browser()来处理ajax请求，不过考虑到这个脚本做的就是减法，用headless browser的方案会引入第三方可执行程序，比如chrormedriver.exe，这就太不友好了，所以还是自己分析下ajax请求，提取到[Analyse my phpinfo() output] Button的真正http请求 ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:4","tags":["原创工具","html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["原创工具"],"content":"\r参考资料 Python3 requests文件下载 期间显示文件信息和下载进度代码实例 Python爬虫之selenium库(三)：Chrome无头模式与操作浏览器 selenium+Headless Chrome实现不弹出浏览器自动化登录–问题总结 selenium设置谷歌无头浏览器 downloading-with-chrome-headless-and-selenium ","date":"2019-09-01","objectID":"/posts/auto-download-xdebug-for-php/:0:5","tags":["原创工具","html","hexo","encrypted"],"title":"PHP-XDebug安装脚本","uri":"/posts/auto-download-xdebug-for-php/"},{"categories":["装机"],"content":" 最近入手了台Surface Pro6，然后又重新捣弄起各种常用的开发环境了，C++、Python、Php的开发环境搞起等，不过很快就遇到了各种状况，这里特此记录下来，以前很多笔记都丢到有道云笔记上了，这里重新拾遗吧。 ","date":"2019-05-07","objectID":"/posts/about-deploy-win10-environment/:0:0","tags":null,"title":"谈谈Win10系统的折腾","uri":"/posts/about-deploy-win10-environment/"},{"categories":["装机"],"content":"\r触摸板无法正常拖动文件和截图了其实这个在Win 10里面是可以设置的，通过开始菜单 –\u003e 设置 –\u003e 设备 –\u003e 触摸板，然后勾选 ☐点击两次之后再拖动及可多选 即可，如下图所示： 另外，Win10内置的触摸板手势也可以在这个设置界面上看到哦O(∩_∩)O ","date":"2019-05-07","objectID":"/posts/about-deploy-win10-environment/:1:0","tags":null,"title":"谈谈Win10系统的折腾","uri":"/posts/about-deploy-win10-environment/"},{"categories":["装机"],"content":"\r无法在第三方应用上打开浏览器 比如QQ、VSCode里面的url，点击之后无反应 这是因为url的默认打开程序被设置成无效程序了，可能因为之前的程序被卸载导致的，重新指定一个即可 ","date":"2019-05-07","objectID":"/posts/about-deploy-win10-environment/:2:0","tags":null,"title":"谈谈Win10系统的折腾","uri":"/posts/about-deploy-win10-environment/"},{"categories":["装机"],"content":"\r一些应用无法正常添加到右键菜单，比如TortoiseGit、TortoiseSvn、Cmder一般是以下两种情况： 没有以管理员身份运行，比如Cmder 没有安装与Windows 系统对应的32bit/64bit版本应用，举个例子，TortoiseGit 32bit是无法在Win10 64bit上添加上右键菜单的 如果是电脑小白的话，其实还有一种是被安全管家类软件拦截导致的，这里就不赘述了==! ","date":"2019-05-07","objectID":"/posts/about-deploy-win10-environment/:3:0","tags":null,"title":"谈谈Win10系统的折腾","uri":"/posts/about-deploy-win10-environment/"},{"categories":["装机"],"content":"\r更改TortoiseSVN的文件比较工具由于未知名原因，TortoiseIDiff工具无法在SVN Commit对话框上直接打开，因此将文本比较工具由 TortoiseIDiff更改为Beyond Compare 3， 打开TortoiseSVN的Setting，选择左边的 Diff Viewer，然后设置Diff configure，如：\"...\\BComp.exe\" %base %mine /title1=%bname /title2=%yname /leftreadonly，配置如下所示： 参考资料： TortoiseSVN比较工具设置为BeyondCompare 4 吐槽这个价位下的surface pro已经没啥性价比了，但是作为一枚伪软粉以及颜控党，终究充值了一波信仰（ps:真香定律无处不在啊），另外它的便捷性的确比普通笔记本好多了，作为一个后端狗，算是为自己的背包减肥了。 ","date":"2019-05-07","objectID":"/posts/about-deploy-win10-environment/:3:1","tags":null,"title":"谈谈Win10系统的折腾","uri":"/posts/about-deploy-win10-environment/"},{"categories":["DevOps"],"content":"\rCMake官网\rhttps://cmake.org/\r","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:0","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["DevOps"],"content":"\r前言CMake是一个跨平台项目构建工具，主要对标C/C++项目。其师出于automake，有其独有的DSL，详情请移步到CMake官网 ","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:1","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["DevOps"],"content":"\r安装CMake对于Linux，这个挺简单的，CentOS执行 yum install cmake，Ubuntu执行 apt-get install cmake，如果觉得Linux发行版安装的cmake版本太旧，那么从官网上下载源码编译吧，当然，到cmake download page上下载也是个不错的途径 而对于Windows，个人是建议直接到cmake download page上下载二进制版本，将其添加到系统环境变量path上即可。电脑上安装了Msys2的话，也可以通过pacman -S cmake来安装；安装了cmder的话，在 .../vendor/init.bat 里插入 set path=%path%;xxx:/xxx/cmake-xxx/bin; 也是可以的，如下图所示： ","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:2","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["DevOps"],"content":"\r入门教程 cmake由于其语法丰富，比较适合管理大型的跨平台c/c++工程，而在轻量级的项目里，premake、xmake、qmake都是不错的方案呢。在终端上输入 cmake -h 后，可以看到cmake 3.12.0中已经支持了vs、codeblocks、codelite、eclipse等IDE和高级文本编辑器了 至于cmake的入门教程，由于网上相关资料已经汗牛充栋了，这里就不重复了，读者可以直接移步到《CMake 入门实战》中文和《cmake-tutorial》官方英文，先过一遍中文教程，心里有底之后 ，再过一遍cmake官方教程即可入门了，剩下的知识点在项目需要用到时再学吧，毕竟只是个项目管理工具而已 下面整理了一些常用的操作命令说明: 函数 作用 project() 指定工程名称，在vs中就是.sln的名字 add_subdirectory() 设置子CMakeLists的所在路径 configure_file() 设置配置文件，一般用来预处理项目版本以及配合find_package、find_library、option等命令控制某些功能是否开启用的 add_executable() 添加一个可执行二进制项目，对应vs里的cli、gui项目 add_library() 添加一个动/静态链接库库项目，SHARED是动态链接库，STATIC是静态链接库 set() 设置变量，如果想多个CMakeLists.txt共用某个变量，那么需要将其指定为CACHE，如set(contribdir ${contribdir} ${CMAKE_CURRENT_SOURCE_DIR}/stb CACHE INTERNAL \"contrib library\" ) unset() 删除变量，通常用来删除临时变量 option() 设置操作项，可通过ON/OFF来控制开关，这个配置项在cmake-gui中以复选框的形式显示，通常与configure_file结合使用 message() 设置项目生成时的日志输出，甚至可以控制cmake的执行，比如FATAL_ERROR可终止cmake的往下执行 source_group() 将文件列表设为某个子群组，对应vs里的include、src等目录，如source_group(\"contrib/include\" ${CURRENT_HEADERS}) file() 快速搜索文件，将其存放在某个变量里，支持多路径搜索，多用于搜索头文件、资源文件什么的，配合source_group将之添加到工程里 aux_source_directory() 搜索指定路径下的源文件，通常是.cpp、.c、.cxx等后缀名的文件，结果存放在某个变量里 add_definitions() 添加预处理宏，针对当前CMakeLists下的所有项目，如果只想为某个项目添加特定的预处理宏，那么需要使用set_tests_properties，如set_tests_properties(person_dll PROPERTIES COMPILE_DEFINITIONS \"DEMO_USE_DLL\") add_custom_command() 添加自定义命令，可以设置执行时机(编译前、链接中、编译后)，比如生成了.dll后，想将其复制到主项目的可执行文件所在目录中，就需要它了，还有各种自定义生成指令也是用到了它 target_link_libraries() 设置要链接的库文件 include_directories() 添加头文件的搜索路径，只对当前CMakeLists.txt生效 link_directories() 添加链接库的搜索路径，只对当前CMakeLists.txt生效 find_package() 查找第三方包，比如某项目依赖了第三方开源库curl来实现一个下载器，那么就可以通过这条指令来判断开发者是否安装了curl，如果 没开启，则禁用下载功能，通常与CMAKE_MODULE_PATH组合使用，如SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) find_path() 搜索某路径下的文件，多用于搜索头文件、链接库，以此来控制功能的开关，举个例子，某个项目集成了一个未开源的第三方库svgload，这个第三方库时以显式调用的方式提供，也就是说，提供了.h、.dll和.lib这三个文件，但是不给源码，此时就可以通过这条指令来尝试搜索项目，看有没有这个svgload开发包了，如果没有的话，通过预编译关闭掉svg的加载功能，当然，也可以采用find_package()来实现 find_library() 搜索某路径下的链接库，find_pat其实也可以替代它，两者用法相似 ","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:3","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["DevOps"],"content":"\r非官方例子由于工作中用到的东西有点多，脑子记不过来，因此在此特意记下几个常用的例子，这里以图片转换器为例: 基本功能：加载常见的图片格式，如jpg、png、bmp、svg等，将其转换成其它图片格式，目前仅提供CLI版本用作演示 技术选型如下: +--------\u003eImageLoadModule(gdi+、stb_image.h、libgif、naosvg、skia、freeimage等)，加载磁盘上的图片资源到内存中 | | ImageConverter--|---------\u003eAutoCompleteModule(linenoise、readline等)，为CLI程序提供命令自动补全的功能 | | +--------\u003eImageSaveModule(gdi+、stb_image_write.h、freeimage等)，将内存中的图片数据保存到磁盘 ImageConverter 0.1 这只是一个初始版，仅仅是搜索项目下的源文件，将其添加到VS上，可以编译执行了，附件：ImageConverter0.1.zip # 指定cmake的最小版本 cmake_minimum_required(VERSION 2.8) # 指定工程名称，ImageConverter.sln project(ImageConverter) # 搜索当前目录下的源码文件，用srcs存储起来 aux_source_directory(. srcs) # 配置一个可执行文件项目，ImageConverterDemo.vcxproj add_executable(ImageConverterDemo ${srcs}) ImageConverter 0.2 接下来搭建这个项目的基础部分，定好各种组件的接口，这里先以gdi+作为图片的编解码器，附件：ImageConverter0.2.zip # 指定cmake的最小版本 cmake_minimum_required(VERSION 2.8) # 指定工程名称，ImageConverter.sln project(ImageConverter) # 搜索目录下的源码文件 aux_source_directory(. srcs) FILE(GLOB_RECURSE coresrcs ./core/*.cpp ) FILE(GLOB_RECURSE miscsrcs ./misc/*.cpp ) # 搜索目录下的头文件 FILE(GLOB_RECURSE coreheaders ./core/*.h ) FILE(GLOB_RECURSE mischeaders ./misc/*.h ) # 添加到项目筛选器上 source_group(\"src\" FILES ${srcs}) source_group(\"src\\\\core\" FILES ${coresrcs}) source_group(\"src\\\\misc\" FILES ${miscsrcs}) source_group(\"include\\\\misc\" FILES ${mischeaders}) source_group(\"include\\\\core\" FILES ${coreheaders}) # 添加头文件搜索路径 include_directories(./core) include_directories(./misc) # 配置一个可执行文件项目，ImageConverterDemo.vcxproj add_executable(ImageConverterDemo ${srcs} ${coresrcs} ${miscsrcs} ${coreheaders} ${mischeaders}) ImageConverter 0.5 这里调用了第三方类库nanosvg来支持svg文件的读取，主要演示了如何通过Git来管理第三方类库，以及如何在cmake里面整合第三方类库源码的过程，简略描述如下： 借助option来配置svg的功能开启，如果为ON，则这里以SUPPORT_SVG_TYPE作为开启的条件，通过add_definitions(-DSUPPORT_SVG_TYPE)来添加预处理宏，源码里以SUPPORT_SVG_TYPE作为预编译宏，整理所有与svg相关的代码逻辑，另外，也要在CMakeLists.txt中，以if(SUPPORT_SVG_TYPE)判断是否执行追加相关头文件搜索路径，添加相关文件名到工程等命令 借助configure_file来配置一个外部的头文件，用来传入程序的版本号，当然，也可以配合option来做其他事情 附件：ImageConverter0.5.zip # 指定cmake的最小版本 cmake_minimum_required(VERSION 2.8) # 指定工程名称，ImageConverter.sln project(ImageConverter) # 配置版本号 set (APP_VERSION_MAJOR 1) set (APP_VERSION_MINOR 0) # 配置是否开启SVG的支持 option (SUPPORT_SVG_TYPE \"support .svg file\" ON) # 加入一个配置头文件，用于处理 CMake 对源码的设置 configure_file ( \"${PROJECT_SOURCE_DIR}/config.h.in\" \"${PROJECT_SOURCE_DIR}/config.h\" ) aux_source_directory(. srcs) source_group(\"src\" FILES ${srcs}) FILE(GLOB_RECURSE coresrcs ./core/*.cpp ) source_group(\"src\\\\core\" FILES ${coresrcs}) FILE(GLOB_RECURSE miscsrcs ./misc/*.cpp ) source_group(\"src\\\\misc\" FILES ${miscsrcs}) FILE(GLOB_RECURSE coreheaders ./core/*.h ) source_group(\"include\\\\core\" FILES ${coreheaders}) FILE(GLOB_RECURSE mischeaders ./misc/*.h ) source_group(\"include\\\\misc\" FILES ${mischeaders}) if(SUPPORT_SVG_TYPE) FILE(GLOB_RECURSE nanosvgheaders ./modules/nanosvg/src/*.h ./modules/nanosvg/example/*.h ) source_group(\"modules\\\\include\\\\nanosvg\" FILES ${nanosvgheaders}) include_directories(./modules/nanosvg/src) include_directories(./modules/nanosvg/example) add_definitions(-DSUPPORT_SVG_TYPE) endif(SUPPORT_SVG_TYPE) # 添加头文件搜索路径 include_directories(./core) include_directories(./misc) # 配置一个可执行文件项目，ImageConverterDemo.vcxproj add_executable(ImageConverterDemo ${srcs} ${coresrcs} ${miscsrcs} ${coreheaders} ${mischeaders} ${nanosvgheaders}) ImageConverter 0.6 目前发现Gdiplus里面的图片编码、解码的功能还是太弱了，支持的图片类型太少，比如无法正常加载psd类型，因此打算采用FreeImage来加强这个功能。由于FreeImage是以一个动态库的开发包形式分发的，因此需要更多的指令来控制依赖FreeImage库的工程生成，其中包括项目生成之后的dll文件拷贝、根据.dll、.lib的文件是否存在来判断是否生成ForFreeImage的工程等等，用到的关键指令如下所示： 函数 作用 FIND_PACKAGE() 用来查看cmake目录下的xxx.cmake文件，里面定义了这个模块的源码、开发包的搜索方式，注意，xxx.cmake里定义的参数可以传递到CMakeLists.txt里面哦 set_target_properties() 为指定项目配置特有属性，通常用来添加项目特有的宏定义，而add_definitions定义的宏会添加到所有生成的项目中，注意这个的区别哦 target_link_libraries() 让指定项目链接静态库/导入库，不是作用到所有项目哦 add_custom_command() 自定义生成命令，在此是为了让FreeImage项目生成后，自动拷贝FreeImage开发包下的.dll文件到.exe所在目录下，注意，这里面还用set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) 来重定向输出目录了哦 附件：ImageConverter0.6.7z ### 这里仅仅截取CMakeLists.txt的FreeImage配置相关代码段 SET(CMAKE_","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:4","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["DevOps"],"content":"\rFAQ\r不熟悉xxx命令，如何快速检索相关资料呢 对于不熟悉的cmake command，有两种方法可以快速找到其使用说明，这里以find_path为例 直接在终端上输入cmake -h find_path来查询即可，如下图所示: 直接问度娘或谷歌，输入cmake find_path来搜索即可，通常搜索引擎前三就是cmake官方的文档，后面的搜索结果是网友的一些博客了 自2023年之后，可以借助ChatGpt4、Github Copilot之类的问答类大模型来快速查找相关函数用法，这个比搜索引擎更加便捷 SublimeText、VSCode等编辑器应该安装什么插件来快速编辑cmake呢 SublimeText—-CMakeEditor VSCode—-CMakeTool+CMake 如何调用cmake来编译工程 cd build/ cmake --build . ","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:5","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["DevOps"],"content":"\r参考资料: cmake 设置vs工程的MT、MTd cmake:msvc编译第三方库时使用/MT静态库连接c/c++ runtime library ","date":"2018-06-20","objectID":"/posts/use_cmake_notes/:0:6","tags":["CMake","学习笔记"],"title":"CMake学习笔记","uri":"/posts/use_cmake_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"宇宙第一IDE，yyds ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:0:0","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"\r快捷键配置","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:1:0","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"\rVisual Studio常用快捷键 快捷键 描述 ctrl+k+ctrl+c 代码注释 ctrl+shift+u 让被选中的文本里的字母全部转换为大写 ctrl+u 让被选中的文本里的字母全部转换为小写 ctrl+shift+space 当光标在函数的小括号里面的时候，会弹出此函数的参数列表 ctrl+i 向前导航跳转 ctrl+o 向后导航跳转 ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:1:1","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"\rVisual Assist常用快捷键 快捷键 描述 shift+alt+s Find Symbol shift+alt+f Find References alt+g Goto Implementation shift+alt+g Goto Related shift+alt+o Open File in Solution ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:1:2","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"\rVisual Assist插件配置","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:2:0","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"\rC++注释配置\r枚举类型注释[\\e] /** @brief $SymbolContext$ */ enum AnotherEnum { V1,/**\u003c value 1 */ V2 /**\u003c value 2 */ }; 函数注释[\\*] /** * @brief: $SymbolContext$ * @param[in] 参数类型 参数名 参数说明 * @param[in|out] 参数类型 参数名 参数说明 * @return 返回值说明 * @note * $end$ */ 类注释[\\c] /** * @class $ClassName$ * @brief $SymbolContext$ * @note * $end$ */ 文件头注释[\\h] /***************************************************************************** * @file $FILE_BASE$.$FILE_EXT$ * @brief $SymbolContext$ * @note * $end$ * *----------------------------------------------------------------------------* * Change History : * \u003cVersion\u003e | \u003cDescription\u003e *----------------------------------------------------------------------------* * 0.0.0.1 | 创建头文件 *----------------------------------------------------------------------------* * *****************************************************************************/ 注意，需要安装Visual Assist插件哦。具体需要【VAssisX】–\u003e【Tools】–\u003e【Edit VA Snippets】，然后将上面的注释宏添加到打开的VA Snippet Editor之中 ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:2:1","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"\r其他功能","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:3:0","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"\r显示特殊变量无需编写插件或修改配置文件，只需要将要显示的变量拉到监视调试窗口(Watch Windows)中，并在变量后面添加,xxx即可显示，目前支持以下功能 只需要将要显示的字符串拉到Watch中,并在变量后面添加,s8即可显示 变量显示标识 描述 ,数字 将变量拆分为数组显示, 数字是要显示多少位, 此法对const char*这类原始字符串非常有用 ,s8 转换为UTF-8字符串查看 ,x 转换成16进制查看 ,hr 转换成Windows HRESULT解释查看 ,wm 转换成Windows消息查看，例如0x0010, wm 显示 WM_CLOSE ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:3:1","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"\rFAQ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:4:0","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"\r编译错误’std::tuple’ : too many template arguments在VS 2012编译Gtest源码的时候，遇到了此错误，具体讨论看一下链接：《Google Test in Visual Studio 2012》 解决方法 只需要在VS工程中，添加预处理 _VARIADIC_MAX=10即可，如果此VS工程是通过qmake来生成的话，那么需要在指定的xxx.pro文件上添加上DEFINES += _VARIADIC_MAX=10语句即可。 ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:4:1","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["IDE技巧","开发技巧"],"content":"\risnan()和isinf()未定义此问题是本人在使用VS 2012编译log4z开源库时冒出来的，其实类似的问题集中在VC上出现，这是由于VC支持新标准不及时所引起的，详情可看：《isnan isinf》 解决方法 在报错的所在文件头上添加上以下代码段即可： inline int isnan(double x) { return x != x; } inline int isinf(double x) { return !isnan(x) \u0026\u0026 isnan(x - x); } ","date":"2017-11-16","objectID":"/posts/use_visual_studio_notes/:4:2","tags":["vs","visual studio"],"title":"Visual Studio使用笔记","uri":"/posts/use_visual_studio_notes/"},{"categories":["编程语言"],"content":"\rLua官网\rhttps://www.lua.org/\r","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:0","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r在Lua实现带默认参数的函数在lua之中，它没有提供像C++那样的不同参数列表的同名函数是不同的机制，在它的内部里面，其实现了一种很朴素的做法 假设定义了一个有n个形参的函数 SetArgs(arg1...argn)，那么若果开发者在实际调用此函数的时候，填充的参数的个数小于n，那么后面没有添加的参数的实参都默认被设为nil，此时通过or运算符来设定默认值即可；另外，也并不支持 SetArgs(arg1 = 1,arg2 = 2, argn = n )之类的语句，如下所示： myTable = { a= 1, b=2, c=3, d=4 } --一种难以言喻的操作 function myTable:SetParam(a1,b1,c1,d1) self.a = a1 or \"a1\" self.b = b1 or \"b1\" self.c = c1 or \"c1\" self.d = d1 or \"d1\" end --并没有这种骚操作 --function myTable:SetParam(a1 = \"a1\",b1 = \"b1\",c1 = \"c1\",d1 = \"c1\") -- self.a = a1 -- self.b = b1 -- self.c = c1 -- self.d = d1 --end local temp = myTable temp:SetParam(\"Adobe\") print(temp.a) print(temp.b) print(temp.c) print(temp.d) print(\"end\") ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:1","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r模拟C++的类的继承机制更多相关资料请看Metatable In Lua 浅尝辄止 --lua仿写类似C++的类 --注意，lua的默认参数比较奇葩，在成员函数内部，直接添加xxx1 or xxx2即可 people = { } function people:new( newName, newIdentity ) obj = {} obj.name = newName or \"unknown name1\" obj.identity = newIdentity or \"unknown identity1\" setmetatable(obj,self) self.__index = self return obj end --添加成员函数 function people:GetName() return self.name end function people:GetIdentity() return self.identity end function people:PrintInfo() print(\"object belong to people\") end --student继承people，此时是相当于将people的元表拷贝到student里面了 student = people:new() --为了避免类实例在创建的时候修改了类的成员变量，因此采用了临时表obj来作为缓冲 --毕竟Lua本身是没有Lua这个概念的，如果不采用临时Table作为缓冲，是无法把类实例和类之间的联系切断 function student:new( newName, newIdentity, newClassroom, newIndex ) obj = people:new( newName, newIdentity ) setmetatable(obj, self) --self.__index = self使得自身的属性都能被obj访问到 self.__index = self --添加成员变量 obj.classroom = newClassroom or \"unknown classroom2\" obj.index = newIndex or \"unknown index2\" return obj end --添加成员变量到子类里 function student:GetClassroom() return self.classroom end function student:GetIndex() return self.index end --重载基类的成员函数 function student:PrintInfo() print(\"object belong to student\") end print(\"startup\") temp = student:new(\"childname\", 56579887, \"classroom1st\", \"1\") --开启了下面语句之后可以发现，此时temp的数值会被temp3所影响 temp3 = student:new(\"childname3\", 4987, \"classroom3rd\", 10) baseObj =people:new(\"basename\", 110) baseObj3 =people:new(\"basename3\", 10000000) print(\"---------打印类实例的信息--------\") print(\"在子类实例中调用基类成员函数\") print(temp:GetIdentity()) print(temp:GetName()) print(\"在子类实例中调用子类成员函数\") print(temp:GetClassroom()) print(temp:GetIndex()) temp:PrintInfo() print(\"调用基类实例的成员函数\") print(baseObj:GetName()) print(baseObj:GetIdentity()) print(\"---------打印当前定义的基类与子类类型的数据--------\") print(\"以下为基类的信息\") --而name和name是在执行new函数的时候，才为其类实例追加的成员变量， --而这些成员变量在原本的people里是没有的，因而为nil，正如people = {} print(people.name) print(people.name) people:PrintInfo() print(\"以下为子类类型的信息\") --name和identity是从people继承过来的，并且，在继承的时候，通过new函数临时为其创建的，因此数值有效 print(student.name) print(student.identity) --而classroom和index是在执行new函数的时候，才为其类实例追加的成员变量， --而这些成员变量在原本的student是没有的，因而为nil，正如student = people:new{} print(student.classroom) print(student.index) student:PrintInfo() print(\"end\") --注意，在new()内，修改self里面的数值的时候，会导致类的成员变量也同时改变，因为，在Lua里面，本身是没有类这个概念的，我们只可以通过Table来模拟类似的类行为，为了绕过Lua的固有限制，我们在通过new()等函数进行类实例创建的时候，使用临时Table来存放此类的特有的成员变量以及成员变量。 --在上述代码里面，student里的classroom和index是无效数值，都为nil，在student:new()函数体内，使用了临时变量obj来存放其基类的成员变量以及成员函数，通过setmetatable(obj,self)语句，让obj拥有了student里面的成员函数以及基类的特性。而之所以需要执行student = people:new()语句，这是为了可以让student继承people的特性了，否则，所有调用了student类实例所有用到基类的方法都将无效，总而言之，这个metatable的作用有点像C++里面的虚表，专门用来定位子类实例和基类之间的成员函数以及成员变量的地址的 ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:2","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r控制Table类型的访问权限要想实现此效果，需要使用Table里面__index和__newindex变量，更多详情请看《用__index和__newindex来限制访问》，如下所示： --访问权限控制函数 function cannotModifyHp(object) local proxy = {} local mt = { __index = object, __newindex = function(k,v) if k ~= \"hp\" then object[k] = v end end } setmetatable(proxy,mt) return proxy end object = {hp = 10,age = 11} --function object.sethp(self,newhp) -- self.hp = newhp --end function object:sethp(newhp) self.hp = newhp end o = cannotModifyHp(object) o.hp = 100 --修改失效 print(o.hp) o:sethp(111) --修改失效 print(o.hp) object:sethp(100) --修改生效 print(o.hp) ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:3","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\rLua上的语法糖收集 v:name(args) 可以被解析成 v.name(v,args) 或者 v.name(self,args) 举个栗子，如下所示： object = {hp = 10,age = 11} function object.SetHp1st(self,newHp) self.hp = newHp end function object:SetHp2nd(newHp) self.hp = newHp end function funcname() body end 等效于 funcname = function() body end function table.a.b.c.funcname() body end 等效于 table.a.b.c.funcname = function() body end local function funcname() body end 等效于 local funcname; funcname = function() body end 不等效于 local funcname = function() body end哦 ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:4","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r重载运算符Lua的运算符在Lua之中，我们可以通过Metatable(元表)来重载非数值运算符，能够重载的运算符如下所示： 运算符 在Lua里的关键字 意义 + add 加法运算 - sub 减法运算 * mul 乘法运算 / div 除法运算 % mod 取模运算，获取余值 ^ pow 幂运算 – urm 一元**-**操作符 .. concat 连接操作 # len 取数据类型的长度，比如table长度等 == eq 关系运算符：相等 \u003c lt 关系运算符：小于 \u003c= le 关系运算符：小于或等于 [] index 通过下标访问Table[key]，仅用于读取数据 [] newindex 通过下标Table[key] ，仅用于修改数据，如Table[key] = value 未知 call 当Lua调用一个值时调用 以下演示了如何重载支持特定格式的表的运算符操作，如+和- --定义2个表 --a = {5, 6,10,8,69,10,\"hello\"} a = {5, 6} b = {7, 8} --用c来做Metatable c = {} --重定义加法操作 c.__add = function(op1, op2) -- 将所有元素进行配对相加 local result = {} local lenght1 = table.maxn(op1) local lenght2 = table.maxn(op2) if lenght1 == lenght2 then for index,item in ipairs(op1) do table.insert(result,op1[index]+op2[index]) end end return result -- --枚举op2的所有元素，将其插入到op1之中，相当于C++里面的重载运算符+ -- for key, item in ipairs(op2) do -- print(\"key = \"..key) -- print(\"item = \"..item) -- --将item插入到op1之中 -- table.insert(op1, item) -- end -- return op1 end c.__sub = function (op1,op2) local result = {} local lenght1 = table.maxn(op1) local lenght2 = table.maxn(op2) if lenght1 == lenght2 then for index,item in ipairs(op1) do table.insert(result,op1[index]-op2[index]) end end return result end --将a的Metatable设置为c --将__add的方法应用到类b的Table数据中 --setmetatable(a, c) setmetatable(b, c) --d现在的样子是{5,6,7,8} d = a + b --d = b + a for key1,value1 in ipairs(d) do print(value1) end --print(c.__add(a,b)[1]) --print(c.__add(a,b)[1]) e = a - b --d = b + a for key2,value2 in ipairs(e) do print(value2) end ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:5","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r和C++相比，那些常见的知识盲区 Lua没有关系操作符!=，以~=来代替，其它的倒是和C++一样 --如果a不为10的话，那么打印a if a ~= 10 then print(a) end Lua的函数体不要用{body}来包裹起来，只需要在后面添加上end即可，另外在Lua之中，if代码块不需要用(body)来包裹起来，只需要在判断之中，通过空格区分开来，然后在后面添加then即可，注意，有elseif而没有else if的语句哦，比如if exp then body end 和 elseif exp then body function IsMatchedID(oldID, newID) if oldID == newID then return true elseif oldID \u003e newID then print(\"oldID \u003e newID\") return false else print(\"oldID \u003c newID\") return false end end print(IsMatchedID(10,13)) print(IsMatchedID(10,10)) print(IsMatchedID(18,10)) 获取Table、字符串等类型的长度，不需要length()等函数来获取，直接用*#*即可 tempTable = {897,8,78,7,87,87,8,78,78,7,87,8,7} print(#tempTable) tempString = \"fadfadfadf\" print(#tempString) ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:6","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["编程语言"],"content":"\r参考资料 云风的 BLOG Lua 教程 ","date":"2017-07-13","objectID":"/posts/lua_learn_notes/:0:7","tags":["lua"],"title":"Lua学习笔记","uri":"/posts/lua_learn_notes/"},{"categories":["开源技术"],"content":"Nginx在Web服务器上应用尤其广泛，这里是本人在使用过程中的一些笔记，方便以后查阅 nginx\rhttps://github.com/nginx\rNGINX（读作：engine-x）是用于 Web 服务、反向代理、内容缓存、负载均衡、媒体流传输等场景的开源软件。NGINX 的创始人 Igor Sysoev 最初编写 NGINX 是为了解决 C10K 问题，如今，NGINX 已经成为全世界最流行的 web 服务器 ","date":"2017-07-13","objectID":"/posts/nginx_notes/:0:0","tags":["Nginx","OpenResty","负载均衡","反向代理"],"title":"Nginx笔记","uri":"/posts/nginx_notes/"},{"categories":["开源技术"],"content":"\r安装部署\rLinux本人推荐通过docker镜像来安装，方便部署和迁移，以下是通过apt安装的步骤 # 安装Nginx sudo apt update sudo apt install nginx # 添加 OpenResty 的官方仓库 sudo apt update sudo apt install -y software-properties-common sudo add-apt-repository -y ppa:openresty/ppa sudo apt update # 安装OpenResty sudo apt install -y openresty # 常用操作命令 nginx -s stop 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 nginx -s quit 平稳关闭Nginx，保存相关信息，有安排的结束web服务。 nginx -s reload 因改变了Nginx相关配置，需要重新加载配置而重载。 nginx -s reopen 重新打开日志文件。 nginx -c filename 为 Nginx 指定一个配置文件，来代替缺省的。 nginx -t 不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v 显示 nginx 的版本。 nginx -V 显示 nginx 的版本，编译器版本和配置参数。 Windows nginx download openresty download ","date":"2017-07-13","objectID":"/posts/nginx_notes/:0:1","tags":["Nginx","OpenResty","负载均衡","反向代理"],"title":"Nginx笔记","uri":"/posts/nginx_notes/"},{"categories":["开源技术"],"content":"\r常用模板配置\r反向代理 # nginx_reverse_proxy.conf #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } # 反向代理：VMware虚拟机里的web服务 http { include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 8086; server_name web.yourdomain.com; location / { proxy_pass http://192.168.183.132:8086/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } server { listen 8090; server_name admin.yourdomain.com; location / { proxy_pass http://192.168.183.132:8090/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } } 负载均衡 #nginx_load_banlancer.conf #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } # # 负载均衡：适合高并发查询服务 http { # upstream backend_servers { # # 负载均衡策略：默认轮询 # server 192.168.183.132:8086; # server 192.168.183.132:8090; # } # upstream backend_servers { # # 负载均衡策略：加权轮询 + 失败重试配置 # # 在fail_timeout时间内失败了max_fails次请求后，则认为该上游服务器不可用，然后将该服务地址踢除掉。fail_timeout时间后会再次将该服务器加入存活列表，进行重试 # server 192.168.183.132:8086 weight=3 max_fails=2 fail_timeout=60s; # server 192.168.183.132:8090 weight=2 max_fails=2 fail_timeout=60s; # } upstream backend_servers { # 负载均衡策略：最小链接 least_conn; server 192.168.183.132:8086; server 192.168.183.132:8090; } # upstream backend_servers { # # 负载均衡策略：ip哈希 # ip_hash; # server 192.168.183.132:8086; # server 192.168.183.132:8090; # } # \u003c--------------------------------------------------\u003e # 针对某个http服务进行负载均衡 server { listen 8020; server_name test.thinkshop.com; location / { proxy_pass http://backend_servers; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } # # 针对某个websocket服务进行负载均衡 # server { # listen 8030; # server_name match.yourdomain.com; # location / { # proxy_pass http://backend_servers; # proxy_http_version 1.1; # proxy_set_header Upgrade $http_upgrade; # proxy_set_header Connection \"upgrade\"; # proxy_set_header Host $host; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_set_header X-Forwarded-Proto $scheme; # } # } } ","date":"2017-07-13","objectID":"/posts/nginx_notes/:0:2","tags":["Nginx","OpenResty","负载均衡","反向代理"],"title":"Nginx笔记","uri":"/posts/nginx_notes/"},{"categories":["开源技术"],"content":"\rNginx 高可用性保证\rLinux Nginx+Keepalived(双机热备)搭建高可用负载均衡环境(HA) 备份链接 Nginx + KeepAlived高可用负载均衡集群 备用链接 Windows PanguHA,一款Windows双机热备工具 PanguFlow PanguFlow是双机热备软件PanguHA的一个子模块，它是一款功能强大的文件实时同步软件，提供了文件热备的功能 pangu-ha 个人狂想：目前Windows下，这个PanguHA工具是能够满足要求的，只是说需要付费购买授权，如果时间充足的话，可以参考Keepalived的实现，用asciinema/PowerSession-rs的思路来采用Rust自行实现一个Keepalived-rs，通过windows-rs来调用Windows api ","date":"2017-07-13","objectID":"/posts/nginx_notes/:0:3","tags":["Nginx","OpenResty","负载均衡","反向代理"],"title":"Nginx笔记","uri":"/posts/nginx_notes/"},{"categories":["开源技术"],"content":"\r高质量实战 分布式 –OpenResty+lua+Redis 实现限流与防爬虫 备用链接 ","date":"2017-07-13","objectID":"/posts/nginx_notes/:0:4","tags":["Nginx","OpenResty","负载均衡","反向代理"],"title":"Nginx笔记","uri":"/posts/nginx_notes/"},{"categories":["开源技术"],"content":"\r参考资料 OpenResty \u0026 Nginx：详细对比与部署指南 nginx官网 Nginx 入门学习笔记 Nginx 教程 《Nginx应用与运维实战》王小东 ","date":"2017-07-13","objectID":"/posts/nginx_notes/:1:0","tags":["Nginx","OpenResty","负载均衡","反向代理"],"title":"Nginx笔记","uri":"/posts/nginx_notes/"},{"categories":["技术选型"],"content":"当摩尔定律的影响力逐渐消退，我们有必要回顾那段硬件资源受限、成本高昂的岁月。在那个时代，开发者们不得不发挥创造力，深入挖掘机器的潜力，精心优化任务调度，从而孕育出一系列高效的并发处理策略，这里，主要是探讨下主流的Actor模型和CSP模型 核心内容是来自《Actor模型和CSP模型的区别》\rhttp://www.jdon.com/concurrent/actor-csp.html\r","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:0","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["技术选型"],"content":"\rActor模型在Actor模型中，主角是Actor，类似一种worker，Actor彼此之间直接发送消息，不需要经过什么中介，消息是异步发送和处理的： Actor模型描述了一组为了避免并发编程的常见问题的公理: 所有Actor状态是Actor本地的，外部无法访问。 Actor必须只有通过消息传递进行通信。 一个Actor可以响应消息:推出新Actor，改变其内部状态，或将消息发送到一个或多个其他参与者。 Actor可能会堵塞自己，但Actor不应该堵塞它运行的线程。 更多可见Actor模型专题 ","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:1","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["技术选型"],"content":"\rChannel模型Channel模型中，worker之间不直接彼此联系，而是通过不同channel进行消息发布和侦听。消息的发送者和接收者之间通过Channel松耦合，发送者不知道自己消息被哪个接收者消费了，接收者也不知道是哪个发送者发送的消息。 Go语言的CSP模型是由协程Goroutine与通道Channel实现： Go协程goroutine 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。 通道channel 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。 ","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:2","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["技术选型"],"content":"\rActor模型和CSP区别Actor模型和CSP区别图如下： Actor之间直接通讯，而CSP是通过Channel通讯，在耦合度上两者是有区别的，后者更加松耦合。 同时，它们都是描述独立的流程通过消息传递进行通信。主要的区别在于：在CSP消息交换是同步的(即两个流程的执行\"接触点\"的，在此他们交换消息)，而Actor模型是完全解耦的，可以在任意的时间将消息发送给任何未经证实的接受者。由于Actor享有更大的相互独立，因为它可以根据自己的状态选择处理哪个传入消息，自主性更大些。 在Go语言中为了不堵塞流程，程序员必须检查不同的传入消息，以便预见确保正确的顺序。CSP好处是Channel不需要缓冲消息，而Actor理论上需要一个无限大小的邮箱作为消息缓冲。 ","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:3","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["技术选型"],"content":"\r发展现状 Actor模型最初由Erlang推出，后已被多种编程语言实现了，其中c语言里面，出名的有云风大大维护的skynet，采用c/lua混合开发，而c++有caf，java有akka等等 CSP模型也是如此，目前在Golang这里最为出名 现如今，在游戏服务端开发领域里，Actor模型在c/c++/lua、erlang这几块发展得红红火火，而CSP模型则以Golang技术栈马首是瞻 ","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:4","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["技术选型"],"content":"\r参考资料 《Actor模型和CSP模型的区别》 《为什么Actor模型是高并发事务的终极解决方案？》 《Actors编程模型》 《The Actor Model (everything you wanted to know…)》 《ActorLite: 一个轻量级Actor模型实现》 《Comparison between 4 actor frameworks》 《一个轻量级Actor并发框架的c++实现， libgsc(Game Server Communication Library)》 《详解Theron通过Actor模型解决C++并发编程的一种思维》 The C++ Actor Framework官网 吐槽近十多年来，在摩尔定律大抵还生效的时期里，App开发采取的技术方案越来越耗机器资源了，达到了一种不可理喻的程度，比如有些App开发者采用了各种Web App开发策略、桌面软件开发者采用了类似Electron框架来进行客户端开发等，导致网上许多功能简单的程序，安装包体积巨大，这实际是对机器资源的一种巨大浪费，怀念以前的小巧精致的App 很多方案是跨平台需求带进来的妥协，好在，有开发者顶不住Electron巨大的分发体积，搞出了tauri方案，而在原生跨平台开发领域里，Google推出了Flutter，发展势头也非常好 ","date":"2017-07-13","objectID":"/posts/thinking_about_the_concurrency_model/:0:5","tags":["actor模型","csp模型","并发模型"],"title":"关于并发模型的思考","uri":"/posts/thinking_about_the_concurrency_model/"},{"categories":["代码规范"],"content":"\rGoogle 开源项目风格指南\rhttps://zh-google-styleguide.readthedocs.io\r","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:0:0","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r前言在c++这个大联盟里，有许许多多领导组织，微软、Google、IBM，还有国内各个大厂内部因地制宜定下的各种代码规范，而在我目前的职业生涯里，先后经历了两种c++代码规范洗礼，其实项目内部具体用什么代码规范，一般都由leader定下的，新加入团队的成员理应遵循已有的代码规范，保证团队工程风格的一致性 但是，作为开发大军里的一员，除开企业内的团队开发，我们私下也会有自己的创造欲望，去捣弄自己的小项目，那么在这个时候，就需要定下一个从一而终的代码规范了，如果机遇一到，拉到融资或者和其它小伙伴一起创业，它就能作为团队规范的一部分了 目前在业界之内，谷歌的开源氛围是较为浓厚的，它提供了许多深受业界认可的开源项目，比如chromium、grpc、protobuf、gson……，还往业界输出了它的《Google 开源项目风格指南》，而之前自己在c++学习的过程中，也用到了其中一些开源库 而刚毕业那会，由于做的是windows下的win32软件开发，因此最开始用的是mfc那套规范；后续进了游戏行业，一直从事游戏服务端开发，此时起就采用google的代码规范了。现今反思了一些东西，自己要想长远发展的话，采用谷歌这套会更好些 ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:1:0","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r命名规范","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:2:0","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r通用命名规则 函数命名，变量命名，文件命名要有描述性；少用缩写。 尽可能给有描述性的命名，别心疼空间，毕竟让代码易于新读者理解很重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个字母来缩写单词。 //示例： int price_count_reader; // 无缩写 int num_errors; // “num” 本来就很常见 int num_dns_connections; // 人人都知道 “DNS” 是啥 //反例： int n; // 莫名其妙。 int nerr; // 怪缩写。 int n_comp_conns; // 怪缩写。 int wgc_connections; // 只有贵团队知道是啥意思。 int pc_reader; // \"pc\" 有太多可能的解释了。 int cstmr_id; // 有删减若干字母。 ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:2:1","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r文件命名 文件名要全部小写, 可以包含下划线 (_) 或连字符 (-). 按项目约定来. 如果并没有项目约定，_ 更好。接受的文件命名: my_useful_class.cc my-useful-class.cc myusefulclass.cc muusefulclass_test.cc // _unittest 和 _regtest 已弃用。 C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾，参见:ref:self-contained headers。 不要使用已经存在于 /usr/include 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如db.h. 通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好. 定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar. 内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中. ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:2:2","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r类型命名 类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum. 所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举 —— 均使用相同约定. 例如: // classes and structs class UrlTable { ... class UrlTableTester { ... struct UrlTableProperties { ... // typedefs typedef hash_map\u003cUrlTableProperties *, string\u003e PropertiesMap; // enums enum UrlTableErrors { ... ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:2:3","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r变量命名 变量名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用，如::a_local_variable, a_struct_data_member, a_class_data_member_. 【普通变量命名】: //举例: string table_name; // 可 - 用下划线。 string tablename; // 可 - 全小写。 //反例: string tableName; // 差 - 混合大小写。 【类数据成员】： 不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样, 但要接下划线。 class TableInfo { private: string table_name_; // 可 - 尾后加下划线。 string tablename_; // 可。 static Pool\u003cTableInfo\u003e* pool_; // 可。 }; 【结构体变量】: 不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样, 不用像类那样接下划线: struct UrlTableProperties { string name; int num_entries; } 【全局变量】: 对全局变量没有特别要求, 少用就好, 但如果你要用, 可以用 g_ 或其它标志作为前缀, 以便更好的区分局部变量. 【常量命名】 在全局或类里的常量名称前加 k: kDaysInAWeek. 且除去开头的 k之外每个单词开头字母均大写。 所有编译时常量, 无论是局部的, 全局的还是类中的, 和其他变量稍微区别一下. 这规则适用于编译时的局部作用域常量，不过要按变量规则来命名也可以。 k后接大写字母开头的单词: const int kDaysInAWeek = 7; 【函数命名】 常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable(), 自定义函数不能与系统或库函数同名. [常规函数]: 函数名的每个单词首字母大写, 没有下划线。 如果您的某函数出错时就要直接 crash, 那么就在函数名加上 OrDie. 但这函数本身必须集成在产品代码里，且平时也可能会出错。 AddTableEntry() DeleteUrl() OpenFileOrDie() [取值和设值函数]: 取值（Accessors）和设值（Mutators）函数要与存取的变量名匹配. 这儿摘录一个类,num_entries_ 是该类的实例变量: class MyClass { public: ... int GetNumEntries() const { return num_entries_; } void SetNumEntries (int num_entries) { num_entries_ = num_entries; } private: int num_entries_; }; 其它非常短小的内联函数名也可以用小写字母, 例如. 如果你在循环中调用这样的函数甚至都不用缓存其返回值, 小写命名就可以接受. 【名字空间命名】 名字空间用小写字母命名. 【枚举命名】 枚举的命名应当和常量或宏一致: kEnumName 或是 ENUM_NAME. 单独的枚举值应该优先采用常量的命名方式. 但宏方式的命名也可以接受. 枚举名 UrlTableErrors(以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式. enum UrlTableErrors { kOK = 0, kErrorOutOfMemory, kErrorMalformedInput, }; enum AlternateUrlTableErrors { OK = 0, OUT_OF_MEMORY = 1, MALFORMED_INPUT = 2, }; 【宏命名】 你并不打算使用宏 \u003cpreprocessor-macros\u003e, 对吧? 如果你一定要用, 像这样命名:MY_MACRO_THAT_SCARES_SMALL_CHILDREN. 通常不应该使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线: #define ROUND(x) ... #define PI_ROUNDED 3.0 【命名规则的特例】 [X]如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略. ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:2:4","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r注释规范这块倾向使用doxgen提供的注释规范，因为如果后续需要自动生成一份开发文档，这个就比较方便 不过，注释固然很重要, 但好的代码本身应该是自文档化的，有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字 【注释风格】 使用 // 或 /* */, 统一就好 // 或 /* */ 都可以; 但 // 更常用些 要在如何注释及注释风格上确保统一 【文件注释】 .h 文件要对所声明的类的功能和用法作简单说明，如果可以的话，可以在文件头上罗列一份feature_list或者todo_list .cc 文件通常包含了更多的实现细节或算法技巧讨论 如果你感觉这些实现细节或算法技巧讨论对于理解.h文件有帮助, 可以该注释挪到.h, 并在.cc中指出文档在.h中 不要简单的在.h和.cc间复制注释. 这种偏离了注释的实际意义 文件头举例如下: /***************************************************************************** * @file auto_register_factory.h * @brief 可注册的工厂类模板 * @note * C++反射机制的一种实现，基于类行为抽象而成 *****************************************************************************/ 【类注释】 每个类的定义都要附带一份注释, 描述类的功能和用法. 举例如下: /** * @class CSigleRegisterFactory * @brief 一个支持自动注册的工厂类模板 * @note * 注意，如果TKey是自定义数据类型，那么请重载其关系运算符哦， * 具体看std::map的条件，通常仅需要重载运算符“\u003c”，详情请看 * https://msdn.microsoft.com/ZH-CN/library/s44w4h2s(v=VS.100,d=hv.2).aspx * 在gcc下编译可能遇到的问题：http://blog.csdn.net/pb1995/article/details/49532285 * 仅仅支持一对一的模式 */ template\u003ctypename TKey, typename TBase\u003e class CSingleRegisteredFactory { ... }; 【函数注释】 函数声明处注释描述函数功能，定义处描述函数实现 [函数声明]: 注释位于声明之前, 对函数功能及用法进行描述. 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情 函数声明处注释的内容: 函数的输入输出. 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数. 如果函数分配了空间, 需要由调用者释放. 参数是否可以为 NULL. 是否存在函数使用上的性能隐患. 如果函数是可重入的, 其同步前提是什么? 使用brief、param、return、note等来描述具体的注释块 举例如下: /** * @brief: 将某类注册到工厂类实例之中 * @param[in] TKey Key 某类在外部检索时所用到的条件，通常采用字符串或枚举等类型 * @param[in|out] IForwarder\u003cTBase\u003e* pobj 待注册到工厂类实例的基类指针，自动跳过空指针 * @param[in] bool bIsOverWrite 如果为true，则重新注册此类，否则，直接释放待注册的基类指针 * @return 无 * @note * 本类会自动管理所有想要注册到本类工厂的基类指针，因此需要对重复注册的类指针自动进行释放 */ void RegisterFactory(TKey key, ImpForwarder *ptr_obj, bool is_overWrite = false) 但也要避免啰啰嗦嗦, 或做些显而易见的说明. 下面的注释就没有必要加上 “returns false otherwise”, 因为已经暗含其中了: // Returns true if the table cannot hold any more entries. bool IsTableFull(); 注释构造/析构函数时, 切记读代码的人知道构造/析构函数是干啥的, 所以 “destroys this object” 这样的注释是没有意义的. 注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的. [函数定义]: 每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要. 不要 从 .h 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上. 【变量注释】 通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明. [类数据成员]: 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明. 比如: private: // Keeps track of the total number of entries in the table. // Used to ensure we do not go over the limit. -1 means // that we don't yet know how many entries the table has. int num_total_entries_; [全局变量]: 和数据成员一样, 所有全局变量也要注释说明含义及用途. 比如: // The total number of tests cases that we run through in this regression test. const int kNumTestCases = 6; 【实现注释】 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释. [代码前注释]: 巧妙或复杂的代码段前要加注释. 比如: // Divide result by two, taking into account that x // contains the carry from the add. for (int i = 0; i \u003c result-\u003esize(); i++) { x = (x \u003c\u003c 8) + (*result)[i]; (*result)[i] = x \u003e\u003e 1; x \u0026= 1; } [行注释]: 比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如: // If we have enough memory, mmap the data portion too. mmap_budget = max\u003cint64\u003e(0, mmap_budget - index_-\u003elength()); if (mmap_budget \u003e= data_size_ \u0026\u0026 !MmapData(mmap_chunk_bytes, mlock)) return; // Error already logged. 注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志. 如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性: DoSomething(); // Comment here so the comments line up. DoSomethingElseThatIsLonger(); // Comment here so there are two spaces between // the code and the comment. { // One space before comment when opening a new scope is allowed, // thus the comment lines up with the following comments and code. DoSomethingElse(); // Two spaces before line comments normally. } NULL, true/false, 1, 2, 3...: 向函数传入 NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意. 例如, 对比: bool success = CalculateSomething(interesting_value, 10, false, NULL); // What are these arguments?? 和: bool success = CalculateSomething(interesting_value, 10, // Default base value. false, // Not the first time we're calling this. NULL); // No callback. 或使用常量或描述性变量: const int kDefaultBase","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:3:0","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["代码规范"],"content":"\r参考资料 Google 开源项目风格指南 - C++风格指南 Google C++ Style Guide ","date":"2017-07-10","objectID":"/posts/cplusplus_style_guide/:4:0","tags":["c++ style","code style","c++代码风格"],"title":"C++ 代码规范","uri":"/posts/cplusplus_style_guide/"},{"categories":["自述"],"content":"\r关于我\r与Bug兄打交道良久~ o(￣▽￣)o熟悉VS、VSCode、Vim、Idea、Sublime等软件的安装/卸载技巧，掌握C/C++、Lua、Erlang、Python、JavaScript等单词的各种拼写方式 世界那么大，总想去看看QAQ希望足迹可以遍布大江南北，目前只是到过广西北海、湖南岳麓书院、张家界、广东清远古龙峡、杭州、苏州、南京、厦门等地方，出国只游过泰国，想想啥时候可以组队去趟日本溜达下，果然还是太弱鸡了23333 杂食的音乐路人甲音乐无国界啦，本人尤爱中国风，喜欢在KTV里鬼哭狼嚎O(∩_∩)O 挂念着小霸王、街机的游戏爱好者OMG早前喜欢在模拟器上玩玩拳皇、热血格斗、风卷残云什么的，不过现在也配上了Switch和Quest2了，玩得范围也更广些，手游上目前比较喜欢决斗链接、荒野乱斗啦 关于本博客目前本人私下会用到好几个笔记/博客工具，主要如下： Hexo=\u003eHugo：主要做对外分享的 之所以转到Hugo是因为Hexo那边的Npm包依赖太重了，本人多台机器上复原发布环境过于麻烦（本人Hack了Hexo官网的主题），遂改成了Hugo，并且修改了Github Pages上的设置，详情参考 这里 amWiki：更多用于记录自己工作上的一些笔记 因为之前本人特意为它开发了一款amWikiForVSCode，一直用到现在，也习惯了 Logseq：这个是新入手的笔记工具，用来作为OKR管理工具和ToDo管理工具 因为之前做年度总结的时候，苦于之前的记录过于分散，此工具的双向链接解决了这个问题，并且还提供了一个知识图谱，刚好解决了这个问题 至于为啥不再使用有道云笔记，这是因为还在读书那会，不幸遇到了一次新旧版本有道云笔记在进行跨设备数据同步时，目录层级丢失以及大量笔记找不回的问题，一直对此心有戚戚，现在更偏好于自己管理自己的数据，以避免类似的事情发生 ","date":"2016-06-18","objectID":"/abouts/about_me/:0:0","tags":["自述"],"title":"争取做个懂生活的IT人","uri":"/abouts/about_me/"},{"categories":["自述"],"content":"\r前进四 程序 = 算法 + 数据结构 软件 = 程序 + 软件工程 软件公司 = 软件 + 商业模式 ","date":"2016-06-18","objectID":"/abouts/about_me/:1:0","tags":["自述"],"title":"争取做个懂生活的IT人","uri":"/abouts/about_me/"},{"categories":["开发技巧"],"content":"这里整理了可能会用到的Windows环境变量，方便查阅 Windows环境变量\rhttps://learn.microsoft.com/zh-cn/windows/win32/procthread/environment-variables\r环境变量 含义 例子 %USERPROFILE% 列出当前用户Profile文件位置 C:\\Users用户名 %APPDATA% 列出应用程序数据的默认存放位置 C:\\Users\\用户名\\AppData\\Roaming %LOCALAPPDATA% 本地用户目录 C:\\Users\\用户名\\AppData\\Local %PATH% 列出了可执行文件的搜索路径 单元格 %CD% 列出当前目录 %ALLUSERSPROFILE% 列出所有用户Profile文件位置 C:\\ProgramData %COMMONPROGRAMFILES% 列出了常用文件的文件夹路径 C:\\Program Files\\Common Files %COMMONPROGRAMFILES(x86)% 列出了常用文件的文件夹路径 C:\\Program Files (x86)\\Common Files %COMSPEC% 列出了可执行命令外壳（命令处理程序）的路径 C:\\Windows\\System32\\cmd.exe %HOMEDRIVE% 列出与用户主目录所在的驱动器盘符 C:\\ %SYSTEMDRIVE% 列出了Windows启动目录所在驱动器 C:\\ %HOMEPATH% 列出用户主目录的完整路径 C:\\Users\\用户名 %PROGRAMDATA% 列出了ProgramData文件夹的路径 C:\\ProgramData %PROGRAMFILES% 列出了ProgramFiles文件夹的路径 C:\\Program Files %PROGRAMFILES(X86)% 列出了ProgramFiles(X86)文件夹的路径 C:\\Program Files (x86) %PUBLIC% C:\\Users\\Public %SYSTEMROOT% 列出了Windows启动目录的位置 C:\\Windows %TEMP% 列出了当前登录的用户可用应用程序的默认临时目录 C:\\Users\\用户名\\AppData\\LocalTemp %TMP% 列出了当前登录的用户可用应用程序的默认临时目录 C:\\Users\\用户名\\AppData\\LocalTemp %WINDIR% 列出操作系统目录的位置 C:\\Windows %OS% 列出操作系统的名字 WindowsXP和Windows2000列为Windows_NT. %PATHEXT% 列出操作系统认为可被执行的文件扩展名 .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC %RANDOM% 列出界于0和32767之间的随机十进制数 [0, 32767] ","date":"2016-03-03","objectID":"/posts/windows_env_variants/:0:0","tags":["Windows环境变量"],"title":"Windows系统环境变量","uri":"/posts/windows_env_variants/"},{"categories":["开发技巧"],"content":"\r一些所谓绿色包的制作思路提供一个设置应用环境变量的脚本(一般命名为set_app_env.bat)，所有关联部分都采用相对路径来设置，然后再提供一个启动应用脚本(一般命名为run_app.bat)，然后将它们整体打包分发，现在各种AI应用一键运行包都是类似思路实现的 # set_app_env.bat @echo off set mine_root=%~dp0 set USERPROFILE=%mine_root%run_dir\\User set APPDATA=%mine_root%run_dir\\User\\AppData\\Roaming set app_path=%mine_root%run_dir\\app_env set path=%app_path%;%app_path%\\Scripts;%path% # run_app.bat @echo off call \"%~dp0set_app_env.bat\" ::进入当前bat的所在目录 cd /d %~dp0 # 启动一个包含某些环境变量的命令行窗口 call start cmd %1 /k # # 启动某个python应用 # python %~dp0web_ui.py --f %1 ","date":"2016-03-03","objectID":"/posts/windows_env_variants/:0:1","tags":["Windows环境变量"],"title":"Windows系统环境变量","uri":"/posts/windows_env_variants/"},{"categories":["版本管理"],"content":"在涉及到多工种协作时，大部分开发团队采用svn作为版本管理工具，这里记录了一些本人遇到的svn的疑难杂症和相关解决方案 ","date":"2016-03-02","objectID":"/posts/git_and_svn_except_notes/:0:0","tags":["svn","疑难杂症"],"title":"Git\u0026SVN爬坑","uri":"/posts/git_and_svn_except_notes/"},{"categories":["版本管理"],"content":"\rFAQ\r遇到了Failed to run the WC DB work queue associated报错日志打开msys2，然后使用pacman -S sqlite3安装sqlite3.exe，进入msys2，然后执行sqlite3 .svn/wc.db \"delete from work_queue\"清空 svn 的工作队列 遇到了svn 被锁住，报错日志： Can’t revert without reverting children进入到svn的顶级目录下，然后执行svn revert . --depth infinity即可 Github超过100M的大文件上传，报错日志： remote: error: File XXX/XXX/XXX is 234 MB; this exceeds GitHub‘s file size limit of 100.00 MB cd git-repo # 设置Git LFS git lfs install # 追踪大文件的类型，此时会生成一个gitattributes文件 git lfs track \"*.zip\" # 将大文件添加到版本库中 git add resources.zip git commit -m \"提交.zip大文件\" # 推送文件到远程仓库 git push ","date":"2016-03-02","objectID":"/posts/git_and_svn_except_notes/:1:0","tags":["svn","疑难杂症"],"title":"Git\u0026SVN爬坑","uri":"/posts/git_and_svn_except_notes/"}]