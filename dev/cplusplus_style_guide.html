<!DOCTYPE html>
<html lang="zh-cn">
<head prefix="og: http://ogp.me/ns#">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <title>C++ 代码规范 | YXZ's Blog</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="https://yaoxuanzhi.github.io/dev/cplusplus_style_guide.html">
  <!-- Alternative links -->
  
    
      <link rel="alternative" hreflang="zh-cn" href="https://yaoxuanzhi.github.io/dev/cplusplus_style_guide.html">
    
  
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/icon/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icon/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icon/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icon/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icon/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icon/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icon/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icon/apple-touch-icon-152x152.png">
  <link rel="icon" type="image/png" href="/icon/favicon-196x196.png" sizes="196x196">
  <link rel="icon" type="image/png" href="/icon/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="/icon/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/icon/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/icon/favicon-32x32.png" sizes="32x32">
  <meta name="msapplication-TileColor" content="#2f83cd">
  <meta name="msapplication-TileImage" content="/icon/mstile-144x144.png">
  <meta name="generator" content="Hexo 3.8.0">
  <!-- CSS -->
  <!-- build:css build/css/navy.css -->
  <link rel="stylesheet" href="/css/navy.css">
  <!-- endbuild -->
  <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css">
  <!-- RSS -->
  <link rel="alternate" href="/atom.xml" title="YXZ's Blog">
  <!-- Open Graph -->
  <meta name="description" content="前言在c++这个大联盟里，有许许多多领导组织，微软、Google、IBM，还有国内各个大厂内部因地制宜定下的各种代码规范，而在我目前的职业生涯里，先后经历了两种c++代码规范洗礼，其实项目内部具体用什么代码规范，一般都由leader定下的，新加入团队的成员理应遵循已有的代码规范，保证团队工程风格的一致性 但是，作为开发大军里的一员，除开企业内的团队开发，我们私下也会有自己的创造欲望，去捣弄自己的小">
<meta property="og:type" content="website">
<meta property="og:title" content="C++ 代码规范">
<meta property="og:url" content="https://yaoxuanzhi.github.io/dev/cplusplus_style_guide.html">
<meta property="og:site_name" content="YXZ&#39;s Blog">
<meta property="og:description" content="前言在c++这个大联盟里，有许许多多领导组织，微软、Google、IBM，还有国内各个大厂内部因地制宜定下的各种代码规范，而在我目前的职业生涯里，先后经历了两种c++代码规范洗礼，其实项目内部具体用什么代码规范，一般都由leader定下的，新加入团队的成员理应遵循已有的代码规范，保证团队工程风格的一致性 但是，作为开发大军里的一员，除开企业内的团队开发，我们私下也会有自己的创造欲望，去捣弄自己的小">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://yaoxuanzhi.github.io/assets/2021-04-27/google_cplusplus_style_guide.png">
<meta property="og:updated_time" content="2021-04-27T05:04:02.567Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 代码规范">
<meta name="twitter:description" content="前言在c++这个大联盟里，有许许多多领导组织，微软、Google、IBM，还有国内各个大厂内部因地制宜定下的各种代码规范，而在我目前的职业生涯里，先后经历了两种c++代码规范洗礼，其实项目内部具体用什么代码规范，一般都由leader定下的，新加入团队的成员理应遵循已有的代码规范，保证团队工程风格的一致性 但是，作为开发大军里的一员，除开企业内的团队开发，我们私下也会有自己的创造欲望，去捣弄自己的小">
<meta name="twitter:image" content="https://yaoxuanzhi.github.io/assets/2021-04-27/google_cplusplus_style_guide.png">
  <!-- Google Analytics --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <h1 id="logo-wrap">
      <a href="/" id="logo">YXZ's Blog</a>
    </h1>
    <nav id="main-nav">
      <a href="/news/" class="main-nav-link">随笔</a><a href="/dev/" class="main-nav-link">开发</a><a href="/open_source/" class="main-nav-link">开源</a><a href="/tool/" class="main-nav-link">工具</a><a href="/about/" class="main-nav-link">关于我</a>
    </nav>
    <div id="lang-select-wrap">
      <label id="lang-select-label"><i class="fa fa-globe"></i><span>简体中文</span></label>
      <select id="lang-select" data-canonical="dev/cplusplus_style_guide.html">
        
          <option value="zh-cn" selected>简体中文</option>
        
      </select>
    </div>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div id="content" class="wrapper">
    <div id="content-inner">
      <article class="article-container" itemscope itemtype="http://schema.org/Article">
        <div class="article-inner">
          <div class="article">
            <div class="inner">
              <header class="article-header">
                <h1 class="article-title" itemprop="name">C++ 代码规范</h1>
                <a href="https://github.com/YaoXuanZhi/mine-site/edit/master/source/dev/cplusplus_style_guide.md" class="article-edit-link" title="改进本文"><i class="fa fa-pencil"></i></a>
              </header>
              
                <footer class="article-footer">
                  <time class="article-footer-updated">发表于：2017-07-09</time>
                </footer>
              
              <div class="article-content" itemprop="articleBody">
                <h2 id="前言" class="article-heading"><a href="#前言" class="headerlink" title="前言"></a>前言<a class="article-anchor" href="#前言" aria-hidden="true"></a></h2><p>在c++这个大联盟里，有许许多多领导组织，微软、Google、IBM，还有国内各个大厂内部因地制宜定下的各种代码规范，而在我目前的职业生涯里，先后经历了两种c++代码规范洗礼，其实项目内部具体用什么代码规范，一般都由leader定下的，新加入团队的成员理应遵循已有的代码规范，保证团队工程风格的一致性</p>
<p>但是，作为开发大军里的一员，除开企业内的团队开发，我们私下也会有自己的创造欲望，去捣弄自己的小项目，那么在这个时候，就需要定下一个从一而终的代码规范了，如果机遇一到，拉到融资或者和其它小伙伴一起创业，它就能作为团队规范的一部分了</p>
<p>目前在业界之内，谷歌的开源氛围是较为浓厚的，它提供了许多深受业界认可的开源项目，比如chromium、grpc、protobuf、gson……，还往业界输出了它的<a href="https://zh-google-styleguide.readthedocs.io" target="_blank" rel="noopener">《Google 开源项目风格指南》</a>，而之前自己在c++学习的过程中，也用到了其中一些开源库</p>
<p>而刚毕业那会，由于做的是windows下的win32软件开发，因此最开始用的是mfc那套规范；后续进了游戏行业，一直从事游戏服务端开发，此时起就采用google的代码规范了。现今反思了一些东西，自己要想长远发展的话，采用谷歌这套会更好些</p>
<hr>
<h2 id="命名规范" class="article-heading"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范<a class="article-anchor" href="#命名规范" aria-hidden="true"></a></h2><h3 id="通用命名规则" class="article-heading"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则<a class="article-anchor" href="#通用命名规则" aria-hidden="true"></a></h3><ul>
<li>函数命名，变量命名，文件命名要有描述性；少用缩写。</li>
<li>尽可能给有描述性的命名，别心疼空间，毕竟让代码易于新读者理解很重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个字母来缩写单词。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//示例：</span><br><span class="hljs-keyword">int</span> price_count_reader;    <span class="hljs-comment">// 无缩写</span><br><span class="hljs-keyword">int</span> num_errors;            <span class="hljs-comment">// “num” 本来就很常见</span><br><span class="hljs-keyword">int</span> num_dns_connections;   <span class="hljs-comment">// 人人都知道 “DNS” 是啥</span><br><br><span class="hljs-comment">//反例：</span><br><span class="hljs-keyword">int</span> n;                     <span class="hljs-comment">// 莫名其妙。</span><br><span class="hljs-keyword">int</span> nerr;                  <span class="hljs-comment">// 怪缩写。</span><br><span class="hljs-keyword">int</span> n_comp_conns;          <span class="hljs-comment">// 怪缩写。</span><br><span class="hljs-keyword">int</span> wgc_connections;       <span class="hljs-comment">// 只有贵团队知道是啥意思。</span><br><span class="hljs-keyword">int</span> pc_reader;             <span class="hljs-comment">// "pc" 有太多可能的解释了。</span><br><span class="hljs-keyword">int</span> cstmr_id;              <span class="hljs-comment">// 有删减若干字母。</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="文件命名" class="article-heading"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名<a class="article-anchor" href="#文件命名" aria-hidden="true"></a></h3><ul>
<li><p>文件名要全部小写, 可以包含下划线 <code>(_)</code> 或连字符 <code>(-)</code>. 按项目约定来. 如果并没有项目约定，<code>_</code> 更好。接受的文件命名:</p>
<ul>
<li>my_useful_class.cc</li>
<li>my-useful-class.cc</li>
<li>myusefulclass.cc</li>
<li>muusefulclass_test.cc // <code>_unittest</code> 和 <code>_regtest</code> 已弃用。</li>
</ul>
</li>
<li><p>C++ 文件要以 <strong>.cc</strong> 结尾, 头文件以 <strong>.h</strong> 结尾. 专门插入文本的文件则以 <strong>.inc</strong> 结尾，参见:<code>ref:self-contained headers</code>。</p>
</li>
<li>不要使用已经存在于 <code>/usr/include</code> 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如<code>db.h</code>.</li>
<li>通常应尽量让文件名更加明确. <code>http_server_logs.h</code> 就比 <code>logs.h</code> 要好. 定义类时文件名一般成对出现, 如 <code>foo_bar.h</code> 和 <code>foo_bar.cc</code>, 对应于类 <code>FooBar</code>.</li>
<li>内联函数必须放在 <code>.h</code> 文件中. 如果内联函数比较短, 就直接放在 <code>.h</code> 中.</li>
</ul>
<h3 id="类型命名" class="article-heading"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名<a class="article-anchor" href="#类型命名" aria-hidden="true"></a></h3><ul>
<li>类型名称的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</li>
<li>所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举 —— 均使用相同约定. 例如:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// classes and structs</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UrlTable</span> &#123;</span> ...<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UrlTableTester</span> &#123;</span> ...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UrlTableProperties</span> &#123;</span> ...<br><br><span class="hljs-comment">// typedefs</span><br><span class="hljs-keyword">typedef</span> hash_map&lt;UrlTableProperties *, <span class="hljs-built_in">string</span>&gt; PropertiesMap;<br><br><span class="hljs-comment">// enums</span><br><span class="hljs-keyword">enum</span> UrlTableErrors &#123; ...<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="变量命名" class="article-heading"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名<a class="article-anchor" href="#变量命名" aria-hidden="true"></a></h3><ul>
<li>变量名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用，如<code>::a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>.</li>
</ul>
<ol>
<li><p>【普通变量命名】:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//举例:</span><br><span class="hljs-built_in">string</span> table_name;  <span class="hljs-comment">// 可 - 用下划线。</span><br><span class="hljs-built_in">string</span> tablename;   <span class="hljs-comment">// 可 - 全小写。</span><br><br><span class="hljs-comment">//反例:</span><br><span class="hljs-built_in">string</span> tableName;   <span class="hljs-comment">// 差 - 混合大小写。</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>【类数据成员】：<br>不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样, <strong>但要接下划线</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TableInfo</span> <br>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">string</span> table_name_;             <span class="hljs-comment">// 可 - 尾后加下划线。</span><br>    <span class="hljs-built_in">string</span> tablename_;              <span class="hljs-comment">// 可。</span><br>    <span class="hljs-keyword">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="hljs-comment">// 可。</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【结构体变量】:<br>不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样, <strong>不用像类那样接下划线</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UrlTableProperties</span> &#123;</span><br>    <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">int</span> num_entries;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【全局变量】:<br>对全局变量没有特别要求, 少用就好, 但如果你要用, 可以用 <code>g_</code> 或其它标志作为前缀, 以便更好的区分局部变量.</p>
</li>
<li><p>【常量命名】<br>在全局或类里的常量名称前加 <code>k</code>: <code>kDaysInAWeek</code>. 且除去开头的 <code>k</code>之外每个单词开头字母均大写。<br>所有编译时常量, 无论是局部的, 全局的还是类中的, 和其他变量稍微区别一下. 这规则适用于编译时的局部作用域常量，不过要按变量规则来命名也可以。<br> <code>k</code>后接大写字母开头的单词:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> kDaysInAWeek = <span class="hljs-number">7</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【函数命名】<br>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyExcitingFunction(),<br>MyExcitingMethod(), <br>my_exciting_member_variable(), <br>set_my_exciting_member_variable(),<br>自定义函数不能与系统或库函数同名.<br></code></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>[常规函数]:<br>函数名的<strong>每个单词首字母大写</strong>, <strong>没有下划线</strong>。<br>如果您的某函数出错时就要直接 <code>crash</code>, 那么就在函数名加上 <code>OrDie</code>. 但这函数本身必须集成在产品代码里，且平时也可能会出错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">AddTableEntry()<br>DeleteUrl()<br>OpenFileOrDie()<br></code></pre></td></tr></table></figure>
</li>
<li><p>[取值和设值函数]:<br>取值（<strong>Accessors</strong>）和设值（<strong>Mutators</strong>）函数要与存取的变量名匹配. 这儿摘录一个类,<code>num_entries_</code> 是该类的实例变量:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetNumEntries</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> num_entries_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetNumEntries</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> num_entries)</span> </span>&#123; num_entries_ = num_entries; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> num_entries_;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>其它非常短小的内联函数名也可以用小写字母, 例如. 如果你在循环中调用这样的函数甚至都不用缓存其返回值, 小写命名就可以接受.</p>
</li>
</ul>
<ol start="7">
<li>【名字空间命名】</li>
</ol>
<ul>
<li>名字空间用小写字母命名.</li>
</ul>
<ol start="8">
<li>【枚举命名】</li>
</ol>
<ul>
<li>枚举的命名应当和<code>常量</code>或<code>宏</code>一致: kEnumName 或是 ENUM_NAME.</li>
<li>单独的枚举值应该优先采用<code>常量</code>的命名方式. 但<code>宏</code>方式的命名也可以接受. </li>
<li>枚举名 UrlTableErrors(以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> UrlTableErrors &#123;<br>    kOK = <span class="hljs-number">0</span>,<br>    kErrorOutOfMemory,<br>    kErrorMalformedInput,<br>&#125;;<br><span class="hljs-keyword">enum</span> AlternateUrlTableErrors &#123;<br>    OK = <span class="hljs-number">0</span>,<br>    OUT_OF_MEMORY = <span class="hljs-number">1</span>,<br>    MALFORMED_INPUT = <span class="hljs-number">2</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ol start="9">
<li><p>【宏命名】<br>你并不打算使用宏 <code>&lt;preprocessor-macros&gt;</code>, 对吧? 如果你一定要用, 像这样命名:<code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.<br>通常<code>不应该</code>使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ROUND(x) ...</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI_ROUNDED 3.0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>【命名规则的特例】<br>[X]如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p>
</li>
</ol>
<h2 id="注释规范" class="article-heading"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范<a class="article-anchor" href="#注释规范" aria-hidden="true"></a></h2><p>这块倾向使用doxgen提供的注释规范，因为如果后续需要自动生成一份开发文档，这个就比较方便</p>
<p>不过，注释固然很重要, 但好的代码本身应该是自文档化的，有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字</p>
<ol>
<li><p>【注释风格】</p>
<ul>
<li>使用 <code>//</code> 或 <code>/* */</code>, 统一就好</li>
<li><code>//</code> 或 <code>/* */</code> 都可以; 但 <code>//</code> 更常用些</li>
<li>要在如何注释及注释风格上确保统一</li>
</ul>
</li>
<li><p>【文件注释】</p>
<ul>
<li>.h 文件要对所声明的类的功能和用法作简单说明，如果可以的话，可以在文件头上罗列一份<code>feature_list</code>或者<code>todo_list</code></li>
<li>.cc 文件通常包含了更多的实现细节或算法技巧讨论</li>
<li>如果你感觉这些实现细节或算法技巧讨论对于理解<code>.h</code>文件有帮助, 可以该注释挪到<code>.h</code>, 并在<code>.cc</code>中指出文档在<code>.h</code>中</li>
<li><p>不要简单的在<code>.h</code>和<code>.cc</code>间复制注释. 这种偏离了注释的实际意义</p>
<p>文件头举例如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*****************************************************************************<br>*  @file     auto_register_factory.h<br>*  @brief    可注册的工厂类模板<br>*  @note<br>*  C++反射机制的一种实现，基于类行为抽象而成<br>*****************************************************************************/</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>【类注释】<br> 每个类的定义都要附带一份注释, 描述类的功能和用法.</p>
<p> 举例如下:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**<br>* @class CSigleRegisterFactory<br>* @brief 一个支持自动注册的工厂类模板<br>* @note<br>* 注意，如果TKey是自定义数据类型，那么请重载其关系运算符哦，<br>* 具体看std::map的条件，通常仅需要重载运算符“&lt;”，详情请看<br>* https://msdn.microsoft.com/ZH-CN/library/s44w4h2s(v=VS.100,d=hv.2).aspx<br>* 在gcc下编译可能遇到的问题：http://blog.csdn.net/pb1995/article/details/49532285<br>* 仅仅支持一对一的模式<br>*/</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> TKey, <span class="hljs-keyword">typename</span> TBase&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CSingleRegisteredFactory</span> &#123;</span><br>...<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【函数注释】<br> 函数声明处注释描述函数功能，定义处描述函数实现</p>
<p> [函数声明]:<br> 注释位于声明之前, 对函数功能及用法进行描述. 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情</p>
<p> 函数声明处注释的内容:<br> 函数的输入输出.<br> 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.<br> 如果函数分配了空间, 需要由调用者释放.<br> 参数是否可以为 NULL.<br> 是否存在函数使用上的性能隐患.<br> 如果函数是可重入的, 其同步前提是什么?<br> 使用brief、param、return、note等来描述具体的注释块</p>
<p> 举例如下:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**<br>* @brief: 将某类注册到工厂类实例之中<br>* @param[in] TKey  Key  某类在外部检索时所用到的条件，通常采用字符串或枚举等类型<br>* @param[in|out] IForwarder&lt;TBase&gt;*  pobj  待注册到工厂类实例的基类指针，自动跳过空指针<br>* @param[in] bool  bIsOverWrite  如果为true，则重新注册此类，否则，直接释放待注册的基类指针<br>* @return 无<br>* @note<br>* 本类会自动管理所有想要注册到本类工厂的基类指针，因此需要对重复注册的类指针自动进行释放<br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterFactory</span><span class="hljs-params">(TKey key, ImpForwarder *ptr_obj, <span class="hljs-keyword">bool</span> is_overWrite = <span class="hljs-literal">false</span>)</span></span><br></code></pre></td></tr></table></figure>
<p> 但也要避免啰啰嗦嗦, 或做些显而易见的说明. 下面的注释就没有必要加上 “returns false otherwise”, 因为已经暗含其中了:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Returns true if the table cannot hold any more entries.</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsTableFull</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p> 注释构造/析构函数时, 切记读代码的人知道构造/析构函数是干啥的, 所以 “destroys this object” 这样的注释是没有意义的. 注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
<p> [函数定义]:<br> 每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要.<br> 不要 从 .h 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.</p>
</li>
<li><p>【变量注释】<br> 通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
<p> [类数据成员]:<br> 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明. 比如:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// Keeps track of the total number of entries in the table.</span><br><span class="hljs-comment">// Used to ensure we do not go over the limit. -1 means</span><br><span class="hljs-comment">// that we don't yet know how many entries the table has.</span><br><span class="hljs-keyword">int</span> num_total_entries_;<br></code></pre></td></tr></table></figure>
<p> [全局变量]:<br> 和数据成员一样, 所有全局变量也要注释说明含义及用途. 比如:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// The total number of tests cases that we run through in this regression test.<br>const int kNumTestCases = 6;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【实现注释】<br> 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.<br> [代码前注释]:<br> 巧妙或复杂的代码段前要加注释. 比如:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Divide result by two, taking into account that x</span><br><span class="hljs-comment">// contains the carry from the add.</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; result-&gt;size(); i++) &#123;<br>    x = (x &lt;&lt; <span class="hljs-number">8</span>) + (*result)[i];<br>    (*result)[i] = x &gt;&gt; <span class="hljs-number">1</span>;<br>    x &amp;= <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p> [行注释]:<br> 比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// If we have enough memory, mmap the data portion too.</span><br>mmap_budget = max&lt;int64&gt;(<span class="hljs-number">0</span>, mmap_budget - index_-&gt;length());<br><span class="hljs-keyword">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))<br>    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Error already logged.</span><br></code></pre></td></tr></table></figure>
<p> 注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
<p> 如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">DoSomething();                  	<span class="hljs-comment">// Comment here so the comments line up.</span><br>DoSomethingElseThatIsLonger();  	<span class="hljs-comment">// Comment here so there are two spaces between</span><br>                                <span class="hljs-comment">// the code and the comment.</span><br>&#123; <span class="hljs-comment">// One space before comment when opening a new scope is allowed,</span><br>  <span class="hljs-comment">// thus the comment lines up with the following comments and code.</span><br>  DoSomethingElse();  <span class="hljs-comment">// Two spaces before line comments normally.</span><br>&#125;<br><span class="hljs-literal">NULL</span>, <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.</span>..:<br></code></pre></td></tr></table></figure>
<p> 向函数传入 NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意. 例如, 对比:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> success = CalculateSomething(interesting_value,<br>                              <span class="hljs-number">10</span>,<br>                              <span class="hljs-literal">false</span>,<br>                              <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// What are these arguments??</span><br></code></pre></td></tr></table></figure>
<p> 和:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> success = CalculateSomething(interesting_value,<br>                                  <span class="hljs-number">10</span>,     	<span class="hljs-comment">// Default base value.</span><br>                                  <span class="hljs-literal">false</span>,  	<span class="hljs-comment">// Not the first time we're calling this.</span><br>                                  <span class="hljs-literal">NULL</span>);  	<span class="hljs-comment">// No callback.</span><br></code></pre></td></tr></table></figure>
<p> 或使用常量或描述性变量:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> kDefaultBaseValue = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> kFirstTimeCalling = <span class="hljs-literal">false</span>;<br>Callback *null_callback = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">bool</span> success = CalculateSomething(interesting_value,<br>                                  kDefaultBaseValue,<br>                                  kFirstTimeCalling,<br>                                  null_callback);<br></code></pre></td></tr></table></figure>
<p> 不允许:<br> 注意 永远不要 用自然语言翻译代码作为注释. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 现在, 检查 b 数组并确保 i 是否存在,</span><br><span class="hljs-comment">// 下一个元素是 i+1.</span><br>...        <span class="hljs-comment">// 天哪. 令人崩溃的注释.</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>【标点, 拼写和语法】<br> 注意标点, 拼写和语法; 写的好的注释比差的要易读的多.<br> 注释的通常写法是包含正确大小写和结尾句号的完整语句. 短一点的注释 (如代码行尾注释) 可以随意点, 依然要注意风格的一致性. 完整的语句可读性更好, 也可以说明该注释是完整的, 而不是一些不成熟的想法.</p>
<p> 虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有所帮助.</p>
</li>
<li><p>【TODO 注释】<br> 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释.<br> TODO 注释要使用全大写的字符串 TODO, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识. 冒号是可选的. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 TODO 格式进行查找. 添加 TODO 注释并不意味着你要自己来修正.</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// TODO(kl@gmail.com): Use a "*" here for concatenation operator.</span><br><span class="hljs-comment">// TODO(Zeke) change this to use relations.</span><br>如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November <span class="hljs-number">2005</span>”), 或者一个明确的事项 (“Remove <span class="hljs-keyword">this</span> code when all clients can handle XML responses.”).<br></code></pre></td></tr></table></figure>
</li>
<li><p>【弃用注释】<br> 通过弃用注释（DEPRECATED comments）以标记某接口点（interface points）已弃用。<br> 您可以写上包含全大写的 DEPRECATED 的注释，以标记某接口为弃用状态。注释可以放在接口声明前，或者同一行。</p>
<p> 在 DEPRECATED 一词后，留下您的名字，邮箱地址以及括号补充。</p>
<p> 仅仅标记接口为 DEPRECATED 并不会让大家不约而同地弃用，您还得亲自主动修正调用点（callsites），或是找个帮手。</p>
<p> 修正好的代码应该不会再涉及弃用接口点了，着实改用新接口点。如果您不知从何下手，可以找标记弃用注释的当事人一起商量。</p>
</li>
<li><p>【其它】<br>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;<br>对于 Chinese coders 来说, 用英文注释还是用中文注释, <code>it is a problem</code>, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；<br>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space，并且是<code>4个space</code>;<br>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了；另外，如果发现了一个bug，可以给它加个FIXME</p>
<p>[代码段分隔]<br>一个简单的函数里，其代码也是可以区分出不同的职能，在每部分职能切换的时候，加上换行</p>
</li>
</ol>
<hr>
<p><img src="/assets/2021-04-27/google_cplusplus_style_guide.png" alt="Google C++ Style Guide"></p>
<hr>
<h2 id="参考" class="article-heading"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="article-anchor" href="#参考" aria-hidden="true"></a></h2><ul>
<li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/" target="_blank" rel="noopener">Google 开源项目风格指南 - C++风格指南</a></li>
<li><a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">Google C++ Style Guide</a></li>
</ul>

              </div>
              <footer class="article-footer">
                
                <a href="lua_learn_notes.html" class="article-footer-prev" title="Lua学习笔记"><i class="fa fa-chevron-left"></i><span>上一页</span></a><a href="thinking_about_the_concurrency_model.html" class="article-footer-next" title="关于并发模型的思考"><span>下一页</span><i class="fa fa-chevron-right"></i></a>
              </footer>
              
            </div>
          </div>
          <aside id="article-toc" role="navigation">
            <div id="article-toc-inner">
              <strong class="sidebar-title">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命名规范"><span class="toc-text">命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通用命名规则"><span class="toc-text">通用命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件命名"><span class="toc-text">文件命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型命名"><span class="toc-text">类型命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量命名"><span class="toc-text">变量命名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注释规范"><span class="toc-text">注释规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
              <a href="#" id="article-toc-top">回到顶部</a>
            </div>
          </aside>
        </div>
      </article>
      <aside id="sidebar" role="navigation">
  <div class="inner">
    <strong class="sidebar-title">算法</strong><a href="char_image_merge.html" class="sidebar-link">字符图片合并</a><strong class="sidebar-title">软件工程</strong><a href="design_pattern.html" class="sidebar-link">设计模式</a><a href="use_cmake_notes.html" class="sidebar-link">CMake学习笔记</a><strong class="sidebar-title">编程语言</strong><a href="lua_learn_notes.html" class="sidebar-link">Lua学习笔记</a><strong class="sidebar-title">代码风格</strong><a href="cplusplus_style_guide.html" class="sidebar-link current">C++代码风格</a><strong class="sidebar-title">并发模型</strong><a href="thinking_about_the_concurrency_model.html" class="sidebar-link">关于并发模型的思考</a>
  </div>
</aside>

    </div>
  </div>
</div>

    <footer id="footer" class="wrapper">
  <div class="inner">
    <div id="footer-copyright">
      &copy; 2021 <a href="https://github.com/hexojs/hexo/graphs/contributors" target="_blank">Hexo</a><br>
      Documentation licensed under <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>.
    </div>
    <div id="footer-links">
      <a href="https://twitter.com/" class="footer-link" target="_blank"><i class="fa fa-twitter"></i></a>
      <a href="https://github.com/" class="footer-link" target="_blank"><i class="fa fa-github-alt"></i></a>
    </div>
  </div>
</footer>

  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <a href="/news/" class="mobile-nav-link">随笔</a><a href="/dev/" class="mobile-nav-link">开发</a><a href="/open_source/" class="mobile-nav-link">开源</a><a href="/tool/" class="mobile-nav-link">工具</a><a href="/about/" class="mobile-nav-link">关于我</a>
      <li class="mobile-nav-item">
        <a href="https://github.com/" class="mobile-nav-link" rel="external" target="_blank">GitHub</a>
      </li>
    </ul>
    
      <strong class="mobile-nav-title">算法</strong><a href="char_image_merge.html" class="mobile-nav-link">字符图片合并</a><strong class="mobile-nav-title">软件工程</strong><a href="design_pattern.html" class="mobile-nav-link">设计模式</a><a href="use_cmake_notes.html" class="mobile-nav-link">CMake学习笔记</a><strong class="mobile-nav-title">编程语言</strong><a href="lua_learn_notes.html" class="mobile-nav-link">Lua学习笔记</a><strong class="mobile-nav-title">代码风格</strong><a href="cplusplus_style_guide.html" class="mobile-nav-link current">C++代码风格</a><strong class="mobile-nav-title">并发模型</strong><a href="thinking_about_the_concurrency_model.html" class="mobile-nav-link">关于并发模型的思考</a>
    
  </div>
  <div id="mobile-lang-select-wrap">
    <span id="mobile-lang-select-label"><i class="fa fa-globe"></i><span>简体中文</span></span>
    <select id="mobile-lang-select" data-canonical="dev/cplusplus_style_guide.html">
      
        <option value="zh-cn" selected>简体中文</option>
      
    </select>
  </div>
</nav>
  <!-- Scripts -->
<!-- build:js build/js/main.js -->
<script src="/js/lang_select.js"></script>
<script src="/js/toc.js"></script>
<script src="/js/mobile_nav.js"></script>
<!-- endbuild -->

<!-- Algolia --><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>